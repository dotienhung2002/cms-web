{"ast":null,"code":"import _objectSpread from \"/Users/abc/Downloads/Workspace/projectFPT/cms-fusamate/cms-fusamate/cms-fusamte/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport mock from '../mock';\nimport jwt from 'jsonwebtoken';\nvar data = {\n  users: [{\n    id: 1,\n    fullName: 'John Doe',\n    username: 'johndoe',\n    password: 'admin',\n    avatar: require('@Assets/images/portrait/small/avatar-s-11.jpg').default,\n    email: 'admin@demo.com',\n    role: 'admin',\n    ability: [{\n      action: 'manage',\n      subject: 'all'\n    }],\n    extras: {\n      eCommerceCartItemsCount: 5\n    }\n  }, {\n    id: 2,\n    fullName: 'Jane Doe',\n    username: 'janedoe',\n    password: 'client',\n    avatar: require('@Assets/images/avatars/1-small.png').default,\n    email: 'client@demo.com',\n    role: 'client',\n    ability: [{\n      action: 'read',\n      subject: 'ACL'\n    }, {\n      action: 'read',\n      subject: 'Auth'\n    }],\n    extras: {\n      eCommerceCartItemsCount: 5\n    }\n  }]\n}; // ! These two secrets shall be in .env file and not in any other file\n\nvar jwtConfig = {\n  secret: 'dd5f3089-40c3-403d-af14-d0c228b05cb4',\n  refreshTokenSecret: '7c4c1c50-3230-45bf-9eae-c9b2e401c767',\n  expireTime: '10m',\n  refreshTokenExpireTime: '10m'\n};\nmock.onPost('/jwt/login').reply(function (request) {\n  var _JSON$parse = JSON.parse(request.data),\n      email = _JSON$parse.email,\n      password = _JSON$parse.password;\n\n  var error = {\n    email: ['Something went wrong']\n  };\n  var user = data.users.find(function (u) {\n    return u.email === email && u.password === password;\n  });\n\n  if (user) {\n    try {\n      var accessToken = jwt.sign({\n        id: user.id\n      }, jwtConfig.secret, {\n        expiresIn: jwtConfig.expireTime\n      });\n      var refreshToken = jwt.sign({\n        id: user.id\n      }, jwtConfig.refreshTokenSecret, {\n        expiresIn: jwtConfig.refreshTokenExpireTime\n      });\n\n      var userData = _objectSpread({}, user);\n\n      delete userData.password;\n      var response = {\n        userData: userData,\n        accessToken: accessToken,\n        refreshToken: refreshToken\n      };\n      return [200, response];\n    } catch (e) {\n      error = e;\n    }\n  } else {\n    error = {\n      email: ['Email or Password is Invalid']\n    };\n  }\n\n  return [400, {\n    error: error\n  }];\n}); // mock.onPost('/jwt/register').reply(request => {\n//   if (request.data.length > 0) {\n//     const { email, password, username } = JSON.parse(request.data)\n//     const isEmailAlreadyInUse = data.users.find(user => user.email === email)\n//     const isUsernameAlreadyInUse = data.users.find(user => user.username === username)\n//     const error = {\n//       email: isEmailAlreadyInUse ? 'This email is already in use.' : null,\n//       username: isUsernameAlreadyInUse ? 'This username is already in use.' : null\n//     }\n//     if (!error.username && !error.email) {\n//       const userData = {\n//         email,\n//         password,\n//         username,\n//         fullName: '',\n//         avatar: null,\n//         role: 'admin',\n//         ability: [\n//           {\n//             action: 'manage',\n//             subject: 'all'\n//           }\n//         ]\n//       }\n//       // Add user id\n//       const length = data.users.length\n//       let lastIndex = 0\n//       if (length) {\n//         lastIndex = data.users[length - 1].id\n//       }\n//       userData.id = lastIndex + 1\n//       data.users.push(userData)\n//       const accessToken = jwt.sign({ id: userData.id }, jwtConfig.secret, { expiresIn: jwtConfig.expireTime })\n//       const user = Object.assign({}, userData)\n//       delete user['password']\n//       const response = { user, accessToken }\n//       return [200, response]\n//     } else {\n//       return [200, { error }]\n//     }\n//   }\n// })\n// mock.onPost('/jwt/refresh-token').reply(request => {\n//   const { refreshToken } = JSON.parse(request.data)\n//   try {\n//     const { id } = jwt.verify(refreshToken, jwtConfig.refreshTokenSecret)\n//     const userData = { ...data.users.find(user => user.id === id) }\n//     const newAccessToken = jwt.sign({ id: userData.id }, jwtConfig.secret, { expiresIn: jwtConfig.expiresIn })\n//     const newRefreshToken = jwt.sign({ id: userData.id }, jwtConfig.refreshTokenSecret, {\n//       expiresIn: jwtConfig.refreshTokenExpireTime\n//     })\n//     delete userData.password\n//     const response = {\n//       userData,\n//       accessToken: newAccessToken,\n//       refreshToken: newRefreshToken\n//     }\n//     return [200, response]\n//   } catch (e) {\n//     const error = 'Invalid refresh token'\n//     return [401, { error }]\n//   }\n// })","map":{"version":3,"sources":["/Users/abc/Downloads/Workspace/projectFPT/cms-fusamate/cms-fusamate/cms-fusamte/src/@fake-db/jwt/index.js"],"names":["mock","jwt","data","users","id","fullName","username","password","avatar","require","default","email","role","ability","action","subject","extras","eCommerceCartItemsCount","jwtConfig","secret","refreshTokenSecret","expireTime","refreshTokenExpireTime","onPost","reply","request","JSON","parse","error","user","find","u","accessToken","sign","expiresIn","refreshToken","userData","response","e"],"mappings":";AAAA,OAAOA,IAAP,MAAiB,SAAjB;AACA,OAAOC,GAAP,MAAgB,cAAhB;AAEA,IAAMC,IAAI,GAAG;AACXC,EAAAA,KAAK,EAAE,CACL;AACEC,IAAAA,EAAE,EAAE,CADN;AAEEC,IAAAA,QAAQ,EAAE,UAFZ;AAGEC,IAAAA,QAAQ,EAAE,SAHZ;AAIEC,IAAAA,QAAQ,EAAE,OAJZ;AAKEC,IAAAA,MAAM,EAAEC,OAAO,CAAC,+CAAD,CAAP,CAAyDC,OALnE;AAMEC,IAAAA,KAAK,EAAE,gBANT;AAOEC,IAAAA,IAAI,EAAE,OAPR;AAQEC,IAAAA,OAAO,EAAE,CACP;AACEC,MAAAA,MAAM,EAAE,QADV;AAEEC,MAAAA,OAAO,EAAE;AAFX,KADO,CARX;AAcEC,IAAAA,MAAM,EAAE;AACNC,MAAAA,uBAAuB,EAAE;AADnB;AAdV,GADK,EAmBL;AACEb,IAAAA,EAAE,EAAE,CADN;AAEEC,IAAAA,QAAQ,EAAE,UAFZ;AAGEC,IAAAA,QAAQ,EAAE,SAHZ;AAIEC,IAAAA,QAAQ,EAAE,QAJZ;AAKEC,IAAAA,MAAM,EAAEC,OAAO,CAAC,oCAAD,CAAP,CAA8CC,OALxD;AAMEC,IAAAA,KAAK,EAAE,iBANT;AAOEC,IAAAA,IAAI,EAAE,QAPR;AAQEC,IAAAA,OAAO,EAAE,CACP;AACEC,MAAAA,MAAM,EAAE,MADV;AAEEC,MAAAA,OAAO,EAAE;AAFX,KADO,EAKP;AACED,MAAAA,MAAM,EAAE,MADV;AAEEC,MAAAA,OAAO,EAAE;AAFX,KALO,CARX;AAkBEC,IAAAA,MAAM,EAAE;AACNC,MAAAA,uBAAuB,EAAE;AADnB;AAlBV,GAnBK;AADI,CAAb,C,CA6CA;;AACA,IAAMC,SAAS,GAAG;AAChBC,EAAAA,MAAM,EAAE,sCADQ;AAEhBC,EAAAA,kBAAkB,EAAE,sCAFJ;AAGhBC,EAAAA,UAAU,EAAE,KAHI;AAIhBC,EAAAA,sBAAsB,EAAE;AAJR,CAAlB;AAOAtB,IAAI,CAACuB,MAAL,CAAY,YAAZ,EAA0BC,KAA1B,CAAgC,UAAAC,OAAO,EAAI;AAAA,oBACbC,IAAI,CAACC,KAAL,CAAWF,OAAO,CAACvB,IAAnB,CADa;AAAA,MACjCS,KADiC,eACjCA,KADiC;AAAA,MAC1BJ,QAD0B,eAC1BA,QAD0B;;AAGzC,MAAIqB,KAAK,GAAG;AACVjB,IAAAA,KAAK,EAAE,CAAC,sBAAD;AADG,GAAZ;AAIA,MAAMkB,IAAI,GAAG3B,IAAI,CAACC,KAAL,CAAW2B,IAAX,CAAgB,UAAAC,CAAC;AAAA,WAAIA,CAAC,CAACpB,KAAF,KAAYA,KAAZ,IAAqBoB,CAAC,CAACxB,QAAF,KAAeA,QAAxC;AAAA,GAAjB,CAAb;;AAEA,MAAIsB,IAAJ,EAAU;AACR,QAAI;AACF,UAAMG,WAAW,GAAG/B,GAAG,CAACgC,IAAJ,CAAS;AAAE7B,QAAAA,EAAE,EAAEyB,IAAI,CAACzB;AAAX,OAAT,EAA0Bc,SAAS,CAACC,MAApC,EAA4C;AAAEe,QAAAA,SAAS,EAAEhB,SAAS,CAACG;AAAvB,OAA5C,CAApB;AACA,UAAMc,YAAY,GAAGlC,GAAG,CAACgC,IAAJ,CAAS;AAAE7B,QAAAA,EAAE,EAAEyB,IAAI,CAACzB;AAAX,OAAT,EAA0Bc,SAAS,CAACE,kBAApC,EAAwD;AAC3Ec,QAAAA,SAAS,EAAEhB,SAAS,CAACI;AADsD,OAAxD,CAArB;;AAIA,UAAMc,QAAQ,qBAAQP,IAAR,CAAd;;AAEA,aAAOO,QAAQ,CAAC7B,QAAhB;AAEA,UAAM8B,QAAQ,GAAG;AACfD,QAAAA,QAAQ,EAARA,QADe;AAEfJ,QAAAA,WAAW,EAAXA,WAFe;AAGfG,QAAAA,YAAY,EAAZA;AAHe,OAAjB;AAMA,aAAO,CAAC,GAAD,EAAME,QAAN,CAAP;AACD,KAjBD,CAiBE,OAAOC,CAAP,EAAU;AACVV,MAAAA,KAAK,GAAGU,CAAR;AACD;AACF,GArBD,MAqBO;AACLV,IAAAA,KAAK,GAAG;AACNjB,MAAAA,KAAK,EAAE,CAAC,8BAAD;AADD,KAAR;AAGD;;AAED,SAAO,CAAC,GAAD,EAAM;AAAEiB,IAAAA,KAAK,EAALA;AAAF,GAAN,CAAP;AACD,CArCD,E,CAuCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import mock from '../mock'\nimport jwt from 'jsonwebtoken'\n\nconst data = {\n  users: [\n    {\n      id: 1,\n      fullName: 'John Doe',\n      username: 'johndoe',\n      password: 'admin',\n      avatar: require('@Assets/images/portrait/small/avatar-s-11.jpg').default,\n      email: 'admin@demo.com',\n      role: 'admin',\n      ability: [\n        {\n          action: 'manage',\n          subject: 'all'\n        }\n      ],\n      extras: {\n        eCommerceCartItemsCount: 5\n      }\n    },\n    {\n      id: 2,\n      fullName: 'Jane Doe',\n      username: 'janedoe',\n      password: 'client',\n      avatar: require('@Assets/images/avatars/1-small.png').default,\n      email: 'client@demo.com',\n      role: 'client',\n      ability: [\n        {\n          action: 'read',\n          subject: 'ACL'\n        },\n        {\n          action: 'read',\n          subject: 'Auth'\n        }\n      ],\n      extras: {\n        eCommerceCartItemsCount: 5\n      }\n    }\n  ]\n}\n\n// ! These two secrets shall be in .env file and not in any other file\nconst jwtConfig = {\n  secret: 'dd5f3089-40c3-403d-af14-d0c228b05cb4',\n  refreshTokenSecret: '7c4c1c50-3230-45bf-9eae-c9b2e401c767',\n  expireTime: '10m',\n  refreshTokenExpireTime: '10m'\n}\n\nmock.onPost('/jwt/login').reply(request => {\n  const { email, password } = JSON.parse(request.data)\n\n  let error = {\n    email: ['Something went wrong']\n  }\n\n  const user = data.users.find(u => u.email === email && u.password === password)\n\n  if (user) {\n    try {\n      const accessToken = jwt.sign({ id: user.id }, jwtConfig.secret, { expiresIn: jwtConfig.expireTime })\n      const refreshToken = jwt.sign({ id: user.id }, jwtConfig.refreshTokenSecret, {\n        expiresIn: jwtConfig.refreshTokenExpireTime\n      })\n\n      const userData = { ...user }\n\n      delete userData.password\n\n      const response = {\n        userData,\n        accessToken,\n        refreshToken\n      }\n\n      return [200, response]\n    } catch (e) {\n      error = e\n    }\n  } else {\n    error = {\n      email: ['Email or Password is Invalid']\n    }\n  }\n\n  return [400, { error }]\n})\n\n// mock.onPost('/jwt/register').reply(request => {\n//   if (request.data.length > 0) {\n//     const { email, password, username } = JSON.parse(request.data)\n//     const isEmailAlreadyInUse = data.users.find(user => user.email === email)\n//     const isUsernameAlreadyInUse = data.users.find(user => user.username === username)\n//     const error = {\n//       email: isEmailAlreadyInUse ? 'This email is already in use.' : null,\n//       username: isUsernameAlreadyInUse ? 'This username is already in use.' : null\n//     }\n\n//     if (!error.username && !error.email) {\n//       const userData = {\n//         email,\n//         password,\n//         username,\n//         fullName: '',\n//         avatar: null,\n//         role: 'admin',\n//         ability: [\n//           {\n//             action: 'manage',\n//             subject: 'all'\n//           }\n//         ]\n//       }\n\n//       // Add user id\n//       const length = data.users.length\n//       let lastIndex = 0\n//       if (length) {\n//         lastIndex = data.users[length - 1].id\n//       }\n//       userData.id = lastIndex + 1\n\n//       data.users.push(userData)\n\n//       const accessToken = jwt.sign({ id: userData.id }, jwtConfig.secret, { expiresIn: jwtConfig.expireTime })\n\n//       const user = Object.assign({}, userData)\n//       delete user['password']\n//       const response = { user, accessToken }\n\n//       return [200, response]\n//     } else {\n//       return [200, { error }]\n//     }\n//   }\n// })\n\n// mock.onPost('/jwt/refresh-token').reply(request => {\n//   const { refreshToken } = JSON.parse(request.data)\n\n//   try {\n//     const { id } = jwt.verify(refreshToken, jwtConfig.refreshTokenSecret)\n\n//     const userData = { ...data.users.find(user => user.id === id) }\n\n//     const newAccessToken = jwt.sign({ id: userData.id }, jwtConfig.secret, { expiresIn: jwtConfig.expiresIn })\n//     const newRefreshToken = jwt.sign({ id: userData.id }, jwtConfig.refreshTokenSecret, {\n//       expiresIn: jwtConfig.refreshTokenExpireTime\n//     })\n\n//     delete userData.password\n//     const response = {\n//       userData,\n//       accessToken: newAccessToken,\n//       refreshToken: newRefreshToken\n//     }\n\n//     return [200, response]\n//   } catch (e) {\n//     const error = 'Invalid refresh token'\n//     return [401, { error }]\n//   }\n// })\n"]},"metadata":{},"sourceType":"module"}