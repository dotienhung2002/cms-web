{"ast":null,"code":"function t() {\n  return (t = Object.assign || function (t) {\n    for (var e = 1; e < arguments.length; e++) {\n      var n = arguments[e];\n      for (var o in n) {\n        Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);\n      }\n    }\n    return t;\n  }).apply(this, arguments);\n}\nfunction e(t) {\n  if (\"undefined\" != typeof window && window.navigator) return !!navigator.userAgent.match(t);\n}\nvar n = e(/(?:Trident.*rv[ :]?11\\.|msie|iemobile|Windows Phone)/i),\n  o = e(/Edge/i),\n  i = e(/firefox/i),\n  r = e(/safari/i) && !e(/chrome/i) && !e(/android/i),\n  a = e(/iP(ad|od|hone)/i),\n  l = e(/chrome/i) && e(/android/i),\n  s = {\n    capture: !1,\n    passive: !1\n  };\nfunction c(t, e, o) {\n  t.addEventListener(e, o, !n && s);\n}\nfunction u(t, e, o) {\n  t.removeEventListener(e, o, !n && s);\n}\nfunction d(t, e) {\n  if (e) {\n    if (\">\" === e[0] && (e = e.substring(1)), t) try {\n      if (t.matches) return t.matches(e);\n      if (t.msMatchesSelector) return t.msMatchesSelector(e);\n      if (t.webkitMatchesSelector) return t.webkitMatchesSelector(e);\n    } catch (t) {\n      return !1;\n    }\n    return !1;\n  }\n}\nfunction h(t) {\n  return t.host && t !== document && t.host.nodeType ? t.host : t.parentNode;\n}\nfunction f(t, e, n, o) {\n  if (t) {\n    n = n || document;\n    do {\n      if (null != e && (\">\" === e[0] ? t.parentNode === n && d(t, e) : d(t, e)) || o && t === n) return t;\n      if (t === n) break;\n    } while (t = h(t));\n  }\n  return null;\n}\nvar p,\n  g = /\\s+/g;\nfunction v(t, e, n) {\n  if (t && e) if (t.classList) t.classList[n ? \"add\" : \"remove\"](e);else {\n    var o = (\" \" + t.className + \" \").replace(g, \" \").replace(\" \" + e + \" \", \" \");\n    t.className = (o + (n ? \" \" + e : \"\")).replace(g, \" \");\n  }\n}\nfunction m(t, e, n) {\n  var o = t && t.style;\n  if (o) {\n    if (void 0 === n) return document.defaultView && document.defaultView.getComputedStyle ? n = document.defaultView.getComputedStyle(t, \"\") : t.currentStyle && (n = t.currentStyle), void 0 === e ? n : n[e];\n    e in o || -1 !== e.indexOf(\"webkit\") || (e = \"-webkit-\" + e), o[e] = n + (\"string\" == typeof n ? \"\" : \"px\");\n  }\n}\nfunction b(t, e) {\n  var n = \"\";\n  if (\"string\" == typeof t) n = t;else do {\n    var o = m(t, \"transform\");\n    o && \"none\" !== o && (n = o + \" \" + n);\n  } while (!e && (t = t.parentNode));\n  var i = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;\n  return i && new i(n);\n}\nfunction w(t, e, n) {\n  if (t) {\n    var o = t.getElementsByTagName(e),\n      i = 0,\n      r = o.length;\n    if (n) for (; i < r; i++) {\n      n(o[i], i);\n    }\n    return o;\n  }\n  return [];\n}\nfunction E() {\n  return document.scrollingElement || document.documentElement;\n}\nfunction y(t, e, o, i, r) {\n  if (t.getBoundingClientRect || t === window) {\n    var a, l, s, c, u, d, h;\n    if (t !== window && t !== E() ? (l = (a = t.getBoundingClientRect()).top, s = a.left, c = a.bottom, u = a.right, d = a.height, h = a.width) : (l = 0, s = 0, c = window.innerHeight, u = window.innerWidth, d = window.innerHeight, h = window.innerWidth), (e || o) && t !== window && (r = r || t.parentNode, !n)) do {\n      if (r && r.getBoundingClientRect && (\"none\" !== m(r, \"transform\") || o && \"static\" !== m(r, \"position\"))) {\n        var f = r.getBoundingClientRect();\n        l -= f.top + parseInt(m(r, \"border-top-width\")), s -= f.left + parseInt(m(r, \"border-left-width\")), c = l + a.height, u = s + a.width;\n        break;\n      }\n    } while (r = r.parentNode);\n    if (i && t !== window) {\n      var p = b(r || t),\n        g = p && p.a,\n        v = p && p.d;\n      p && (c = (l /= v) + (d /= v), u = (s /= g) + (h /= g));\n    }\n    return {\n      top: l,\n      left: s,\n      bottom: c,\n      right: u,\n      width: h,\n      height: d\n    };\n  }\n}\nfunction D(t, e, n) {\n  for (var o = x(t, !0), i = y(t)[e]; o;) {\n    var r = y(o)[n];\n    if (!(\"top\" === n || \"left\" === n ? i >= r : i <= r)) return o;\n    if (o === E()) break;\n    o = x(o, !1);\n  }\n  return !1;\n}\nfunction _(t, e, n) {\n  for (var o = 0, i = 0, r = t.children; i < r.length;) {\n    if (\"none\" !== r[i].style.display && r[i] !== It.ghost && r[i] !== It.dragged && f(r[i], n.draggable, t, !1)) {\n      if (o === e) return r[i];\n      o++;\n    }\n    i++;\n  }\n  return null;\n}\nfunction S(t, e) {\n  for (var n = t.lastElementChild; n && (n === It.ghost || \"none\" === m(n, \"display\") || e && !d(n, e));) {\n    n = n.previousElementSibling;\n  }\n  return n || null;\n}\nfunction C(t, e) {\n  var n = 0;\n  if (!t || !t.parentNode) return -1;\n  for (; t = t.previousElementSibling;) {\n    \"TEMPLATE\" === t.nodeName.toUpperCase() || t === It.clone || e && !d(t, e) || n++;\n  }\n  return n;\n}\nfunction T(t) {\n  var e = 0,\n    n = 0,\n    o = E();\n  if (t) do {\n    var i = b(t);\n    e += t.scrollLeft * i.a, n += t.scrollTop * i.d;\n  } while (t !== o && (t = t.parentNode));\n  return [e, n];\n}\nfunction x(t, e) {\n  if (!t || !t.getBoundingClientRect) return E();\n  var n = t,\n    o = !1;\n  do {\n    if (n.clientWidth < n.scrollWidth || n.clientHeight < n.scrollHeight) {\n      var i = m(n);\n      if (n.clientWidth < n.scrollWidth && (\"auto\" == i.overflowX || \"scroll\" == i.overflowX) || n.clientHeight < n.scrollHeight && (\"auto\" == i.overflowY || \"scroll\" == i.overflowY)) {\n        if (!n.getBoundingClientRect || n === document.body) return E();\n        if (o || e) return n;\n        o = !0;\n      }\n    }\n  } while (n = n.parentNode);\n  return E();\n}\nfunction M(t, e) {\n  return Math.round(t.top) === Math.round(e.top) && Math.round(t.left) === Math.round(e.left) && Math.round(t.height) === Math.round(e.height) && Math.round(t.width) === Math.round(e.width);\n}\nfunction N(t, e) {\n  return function () {\n    if (!p) {\n      var n = arguments,\n        o = this;\n      1 === n.length ? t.call(o, n[0]) : t.apply(o, n), p = setTimeout(function () {\n        p = void 0;\n      }, e);\n    }\n  };\n}\nfunction O(t, e, n) {\n  t.scrollLeft += e, t.scrollTop += n;\n}\nfunction A(t) {\n  var e = window.Polymer,\n    n = window.jQuery || window.Zepto;\n  return e && e.dom ? e.dom(t).cloneNode(!0) : n ? n(t).clone(!0)[0] : t.cloneNode(!0);\n}\nfunction I(t, e) {\n  m(t, \"position\", \"absolute\"), m(t, \"top\", e.top), m(t, \"left\", e.left), m(t, \"width\", e.width), m(t, \"height\", e.height);\n}\nfunction P(t) {\n  m(t, \"position\", \"\"), m(t, \"top\", \"\"), m(t, \"left\", \"\"), m(t, \"width\", \"\"), m(t, \"height\", \"\");\n}\nvar k = \"Sortable\" + new Date().getTime(),\n  R = [],\n  X = {\n    initializeByDefault: !0\n  },\n  Y = {\n    mount: function mount(t) {\n      for (var e in X) {\n        X.hasOwnProperty(e) && !(e in t) && (t[e] = X[e]);\n      }\n      R.push(t);\n    },\n    pluginEvent: function pluginEvent(e, n, o) {\n      var i = this;\n      this.eventCanceled = !1, o.cancel = function () {\n        i.eventCanceled = !0;\n      };\n      var r = e + \"Global\";\n      R.forEach(function (i) {\n        n[i.pluginName] && (n[i.pluginName][r] && n[i.pluginName][r](t({\n          sortable: n\n        }, o)), n.options[i.pluginName] && n[i.pluginName][e] && n[i.pluginName][e](t({\n          sortable: n\n        }, o)));\n      });\n    },\n    initializePlugins: function initializePlugins(t, e, n, o) {\n      for (var i in R.forEach(function (o) {\n        var i = o.pluginName;\n        if (t.options[i] || o.initializeByDefault) {\n          var r = new o(t, e, t.options);\n          r.sortable = t, r.options = t.options, t[i] = r, Object.assign(n, r.defaults);\n        }\n      }), t.options) {\n        if (t.options.hasOwnProperty(i)) {\n          var r = this.modifyOption(t, i, t.options[i]);\n          void 0 !== r && (t.options[i] = r);\n        }\n      }\n    },\n    getEventProperties: function getEventProperties(t, e) {\n      var n = {};\n      return R.forEach(function (o) {\n        \"function\" == typeof o.eventProperties && Object.assign(n, o.eventProperties.call(e[o.pluginName], t));\n      }), n;\n    },\n    modifyOption: function modifyOption(t, e, n) {\n      var o;\n      return R.forEach(function (i) {\n        t[i.pluginName] && i.optionListeners && \"function\" == typeof i.optionListeners[e] && (o = i.optionListeners[e].call(t[i.pluginName], n));\n      }), o;\n    }\n  };\nfunction B(e) {\n  var i = e.sortable,\n    r = e.rootEl,\n    a = e.name,\n    l = e.targetEl,\n    s = e.cloneEl,\n    c = e.toEl,\n    u = e.fromEl,\n    d = e.oldIndex,\n    h = e.newIndex,\n    f = e.oldDraggableIndex,\n    p = e.newDraggableIndex,\n    g = e.originalEvent,\n    v = e.putSortable,\n    m = e.extraEventProperties;\n  if (i = i || r && r[k]) {\n    var b,\n      w = i.options,\n      E = \"on\" + a.charAt(0).toUpperCase() + a.substr(1);\n    !window.CustomEvent || n || o ? (b = document.createEvent(\"Event\")).initEvent(a, !0, !0) : b = new CustomEvent(a, {\n      bubbles: !0,\n      cancelable: !0\n    }), b.to = c || r, b.from = u || r, b.item = l || r, b.clone = s, b.oldIndex = d, b.newIndex = h, b.oldDraggableIndex = f, b.newDraggableIndex = p, b.originalEvent = g, b.pullMode = v ? v.lastPutMode : void 0;\n    var y = t({}, m, Y.getEventProperties(a, i));\n    for (var D in y) {\n      b[D] = y[D];\n    }\n    r && r.dispatchEvent(b), w[E] && w[E].call(i, b);\n  }\n}\nvar H = function H(e, n, o) {\n  var i = void 0 === o ? {} : o,\n    r = i.evt,\n    a = function (t, e) {\n      if (null == t) return {};\n      var n,\n        o,\n        i = {},\n        r = Object.keys(t);\n      for (o = 0; o < r.length; o++) {\n        e.indexOf(n = r[o]) >= 0 || (i[n] = t[n]);\n      }\n      return i;\n    }(i, [\"evt\"]);\n  Y.pluginEvent.bind(It)(e, n, t({\n    dragEl: L,\n    parentEl: K,\n    ghostEl: W,\n    rootEl: j,\n    nextEl: z,\n    lastDownEl: G,\n    cloneEl: U,\n    cloneHidden: q,\n    dragStarted: lt,\n    putSortable: tt,\n    activeSortable: It.active,\n    originalEvent: r,\n    oldIndex: V,\n    oldDraggableIndex: Q,\n    newIndex: Z,\n    newDraggableIndex: $,\n    hideGhostForTarget: xt,\n    unhideGhostForTarget: Mt,\n    cloneNowHidden: function cloneNowHidden() {\n      q = !0;\n    },\n    cloneNowShown: function cloneNowShown() {\n      q = !1;\n    },\n    dispatchSortableEvent: function dispatchSortableEvent(t) {\n      F({\n        sortable: n,\n        name: t,\n        originalEvent: r\n      });\n    }\n  }, a));\n};\nfunction F(e) {\n  B(t({\n    putSortable: tt,\n    cloneEl: U,\n    targetEl: L,\n    rootEl: j,\n    oldIndex: V,\n    oldDraggableIndex: Q,\n    newIndex: Z,\n    newDraggableIndex: $\n  }, e));\n}\nvar L,\n  K,\n  W,\n  j,\n  z,\n  G,\n  U,\n  q,\n  V,\n  Z,\n  Q,\n  $,\n  J,\n  tt,\n  et,\n  nt,\n  ot,\n  it,\n  rt,\n  at,\n  lt,\n  st,\n  ct,\n  ut,\n  dt,\n  ht = !1,\n  ft = !1,\n  pt = [],\n  gt = !1,\n  vt = !1,\n  mt = [],\n  bt = !1,\n  wt = [],\n  Et = \"undefined\" != typeof document,\n  yt = a,\n  Dt = o || n ? \"cssFloat\" : \"float\",\n  _t = Et && !l && !a && \"draggable\" in document.createElement(\"div\"),\n  St = function () {\n    if (Et) {\n      if (n) return !1;\n      var t = document.createElement(\"x\");\n      return t.style.cssText = \"pointer-events:auto\", \"auto\" === t.style.pointerEvents;\n    }\n  }(),\n  Ct = function Ct(t, e) {\n    var n = m(t),\n      o = parseInt(n.width) - parseInt(n.paddingLeft) - parseInt(n.paddingRight) - parseInt(n.borderLeftWidth) - parseInt(n.borderRightWidth),\n      i = _(t, 0, e),\n      r = _(t, 1, e),\n      a = i && m(i),\n      l = r && m(r),\n      s = a && parseInt(a.marginLeft) + parseInt(a.marginRight) + y(i).width,\n      c = l && parseInt(l.marginLeft) + parseInt(l.marginRight) + y(r).width;\n    return \"flex\" === n.display ? \"column\" === n.flexDirection || \"column-reverse\" === n.flexDirection ? \"vertical\" : \"horizontal\" : \"grid\" === n.display ? n.gridTemplateColumns.split(\" \").length <= 1 ? \"vertical\" : \"horizontal\" : i && a.float && \"none\" !== a.float ? !r || \"both\" !== l.clear && l.clear !== (\"left\" === a.float ? \"left\" : \"right\") ? \"horizontal\" : \"vertical\" : i && (\"block\" === a.display || \"flex\" === a.display || \"table\" === a.display || \"grid\" === a.display || s >= o && \"none\" === n[Dt] || r && \"none\" === n[Dt] && s + c > o) ? \"vertical\" : \"horizontal\";\n  },\n  Tt = function Tt(t) {\n    function e(t, n) {\n      return function (o, i, r, a) {\n        if (null == t && (n || o.options.group.name && i.options.group.name && o.options.group.name === i.options.group.name)) return !0;\n        if (null == t || !1 === t) return !1;\n        if (n && \"clone\" === t) return t;\n        if (\"function\" == typeof t) return e(t(o, i, r, a), n)(o, i, r, a);\n        var l = (n ? o : i).options.group.name;\n        return !0 === t || \"string\" == typeof t && t === l || t.join && t.indexOf(l) > -1;\n      };\n    }\n    var n = {},\n      o = t.group;\n    o && \"object\" == typeof o || (o = {\n      name: o\n    }), n.name = o.name, n.checkPull = e(o.pull, !0), n.checkPut = e(o.put), n.revertClone = o.revertClone, t.group = n;\n  },\n  xt = function xt() {\n    !St && W && m(W, \"display\", \"none\");\n  },\n  Mt = function Mt() {\n    !St && W && m(W, \"display\", \"\");\n  };\nEt && document.addEventListener(\"click\", function (t) {\n  if (ft) return t.preventDefault(), t.stopPropagation && t.stopPropagation(), t.stopImmediatePropagation && t.stopImmediatePropagation(), ft = !1, !1;\n}, !0);\nvar Nt,\n  Ot = function Ot(t) {\n    if (L) {\n      var e = (i = (t = t.touches ? t.touches[0] : t).clientX, r = t.clientY, pt.some(function (t) {\n        if (!S(t)) {\n          var e = y(t),\n            n = t[k].options.emptyInsertThreshold;\n          return n && i >= e.left - n && i <= e.right + n && r >= e.top - n && r <= e.bottom + n ? a = t : void 0;\n        }\n      }), a);\n      if (e) {\n        var n = {};\n        for (var o in t) {\n          t.hasOwnProperty(o) && (n[o] = t[o]);\n        }\n        n.target = n.rootEl = e, n.preventDefault = void 0, n.stopPropagation = void 0, e[k]._onDragOver(n);\n      }\n    }\n    var i, r, a;\n  },\n  At = function At(t) {\n    L && L.parentNode[k]._isOutsideThisEl(t.target);\n  };\nfunction It(e, n) {\n  if (!e || !e.nodeType || 1 !== e.nodeType) throw \"Sortable: `el` must be an HTMLElement, not \" + {}.toString.call(e);\n  this.el = e, this.options = n = Object.assign({}, n), e[k] = this;\n  var o,\n    i,\n    r = {\n      group: null,\n      sort: !0,\n      disabled: !1,\n      store: null,\n      handle: null,\n      draggable: /^[uo]l$/i.test(e.nodeName) ? \">li\" : \">*\",\n      swapThreshold: 1,\n      invertSwap: !1,\n      invertedSwapThreshold: null,\n      removeCloneOnHide: !0,\n      direction: function direction() {\n        return Ct(e, this.options);\n      },\n      ghostClass: \"sortable-ghost\",\n      chosenClass: \"sortable-chosen\",\n      dragClass: \"sortable-drag\",\n      ignore: \"a, img\",\n      filter: null,\n      preventOnFilter: !0,\n      animation: 0,\n      easing: null,\n      setData: function setData(t, e) {\n        t.setData(\"Text\", e.textContent);\n      },\n      dropBubble: !1,\n      dragoverBubble: !1,\n      dataIdAttr: \"data-id\",\n      delay: 0,\n      delayOnTouchOnly: !1,\n      touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,\n      forceFallback: !1,\n      fallbackClass: \"sortable-fallback\",\n      fallbackOnBody: !1,\n      fallbackTolerance: 0,\n      fallbackOffset: {\n        x: 0,\n        y: 0\n      },\n      supportPointer: !1 !== It.supportPointer && \"PointerEvent\" in window,\n      emptyInsertThreshold: 5\n    };\n  for (var a in Y.initializePlugins(this, e, r), r) {\n    !(a in n) && (n[a] = r[a]);\n  }\n  for (var l in Tt(n), this) {\n    \"_\" === l.charAt(0) && \"function\" == typeof this[l] && (this[l] = this[l].bind(this));\n  }\n  this.nativeDraggable = !n.forceFallback && _t, this.nativeDraggable && (this.options.touchStartThreshold = 1), n.supportPointer ? c(e, \"pointerdown\", this._onTapStart) : (c(e, \"mousedown\", this._onTapStart), c(e, \"touchstart\", this._onTapStart)), this.nativeDraggable && (c(e, \"dragover\", this), c(e, \"dragenter\", this)), pt.push(this.el), n.store && n.store.get && this.sort(n.store.get(this) || []), Object.assign(this, (i = [], {\n    captureAnimationState: function captureAnimationState() {\n      i = [], this.options.animation && [].slice.call(this.el.children).forEach(function (e) {\n        if (\"none\" !== m(e, \"display\") && void 0 !== e) {\n          i.push({\n            target: e,\n            rect: y(e)\n          });\n          var n = t({}, i[i.length - 1].rect);\n          if (e.thisAnimationDuration) {\n            var o = b(e, !0);\n            o && (n.top -= o.f, n.left -= o.e);\n          }\n          e.fromRect = n;\n        }\n      });\n    },\n    addAnimationState: function addAnimationState(t) {\n      i.push(t);\n    },\n    removeAnimationState: function removeAnimationState(t) {\n      i.splice(function (t, e) {\n        for (var n in t) {\n          if (t.hasOwnProperty(n)) for (var o in e) {\n            if (e.hasOwnProperty(o) && e[o] === t[n][o]) return Number(n);\n          }\n        }\n        return -1;\n      }(i, {\n        target: t\n      }), 1);\n    },\n    animateAll: function animateAll(t) {\n      var e = this;\n      if (!this.options.animation) return clearTimeout(o), void (\"function\" == typeof t && t());\n      var n = !1,\n        r = 0;\n      i.forEach(function (t) {\n        var o = 0,\n          i = t.target,\n          a = i.fromRect,\n          l = y(i),\n          s = i.prevFromRect,\n          c = i.prevToRect,\n          u = t.rect,\n          d = b(i, !0);\n        d && (l.top -= d.f, l.left -= d.e), i.toRect = l, i.thisAnimationDuration && M(s, l) && !M(a, l) && (u.top - l.top) / (u.left - l.left) == (a.top - l.top) / (a.left - l.left) && (o = function (t, e, n, o) {\n          return Math.sqrt(Math.pow(e.top - t.top, 2) + Math.pow(e.left - t.left, 2)) / Math.sqrt(Math.pow(e.top - n.top, 2) + Math.pow(e.left - n.left, 2)) * o.animation;\n        }(u, s, c, e.options)), M(l, a) || (i.prevFromRect = a, i.prevToRect = l, o || (o = e.options.animation), e.animate(i, u, l, o)), o && (n = !0, r = Math.max(r, o), clearTimeout(i.animationResetTimer), i.animationResetTimer = setTimeout(function () {\n          i.animationTime = 0, i.prevFromRect = null, i.fromRect = null, i.prevToRect = null, i.thisAnimationDuration = null;\n        }, o), i.thisAnimationDuration = o);\n      }), clearTimeout(o), n ? o = setTimeout(function () {\n        \"function\" == typeof t && t();\n      }, r) : \"function\" == typeof t && t(), i = [];\n    },\n    animate: function animate(t, e, n, o) {\n      if (o) {\n        m(t, \"transition\", \"\"), m(t, \"transform\", \"\");\n        var i = b(this.el),\n          r = (e.left - n.left) / (i && i.a || 1),\n          a = (e.top - n.top) / (i && i.d || 1);\n        t.animatingX = !!r, t.animatingY = !!a, m(t, \"transform\", \"translate3d(\" + r + \"px,\" + a + \"px,0)\"), this.forRepaintDummy = function (t) {\n          return t.offsetWidth;\n        }(t), m(t, \"transition\", \"transform \" + o + \"ms\" + (this.options.easing ? \" \" + this.options.easing : \"\")), m(t, \"transform\", \"translate3d(0,0,0)\"), \"number\" == typeof t.animated && clearTimeout(t.animated), t.animated = setTimeout(function () {\n          m(t, \"transition\", \"\"), m(t, \"transform\", \"\"), t.animated = !1, t.animatingX = !1, t.animatingY = !1;\n        }, o);\n      }\n    }\n  }));\n}\nfunction Pt(t, e, i, r, a, l, s, c) {\n  var u,\n    d,\n    h = t[k],\n    f = h.options.onMove;\n  return !window.CustomEvent || n || o ? (u = document.createEvent(\"Event\")).initEvent(\"move\", !0, !0) : u = new CustomEvent(\"move\", {\n    bubbles: !0,\n    cancelable: !0\n  }), u.to = e, u.from = t, u.dragged = i, u.draggedRect = r, u.related = a || e, u.relatedRect = l || y(e), u.willInsertAfter = c, u.originalEvent = s, t.dispatchEvent(u), f && (d = f.call(h, u, s)), d;\n}\nfunction kt(t) {\n  t.draggable = !1;\n}\nfunction Rt() {\n  bt = !1;\n}\nfunction Xt(t) {\n  for (var e = t.tagName + t.className + t.src + t.href + t.textContent, n = e.length, o = 0; n--;) {\n    o += e.charCodeAt(n);\n  }\n  return o.toString(36);\n}\nfunction Yt(t) {\n  return setTimeout(t, 0);\n}\nfunction Bt(t) {\n  return clearTimeout(t);\n}\nIt.prototype = {\n  constructor: It,\n  _isOutsideThisEl: function _isOutsideThisEl(t) {\n    this.el.contains(t) || t === this.el || (st = null);\n  },\n  _getDirection: function _getDirection(t, e) {\n    return \"function\" == typeof this.options.direction ? this.options.direction.call(this, t, e, L) : this.options.direction;\n  },\n  _onTapStart: function _onTapStart(t) {\n    if (t.cancelable) {\n      var e = this,\n        n = this.el,\n        o = this.options,\n        i = o.preventOnFilter,\n        a = t.type,\n        l = t.touches && t.touches[0] || t.pointerType && \"touch\" === t.pointerType && t,\n        s = (l || t).target,\n        c = t.target.shadowRoot && (t.path && t.path[0] || t.composedPath && t.composedPath()[0]) || s,\n        u = o.filter;\n      if (function (t) {\n        wt.length = 0;\n        for (var e = t.getElementsByTagName(\"input\"), n = e.length; n--;) {\n          var o = e[n];\n          o.checked && wt.push(o);\n        }\n      }(n), !L && !(/mousedown|pointerdown/.test(a) && 0 !== t.button || o.disabled) && !c.isContentEditable && (this.nativeDraggable || !r || !s || \"SELECT\" !== s.tagName.toUpperCase()) && !((s = f(s, o.draggable, n, !1)) && s.animated || G === s)) {\n        if (V = C(s), Q = C(s, o.draggable), \"function\" == typeof u) {\n          if (u.call(this, t, s, this)) return F({\n            sortable: e,\n            rootEl: c,\n            name: \"filter\",\n            targetEl: s,\n            toEl: n,\n            fromEl: n\n          }), H(\"filter\", e, {\n            evt: t\n          }), void (i && t.cancelable && t.preventDefault());\n        } else if (u && (u = u.split(\",\").some(function (o) {\n          if (o = f(c, o.trim(), n, !1)) return F({\n            sortable: e,\n            rootEl: o,\n            name: \"filter\",\n            targetEl: s,\n            fromEl: n,\n            toEl: n\n          }), H(\"filter\", e, {\n            evt: t\n          }), !0;\n        }))) return void (i && t.cancelable && t.preventDefault());\n        o.handle && !f(c, o.handle, n, !1) || this._prepareDragStart(t, l, s);\n      }\n    }\n  },\n  _prepareDragStart: function _prepareDragStart(t, e, r) {\n    var a,\n      l = this,\n      s = l.el,\n      u = l.options,\n      d = s.ownerDocument;\n    if (r && !L && r.parentNode === s) {\n      var h = y(r);\n      if (j = s, K = (L = r).parentNode, z = L.nextSibling, G = r, J = u.group, It.dragged = L, rt = (et = {\n        target: L,\n        clientX: (e || t).clientX,\n        clientY: (e || t).clientY\n      }).clientX - h.left, at = et.clientY - h.top, this._lastX = (e || t).clientX, this._lastY = (e || t).clientY, L.style[\"will-change\"] = \"all\", a = function a() {\n        H(\"delayEnded\", l, {\n          evt: t\n        }), It.eventCanceled ? l._onDrop() : (l._disableDelayedDragEvents(), !i && l.nativeDraggable && (L.draggable = !0), l._triggerDragStart(t, e), F({\n          sortable: l,\n          name: \"choose\",\n          originalEvent: t\n        }), v(L, u.chosenClass, !0));\n      }, u.ignore.split(\",\").forEach(function (t) {\n        w(L, t.trim(), kt);\n      }), c(d, \"dragover\", Ot), c(d, \"mousemove\", Ot), c(d, \"touchmove\", Ot), c(d, \"mouseup\", l._onDrop), c(d, \"touchend\", l._onDrop), c(d, \"touchcancel\", l._onDrop), i && this.nativeDraggable && (this.options.touchStartThreshold = 4, L.draggable = !0), H(\"delayStart\", this, {\n        evt: t\n      }), !u.delay || u.delayOnTouchOnly && !e || this.nativeDraggable && (o || n)) a();else {\n        if (It.eventCanceled) return void this._onDrop();\n        c(d, \"mouseup\", l._disableDelayedDrag), c(d, \"touchend\", l._disableDelayedDrag), c(d, \"touchcancel\", l._disableDelayedDrag), c(d, \"mousemove\", l._delayedDragTouchMoveHandler), c(d, \"touchmove\", l._delayedDragTouchMoveHandler), u.supportPointer && c(d, \"pointermove\", l._delayedDragTouchMoveHandler), l._dragStartTimer = setTimeout(a, u.delay);\n      }\n    }\n  },\n  _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(t) {\n    var e = t.touches ? t.touches[0] : t;\n    Math.max(Math.abs(e.clientX - this._lastX), Math.abs(e.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1)) && this._disableDelayedDrag();\n  },\n  _disableDelayedDrag: function _disableDelayedDrag() {\n    L && kt(L), clearTimeout(this._dragStartTimer), this._disableDelayedDragEvents();\n  },\n  _disableDelayedDragEvents: function _disableDelayedDragEvents() {\n    var t = this.el.ownerDocument;\n    u(t, \"mouseup\", this._disableDelayedDrag), u(t, \"touchend\", this._disableDelayedDrag), u(t, \"touchcancel\", this._disableDelayedDrag), u(t, \"mousemove\", this._delayedDragTouchMoveHandler), u(t, \"touchmove\", this._delayedDragTouchMoveHandler), u(t, \"pointermove\", this._delayedDragTouchMoveHandler);\n  },\n  _triggerDragStart: function _triggerDragStart(t, e) {\n    e = e || \"touch\" == t.pointerType && t, !this.nativeDraggable || e ? c(document, this.options.supportPointer ? \"pointermove\" : e ? \"touchmove\" : \"mousemove\", this._onTouchMove) : (c(L, \"dragend\", this), c(j, \"dragstart\", this._onDragStart));\n    try {\n      document.selection ? Yt(function () {\n        document.selection.empty();\n      }) : window.getSelection().removeAllRanges();\n    } catch (t) {}\n  },\n  _dragStarted: function _dragStarted(t, e) {\n    if (ht = !1, j && L) {\n      H(\"dragStarted\", this, {\n        evt: e\n      }), this.nativeDraggable && c(document, \"dragover\", At);\n      var n = this.options;\n      !t && v(L, n.dragClass, !1), v(L, n.ghostClass, !0), It.active = this, t && this._appendGhost(), F({\n        sortable: this,\n        name: \"start\",\n        originalEvent: e\n      });\n    } else this._nulling();\n  },\n  _emulateDragOver: function _emulateDragOver() {\n    if (nt) {\n      this._lastX = nt.clientX, this._lastY = nt.clientY, xt();\n      for (var t = document.elementFromPoint(nt.clientX, nt.clientY), e = t; t && t.shadowRoot && (t = t.shadowRoot.elementFromPoint(nt.clientX, nt.clientY)) !== e;) {\n        e = t;\n      }\n      if (L.parentNode[k]._isOutsideThisEl(t), e) do {\n        if (e[k] && e[k]._onDragOver({\n          clientX: nt.clientX,\n          clientY: nt.clientY,\n          target: t,\n          rootEl: e\n        }) && !this.options.dragoverBubble) break;\n        t = e;\n      } while (e = e.parentNode);\n      Mt();\n    }\n  },\n  _onTouchMove: function _onTouchMove(t) {\n    if (et) {\n      var e = this.options,\n        n = e.fallbackTolerance,\n        o = e.fallbackOffset,\n        i = t.touches ? t.touches[0] : t,\n        r = W && b(W, !0),\n        a = W && r && r.a,\n        l = W && r && r.d,\n        s = yt && dt && T(dt),\n        c = (i.clientX - et.clientX + o.x) / (a || 1) + (s ? s[0] - mt[0] : 0) / (a || 1),\n        u = (i.clientY - et.clientY + o.y) / (l || 1) + (s ? s[1] - mt[1] : 0) / (l || 1);\n      if (!It.active && !ht) {\n        if (n && Math.max(Math.abs(i.clientX - this._lastX), Math.abs(i.clientY - this._lastY)) < n) return;\n        this._onDragStart(t, !0);\n      }\n      if (W) {\n        r ? (r.e += c - (ot || 0), r.f += u - (it || 0)) : r = {\n          a: 1,\n          b: 0,\n          c: 0,\n          d: 1,\n          e: c,\n          f: u\n        };\n        var d = \"matrix(\" + r.a + \",\" + r.b + \",\" + r.c + \",\" + r.d + \",\" + r.e + \",\" + r.f + \")\";\n        m(W, \"webkitTransform\", d), m(W, \"mozTransform\", d), m(W, \"msTransform\", d), m(W, \"transform\", d), ot = c, it = u, nt = i;\n      }\n      t.cancelable && t.preventDefault();\n    }\n  },\n  _appendGhost: function _appendGhost() {\n    if (!W) {\n      var t = this.options.fallbackOnBody ? document.body : j,\n        e = y(L, !0, yt, !0, t),\n        n = this.options;\n      if (yt) {\n        for (dt = t; \"static\" === m(dt, \"position\") && \"none\" === m(dt, \"transform\") && dt !== document;) {\n          dt = dt.parentNode;\n        }\n        dt !== document.body && dt !== document.documentElement ? (dt === document && (dt = E()), e.top += dt.scrollTop, e.left += dt.scrollLeft) : dt = E(), mt = T(dt);\n      }\n      v(W = L.cloneNode(!0), n.ghostClass, !1), v(W, n.fallbackClass, !0), v(W, n.dragClass, !0), m(W, \"transition\", \"\"), m(W, \"transform\", \"\"), m(W, \"box-sizing\", \"border-box\"), m(W, \"margin\", 0), m(W, \"top\", e.top), m(W, \"left\", e.left), m(W, \"width\", e.width), m(W, \"height\", e.height), m(W, \"opacity\", \"0.8\"), m(W, \"position\", yt ? \"absolute\" : \"fixed\"), m(W, \"zIndex\", \"100000\"), m(W, \"pointerEvents\", \"none\"), It.ghost = W, t.appendChild(W), m(W, \"transform-origin\", rt / parseInt(W.style.width) * 100 + \"% \" + at / parseInt(W.style.height) * 100 + \"%\");\n    }\n  },\n  _onDragStart: function _onDragStart(t, e) {\n    var n = this,\n      o = t.dataTransfer,\n      i = n.options;\n    H(\"dragStart\", this, {\n      evt: t\n    }), It.eventCanceled ? this._onDrop() : (H(\"setupClone\", this), It.eventCanceled || ((U = A(L)).draggable = !1, U.style[\"will-change\"] = \"\", this._hideClone(), v(U, this.options.chosenClass, !1), It.clone = U), n.cloneId = Yt(function () {\n      H(\"clone\", n), It.eventCanceled || (n.options.removeCloneOnHide || j.insertBefore(U, L), n._hideClone(), F({\n        sortable: n,\n        name: \"clone\"\n      }));\n    }), !e && v(L, i.dragClass, !0), e ? (ft = !0, n._loopId = setInterval(n._emulateDragOver, 50)) : (u(document, \"mouseup\", n._onDrop), u(document, \"touchend\", n._onDrop), u(document, \"touchcancel\", n._onDrop), o && (o.effectAllowed = \"move\", i.setData && i.setData.call(n, o, L)), c(document, \"drop\", n), m(L, \"transform\", \"translateZ(0)\")), ht = !0, n._dragStartId = Yt(n._dragStarted.bind(n, e, t)), c(document, \"selectstart\", n), lt = !0, r && m(document.body, \"user-select\", \"none\"));\n  },\n  _onDragOver: function _onDragOver(e) {\n    var n,\n      o,\n      i,\n      r,\n      a = this.el,\n      l = e.target,\n      s = this.options,\n      c = s.group,\n      u = It.active,\n      d = J === c,\n      h = s.sort,\n      p = tt || u,\n      g = this,\n      b = !1;\n    if (!bt) {\n      if (void 0 !== e.preventDefault && e.cancelable && e.preventDefault(), l = f(l, s.draggable, a, !0), B(\"dragOver\"), It.eventCanceled) return b;\n      if (L.contains(e.target) || l.animated && l.animatingX && l.animatingY || g._ignoreWhileAnimating === l) return U(!1);\n      if (ft = !1, u && !s.disabled && (d ? h || (i = !j.contains(L)) : tt === this || (this.lastPutMode = J.checkPull(this, u, L, e)) && c.checkPut(this, u, L, e))) {\n        if (r = \"vertical\" === this._getDirection(e, l), n = y(L), B(\"dragOverValid\"), It.eventCanceled) return b;\n        if (i) return K = j, G(), this._hideClone(), B(\"revert\"), It.eventCanceled || (z ? j.insertBefore(L, z) : j.appendChild(L)), U(!0);\n        var w = S(a, s.draggable);\n        if (!w || function (t, e, n) {\n          var o = y(S(n.el, n.options.draggable));\n          return e ? t.clientX > o.right + 10 || t.clientX <= o.right && t.clientY > o.bottom && t.clientX >= o.left : t.clientX > o.right && t.clientY > o.top || t.clientX <= o.right && t.clientY > o.bottom + 10;\n        }(e, r, this) && !w.animated) {\n          if (w === L) return U(!1);\n          if (w && a === e.target && (l = w), l && (o = y(l)), !1 !== Pt(j, a, L, n, l, o, e, !!l)) return G(), a.appendChild(L), K = a, q(), U(!0);\n        } else if (l.parentNode === a) {\n          o = y(l);\n          var E,\n            _,\n            T,\n            x = L.parentNode !== a,\n            M = !function (t, e, n) {\n              var o = n ? t.left : t.top,\n                i = n ? e.left : e.top;\n              return o === i || (n ? t.right : t.bottom) === (n ? e.right : e.bottom) || o + (n ? t.width : t.height) / 2 === i + (n ? e.width : e.height) / 2;\n            }(L.animated && L.toRect || n, l.animated && l.toRect || o, r),\n            N = r ? \"top\" : \"left\",\n            A = D(l, \"top\", \"top\") || D(L, \"top\", \"top\"),\n            I = A ? A.scrollTop : void 0;\n          if (st !== l && (_ = o[N], gt = !1, vt = !M && s.invertSwap || x), 0 !== (E = function (t, e, n, o, i, r, a, l) {\n            var s = o ? t.clientY : t.clientX,\n              c = o ? n.height : n.width,\n              u = o ? n.top : n.left,\n              d = o ? n.bottom : n.right,\n              h = !1;\n            if (!a) if (l && ut < c * i) {\n              if (!gt && (1 === ct ? s > u + c * r / 2 : s < d - c * r / 2) && (gt = !0), gt) h = !0;else if (1 === ct ? s < u + ut : s > d - ut) return -ct;\n            } else if (s > u + c * (1 - i) / 2 && s < d - c * (1 - i) / 2) return function (t) {\n              return C(L) < C(t) ? 1 : -1;\n            }(e);\n            return (h = h || a) && (s < u + c * r / 2 || s > d - c * r / 2) ? s > u + c / 2 ? 1 : -1 : 0;\n          }(e, l, o, r, M ? 1 : s.swapThreshold, null == s.invertedSwapThreshold ? s.swapThreshold : s.invertedSwapThreshold, vt, st === l))) {\n            var P = C(L);\n            do {\n              T = K.children[P -= E];\n            } while (T && (\"none\" === m(T, \"display\") || T === W));\n          }\n          if (0 === E || T === l) return U(!1);\n          st = l, ct = E;\n          var R = l.nextElementSibling,\n            X = !1,\n            Y = Pt(j, a, L, n, l, o, e, X = 1 === E);\n          if (!1 !== Y) return 1 !== Y && -1 !== Y || (X = 1 === Y), bt = !0, setTimeout(Rt, 30), G(), X && !R ? a.appendChild(L) : l.parentNode.insertBefore(L, X ? R : l), A && O(A, 0, I - A.scrollTop), K = L.parentNode, void 0 === _ || vt || (ut = Math.abs(_ - y(l)[N])), q(), U(!0);\n        }\n        if (a.contains(L)) return U(!1);\n      }\n      return !1;\n    }\n    function B(s, c) {\n      H(s, g, t({\n        evt: e,\n        isOwner: d,\n        axis: r ? \"vertical\" : \"horizontal\",\n        revert: i,\n        dragRect: n,\n        targetRect: o,\n        canSort: h,\n        fromSortable: p,\n        target: l,\n        completed: U,\n        onMove: function onMove(t, o) {\n          return Pt(j, a, L, n, t, y(t), e, o);\n        },\n        changed: q\n      }, c));\n    }\n    function G() {\n      B(\"dragOverAnimationCapture\"), g.captureAnimationState(), g !== p && p.captureAnimationState();\n    }\n    function U(t) {\n      return B(\"dragOverCompleted\", {\n        insertion: t\n      }), t && (d ? u._hideClone() : u._showClone(g), g !== p && (v(L, tt ? tt.options.ghostClass : u.options.ghostClass, !1), v(L, s.ghostClass, !0)), tt !== g && g !== It.active ? tt = g : g === It.active && tt && (tt = null), p === g && (g._ignoreWhileAnimating = l), g.animateAll(function () {\n        B(\"dragOverAnimationComplete\"), g._ignoreWhileAnimating = null;\n      }), g !== p && (p.animateAll(), p._ignoreWhileAnimating = null)), (l === L && !L.animated || l === a && !l.animated) && (st = null), s.dragoverBubble || e.rootEl || l === document || (L.parentNode[k]._isOutsideThisEl(e.target), !t && Ot(e)), !s.dragoverBubble && e.stopPropagation && e.stopPropagation(), b = !0;\n    }\n    function q() {\n      Z = C(L), $ = C(L, s.draggable), F({\n        sortable: g,\n        name: \"change\",\n        toEl: a,\n        newIndex: Z,\n        newDraggableIndex: $,\n        originalEvent: e\n      });\n    }\n  },\n  _ignoreWhileAnimating: null,\n  _offMoveEvents: function _offMoveEvents() {\n    u(document, \"mousemove\", this._onTouchMove), u(document, \"touchmove\", this._onTouchMove), u(document, \"pointermove\", this._onTouchMove), u(document, \"dragover\", Ot), u(document, \"mousemove\", Ot), u(document, \"touchmove\", Ot);\n  },\n  _offUpEvents: function _offUpEvents() {\n    var t = this.el.ownerDocument;\n    u(t, \"mouseup\", this._onDrop), u(t, \"touchend\", this._onDrop), u(t, \"pointerup\", this._onDrop), u(t, \"touchcancel\", this._onDrop), u(document, \"selectstart\", this);\n  },\n  _onDrop: function _onDrop(t) {\n    var e = this.el,\n      n = this.options;\n    Z = C(L), $ = C(L, n.draggable), H(\"drop\", this, {\n      evt: t\n    }), K = L && L.parentNode, Z = C(L), $ = C(L, n.draggable), It.eventCanceled || (ht = !1, vt = !1, gt = !1, clearInterval(this._loopId), clearTimeout(this._dragStartTimer), Bt(this.cloneId), Bt(this._dragStartId), this.nativeDraggable && (u(document, \"drop\", this), u(e, \"dragstart\", this._onDragStart)), this._offMoveEvents(), this._offUpEvents(), r && m(document.body, \"user-select\", \"\"), m(L, \"transform\", \"\"), t && (lt && (t.cancelable && t.preventDefault(), !n.dropBubble && t.stopPropagation()), W && W.parentNode && W.parentNode.removeChild(W), (j === K || tt && \"clone\" !== tt.lastPutMode) && U && U.parentNode && U.parentNode.removeChild(U), L && (this.nativeDraggable && u(L, \"dragend\", this), kt(L), L.style[\"will-change\"] = \"\", lt && !ht && v(L, tt ? tt.options.ghostClass : this.options.ghostClass, !1), v(L, this.options.chosenClass, !1), F({\n      sortable: this,\n      name: \"unchoose\",\n      toEl: K,\n      newIndex: null,\n      newDraggableIndex: null,\n      originalEvent: t\n    }), j !== K ? (Z >= 0 && (F({\n      rootEl: K,\n      name: \"add\",\n      toEl: K,\n      fromEl: j,\n      originalEvent: t\n    }), F({\n      sortable: this,\n      name: \"remove\",\n      toEl: K,\n      originalEvent: t\n    }), F({\n      rootEl: K,\n      name: \"sort\",\n      toEl: K,\n      fromEl: j,\n      originalEvent: t\n    }), F({\n      sortable: this,\n      name: \"sort\",\n      toEl: K,\n      originalEvent: t\n    })), tt && tt.save()) : Z !== V && Z >= 0 && (F({\n      sortable: this,\n      name: \"update\",\n      toEl: K,\n      originalEvent: t\n    }), F({\n      sortable: this,\n      name: \"sort\",\n      toEl: K,\n      originalEvent: t\n    })), It.active && (null != Z && -1 !== Z || (Z = V, $ = Q), F({\n      sortable: this,\n      name: \"end\",\n      toEl: K,\n      originalEvent: t\n    }), this.save())))), this._nulling();\n  },\n  _nulling: function _nulling() {\n    H(\"nulling\", this), j = L = K = W = z = U = G = q = et = nt = lt = Z = $ = V = Q = st = ct = tt = J = It.dragged = It.ghost = It.clone = It.active = null, wt.forEach(function (t) {\n      t.checked = !0;\n    }), wt.length = ot = it = 0;\n  },\n  handleEvent: function handleEvent(t) {\n    switch (t.type) {\n      case \"drop\":\n      case \"dragend\":\n        this._onDrop(t);\n        break;\n      case \"dragenter\":\n      case \"dragover\":\n        L && (this._onDragOver(t), function (t) {\n          t.dataTransfer && (t.dataTransfer.dropEffect = \"move\"), t.cancelable && t.preventDefault();\n        }(t));\n        break;\n      case \"selectstart\":\n        t.preventDefault();\n    }\n  },\n  toArray: function toArray() {\n    for (var t, e = [], n = this.el.children, o = 0, i = n.length, r = this.options; o < i; o++) {\n      f(t = n[o], r.draggable, this.el, !1) && e.push(t.getAttribute(r.dataIdAttr) || Xt(t));\n    }\n    return e;\n  },\n  sort: function sort(t) {\n    var e = {},\n      n = this.el;\n    this.toArray().forEach(function (t, o) {\n      var i = n.children[o];\n      f(i, this.options.draggable, n, !1) && (e[t] = i);\n    }, this), t.forEach(function (t) {\n      e[t] && (n.removeChild(e[t]), n.appendChild(e[t]));\n    });\n  },\n  save: function save() {\n    var t = this.options.store;\n    t && t.set && t.set(this);\n  },\n  closest: function closest(t, e) {\n    return f(t, e || this.options.draggable, this.el, !1);\n  },\n  option: function option(t, e) {\n    var n = this.options;\n    if (void 0 === e) return n[t];\n    var o = Y.modifyOption(this, t, e);\n    n[t] = void 0 !== o ? o : e, \"group\" === t && Tt(n);\n  },\n  destroy: function destroy() {\n    H(\"destroy\", this);\n    var t = this.el;\n    t[k] = null, u(t, \"mousedown\", this._onTapStart), u(t, \"touchstart\", this._onTapStart), u(t, \"pointerdown\", this._onTapStart), this.nativeDraggable && (u(t, \"dragover\", this), u(t, \"dragenter\", this)), Array.prototype.forEach.call(t.querySelectorAll(\"[draggable]\"), function (t) {\n      t.removeAttribute(\"draggable\");\n    }), this._onDrop(), this._disableDelayedDragEvents(), pt.splice(pt.indexOf(this.el), 1), this.el = t = null;\n  },\n  _hideClone: function _hideClone() {\n    if (!q) {\n      if (H(\"hideClone\", this), It.eventCanceled) return;\n      m(U, \"display\", \"none\"), this.options.removeCloneOnHide && U.parentNode && U.parentNode.removeChild(U), q = !0;\n    }\n  },\n  _showClone: function _showClone(t) {\n    if (\"clone\" === t.lastPutMode) {\n      if (q) {\n        if (H(\"showClone\", this), It.eventCanceled) return;\n        L.parentNode != j || this.options.group.revertClone ? z ? j.insertBefore(U, z) : j.appendChild(U) : j.insertBefore(U, L), this.options.group.revertClone && this.animate(L, U), m(U, \"display\", \"\"), q = !1;\n      }\n    } else this._hideClone();\n  }\n}, Et && c(document, \"touchmove\", function (t) {\n  (It.active || ht) && t.cancelable && t.preventDefault();\n}), It.utils = {\n  on: c,\n  off: u,\n  css: m,\n  find: w,\n  is: function is(t, e) {\n    return !!f(t, e, t, !1);\n  },\n  extend: function extend(t, e) {\n    if (t && e) for (var n in e) {\n      e.hasOwnProperty(n) && (t[n] = e[n]);\n    }\n    return t;\n  },\n  throttle: N,\n  closest: f,\n  toggleClass: v,\n  clone: A,\n  index: C,\n  nextTick: Yt,\n  cancelNextTick: Bt,\n  detectDirection: Ct,\n  getChild: _\n}, It.get = function (t) {\n  return t[k];\n}, It.mount = function () {\n  var e = [].slice.call(arguments);\n  e[0].constructor === Array && (e = e[0]), e.forEach(function (e) {\n    if (!e.prototype || !e.prototype.constructor) throw \"Sortable: Mounted plugin must be a constructor function, not \" + {}.toString.call(e);\n    e.utils && (It.utils = t({}, It.utils, e.utils)), Y.mount(e);\n  });\n}, It.create = function (t, e) {\n  return new It(t, e);\n}, It.version = \"1.12.0\";\nvar Ht,\n  Ft,\n  Lt,\n  Kt,\n  Wt,\n  jt = [],\n  zt = [],\n  Gt = !1,\n  Ut = !1,\n  qt = !1;\nfunction Vt(t, e) {\n  zt.forEach(function (n, o) {\n    var i = e.children[n.sortableIndex + (t ? Number(o) : 0)];\n    i ? e.insertBefore(n, i) : e.appendChild(n);\n  });\n}\nfunction Zt() {\n  jt.forEach(function (t) {\n    t !== Lt && t.parentNode && t.parentNode.removeChild(t);\n  });\n}\nvar Qt = function Qt(t) {\n  var e = t.originalEvent,\n    n = t.putSortable,\n    o = t.dragEl,\n    i = t.dispatchSortableEvent,\n    r = t.unhideGhostForTarget;\n  if (e) {\n    var a = n || t.activeSortable;\n    (0, t.hideGhostForTarget)();\n    var l = e.changedTouches && e.changedTouches.length ? e.changedTouches[0] : e,\n      s = document.elementFromPoint(l.clientX, l.clientY);\n    r(), a && !a.el.contains(s) && (i(\"spill\"), this.onSpill({\n      dragEl: o,\n      putSortable: n\n    }));\n  }\n};\nfunction $t() {}\nfunction Jt() {}\n$t.prototype = {\n  startIndex: null,\n  dragStart: function dragStart(t) {\n    this.startIndex = t.oldDraggableIndex;\n  },\n  onSpill: function onSpill(t) {\n    var e = t.dragEl,\n      n = t.putSortable;\n    this.sortable.captureAnimationState(), n && n.captureAnimationState();\n    var o = _(this.sortable.el, this.startIndex, this.options);\n    o ? this.sortable.el.insertBefore(e, o) : this.sortable.el.appendChild(e), this.sortable.animateAll(), n && n.animateAll();\n  },\n  drop: Qt\n}, Object.assign($t, {\n  pluginName: \"revertOnSpill\"\n}), Jt.prototype = {\n  onSpill: function onSpill(t) {\n    var e = t.dragEl,\n      n = t.putSortable || this.sortable;\n    n.captureAnimationState(), e.parentNode && e.parentNode.removeChild(e), n.animateAll();\n  },\n  drop: Qt\n}, Object.assign(Jt, {\n  pluginName: \"removeOnSpill\"\n});\nvar te,\n  ee,\n  ne,\n  oe,\n  ie,\n  re,\n  ae = [],\n  le = !1;\nfunction se() {\n  ae.forEach(function (t) {\n    clearInterval(t.pid);\n  }), ae = [];\n}\nfunction ce() {\n  clearInterval(re);\n}\nvar ue = N(function (t, e, n, o) {\n  if (e.scroll) {\n    var i,\n      r = (t.touches ? t.touches[0] : t).clientX,\n      a = (t.touches ? t.touches[0] : t).clientY,\n      l = e.scrollSensitivity,\n      s = e.scrollSpeed,\n      c = E(),\n      u = !1;\n    ee !== n && (ee = n, se(), i = e.scrollFn, !0 === (te = e.scroll) && (te = x(n, !0)));\n    var d = 0,\n      h = te;\n    do {\n      var f = h,\n        p = y(f),\n        g = p.top,\n        v = p.bottom,\n        b = p.left,\n        w = p.right,\n        D = p.width,\n        _ = p.height,\n        S = void 0,\n        C = void 0,\n        T = f.scrollWidth,\n        M = f.scrollHeight,\n        N = m(f),\n        A = f.scrollLeft,\n        I = f.scrollTop;\n      f === c ? (S = D < T && (\"auto\" === N.overflowX || \"scroll\" === N.overflowX || \"visible\" === N.overflowX), C = _ < M && (\"auto\" === N.overflowY || \"scroll\" === N.overflowY || \"visible\" === N.overflowY)) : (S = D < T && (\"auto\" === N.overflowX || \"scroll\" === N.overflowX), C = _ < M && (\"auto\" === N.overflowY || \"scroll\" === N.overflowY));\n      var P = S && (Math.abs(w - r) <= l && A + D < T) - (Math.abs(b - r) <= l && !!A),\n        R = C && (Math.abs(v - a) <= l && I + _ < M) - (Math.abs(g - a) <= l && !!I);\n      if (!ae[d]) for (var X = 0; X <= d; X++) {\n        ae[X] || (ae[X] = {});\n      }\n      ae[d].vx == P && ae[d].vy == R && ae[d].el === f || (ae[d].el = f, ae[d].vx = P, ae[d].vy = R, clearInterval(ae[d].pid), 0 == P && 0 == R || (u = !0, ae[d].pid = setInterval(function () {\n        o && 0 === this.layer && It.active._onTouchMove(ie);\n        var e = ae[this.layer].vy ? ae[this.layer].vy * s : 0,\n          n = ae[this.layer].vx ? ae[this.layer].vx * s : 0;\n        \"function\" == typeof i && \"continue\" !== i.call(It.dragged.parentNode[k], n, e, t, ie, ae[this.layer].el) || O(ae[this.layer].el, n, e);\n      }.bind({\n        layer: d\n      }), 24))), d++;\n    } while (e.bubbleScroll && h !== c && (h = x(h, !1)));\n    le = u;\n  }\n}, 30);\nIt.mount(new function () {\n  function t() {\n    for (var t in this.defaults = {\n      scroll: !0,\n      scrollSensitivity: 30,\n      scrollSpeed: 10,\n      bubbleScroll: !0\n    }, this) {\n      \"_\" === t.charAt(0) && \"function\" == typeof this[t] && (this[t] = this[t].bind(this));\n    }\n  }\n  return t.prototype = {\n    dragStarted: function dragStarted(t) {\n      var e = t.originalEvent;\n      this.sortable.nativeDraggable ? c(document, \"dragover\", this._handleAutoScroll) : c(document, this.options.supportPointer ? \"pointermove\" : e.touches ? \"touchmove\" : \"mousemove\", this._handleFallbackAutoScroll);\n    },\n    dragOverCompleted: function dragOverCompleted(t) {\n      var e = t.originalEvent;\n      this.options.dragOverBubble || e.rootEl || this._handleAutoScroll(e);\n    },\n    drop: function drop() {\n      this.sortable.nativeDraggable ? u(document, \"dragover\", this._handleAutoScroll) : (u(document, \"pointermove\", this._handleFallbackAutoScroll), u(document, \"touchmove\", this._handleFallbackAutoScroll), u(document, \"mousemove\", this._handleFallbackAutoScroll)), ce(), se(), clearTimeout(p), p = void 0;\n    },\n    nulling: function nulling() {\n      ie = ee = te = le = re = ne = oe = null, ae.length = 0;\n    },\n    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(t) {\n      this._handleAutoScroll(t, !0);\n    },\n    _handleAutoScroll: function _handleAutoScroll(t, e) {\n      var i = this,\n        a = (t.touches ? t.touches[0] : t).clientX,\n        l = (t.touches ? t.touches[0] : t).clientY,\n        s = document.elementFromPoint(a, l);\n      if (ie = t, e || o || n || r) {\n        ue(t, this.options, s, e);\n        var c = x(s, !0);\n        !le || re && a === ne && l === oe || (re && ce(), re = setInterval(function () {\n          var n = x(document.elementFromPoint(a, l), !0);\n          n !== c && (c = n, se()), ue(t, i.options, n, e);\n        }, 10), ne = a, oe = l);\n      } else {\n        if (!this.options.bubbleScroll || x(s, !0) === E()) return void se();\n        ue(t, this.options, x(s, !1), !1);\n      }\n    }\n  }, Object.assign(t, {\n    pluginName: \"scroll\",\n    initializeByDefault: !0\n  });\n}()), It.mount(Jt, $t), It.mount(new function () {\n  function t() {\n    this.defaults = {\n      swapClass: \"sortable-swap-highlight\"\n    };\n  }\n  return t.prototype = {\n    dragStart: function dragStart(t) {\n      Nt = t.dragEl;\n    },\n    dragOverValid: function dragOverValid(t) {\n      var e = t.completed,\n        n = t.target,\n        o = t.changed,\n        i = t.cancel;\n      if (t.activeSortable.options.swap) {\n        var r = this.options;\n        if (n && n !== this.sortable.el) {\n          var a = Nt;\n          !1 !== (0, t.onMove)(n) ? (v(n, r.swapClass, !0), Nt = n) : Nt = null, a && a !== Nt && v(a, r.swapClass, !1);\n        }\n        o(), e(!0), i();\n      }\n    },\n    drop: function drop(t) {\n      var e,\n        n,\n        o,\n        i,\n        r,\n        a,\n        l = t.activeSortable,\n        s = t.putSortable,\n        c = t.dragEl,\n        u = s || this.sortable,\n        d = this.options;\n      Nt && v(Nt, d.swapClass, !1), Nt && (d.swap || s && s.options.swap) && c !== Nt && (u.captureAnimationState(), u !== l && l.captureAnimationState(), a = (n = Nt).parentNode, (r = (e = c).parentNode) && a && !r.isEqualNode(n) && !a.isEqualNode(e) && (o = C(e), i = C(n), r.isEqualNode(a) && o < i && i++, r.insertBefore(n, r.children[o]), a.insertBefore(e, a.children[i])), u.animateAll(), u !== l && l.animateAll());\n    },\n    nulling: function nulling() {\n      Nt = null;\n    }\n  }, Object.assign(t, {\n    pluginName: \"swap\",\n    eventProperties: function eventProperties() {\n      return {\n        swapItem: Nt\n      };\n    }\n  });\n}()), It.mount(new function () {\n  function t(t) {\n    for (var e in this) {\n      \"_\" === e.charAt(0) && \"function\" == typeof this[e] && (this[e] = this[e].bind(this));\n    }\n    t.options.supportPointer ? c(document, \"pointerup\", this._deselectMultiDrag) : (c(document, \"mouseup\", this._deselectMultiDrag), c(document, \"touchend\", this._deselectMultiDrag)), c(document, \"keydown\", this._checkKeyDown), c(document, \"keyup\", this._checkKeyUp), this.defaults = {\n      selectedClass: \"sortable-selected\",\n      multiDragKey: null,\n      setData: function setData(e, n) {\n        var o = \"\";\n        jt.length && Ft === t ? jt.forEach(function (t, e) {\n          o += (e ? \", \" : \"\") + t.textContent;\n        }) : o = n.textContent, e.setData(\"Text\", o);\n      }\n    };\n  }\n  return t.prototype = {\n    multiDragKeyDown: !1,\n    isMultiDrag: !1,\n    delayStartGlobal: function delayStartGlobal(t) {\n      Lt = t.dragEl;\n    },\n    delayEnded: function delayEnded() {\n      this.isMultiDrag = ~jt.indexOf(Lt);\n    },\n    setupClone: function setupClone(t) {\n      var e = t.sortable,\n        n = t.cancel;\n      if (this.isMultiDrag) {\n        for (var o = 0; o < jt.length; o++) {\n          zt.push(A(jt[o])), zt[o].sortableIndex = jt[o].sortableIndex, zt[o].draggable = !1, zt[o].style[\"will-change\"] = \"\", v(zt[o], this.options.selectedClass, !1), jt[o] === Lt && v(zt[o], this.options.chosenClass, !1);\n        }\n        e._hideClone(), n();\n      }\n    },\n    clone: function clone(t) {\n      var e = t.dispatchSortableEvent,\n        n = t.cancel;\n      this.isMultiDrag && (this.options.removeCloneOnHide || jt.length && Ft === t.sortable && (Vt(!0, t.rootEl), e(\"clone\"), n()));\n    },\n    showClone: function showClone(t) {\n      var e = t.cloneNowShown,\n        n = t.cancel;\n      this.isMultiDrag && (Vt(!1, t.rootEl), zt.forEach(function (t) {\n        m(t, \"display\", \"\");\n      }), e(), Wt = !1, n());\n    },\n    hideClone: function hideClone(t) {\n      var e = this,\n        n = t.cloneNowHidden,\n        o = t.cancel;\n      this.isMultiDrag && (zt.forEach(function (t) {\n        m(t, \"display\", \"none\"), e.options.removeCloneOnHide && t.parentNode && t.parentNode.removeChild(t);\n      }), n(), Wt = !0, o());\n    },\n    dragStartGlobal: function dragStartGlobal(t) {\n      !this.isMultiDrag && Ft && Ft.multiDrag._deselectMultiDrag(), jt.forEach(function (t) {\n        t.sortableIndex = C(t);\n      }), jt = jt.sort(function (t, e) {\n        return t.sortableIndex - e.sortableIndex;\n      }), qt = !0;\n    },\n    dragStarted: function dragStarted(t) {\n      var e = this,\n        n = t.sortable;\n      if (this.isMultiDrag) {\n        if (this.options.sort && (n.captureAnimationState(), this.options.animation)) {\n          jt.forEach(function (t) {\n            t !== Lt && m(t, \"position\", \"absolute\");\n          });\n          var o = y(Lt, !1, !0, !0);\n          jt.forEach(function (t) {\n            t !== Lt && I(t, o);\n          }), Ut = !0, Gt = !0;\n        }\n        n.animateAll(function () {\n          Ut = !1, Gt = !1, e.options.animation && jt.forEach(function (t) {\n            P(t);\n          }), e.options.sort && Zt();\n        });\n      }\n    },\n    dragOver: function dragOver(t) {\n      var e = t.completed,\n        n = t.cancel;\n      Ut && ~jt.indexOf(t.target) && (e(!1), n());\n    },\n    revert: function revert(t) {\n      var e = t.fromSortable,\n        n = t.rootEl,\n        o = t.sortable,\n        i = t.dragRect;\n      jt.length > 1 && (jt.forEach(function (t) {\n        o.addAnimationState({\n          target: t,\n          rect: Ut ? y(t) : i\n        }), P(t), t.fromRect = i, e.removeAnimationState(t);\n      }), Ut = !1, function (t, e) {\n        jt.forEach(function (n, o) {\n          var i = e.children[n.sortableIndex + (t ? Number(o) : 0)];\n          i ? e.insertBefore(n, i) : e.appendChild(n);\n        });\n      }(!this.options.removeCloneOnHide, n));\n    },\n    dragOverCompleted: function dragOverCompleted(t) {\n      var e = t.sortable,\n        n = t.isOwner,\n        o = t.activeSortable,\n        i = t.parentEl,\n        r = t.putSortable,\n        a = this.options;\n      if (t.insertion) {\n        if (n && o._hideClone(), Gt = !1, a.animation && jt.length > 1 && (Ut || !n && !o.options.sort && !r)) {\n          var l = y(Lt, !1, !0, !0);\n          jt.forEach(function (t) {\n            t !== Lt && (I(t, l), i.appendChild(t));\n          }), Ut = !0;\n        }\n        if (!n) if (Ut || Zt(), jt.length > 1) {\n          var s = Wt;\n          o._showClone(e), o.options.animation && !Wt && s && zt.forEach(function (t) {\n            o.addAnimationState({\n              target: t,\n              rect: Kt\n            }), t.fromRect = Kt, t.thisAnimationDuration = null;\n          });\n        } else o._showClone(e);\n      }\n    },\n    dragOverAnimationCapture: function dragOverAnimationCapture(t) {\n      var e = t.dragRect,\n        n = t.isOwner,\n        o = t.activeSortable;\n      if (jt.forEach(function (t) {\n        t.thisAnimationDuration = null;\n      }), o.options.animation && !n && o.multiDrag.isMultiDrag) {\n        Kt = Object.assign({}, e);\n        var i = b(Lt, !0);\n        Kt.top -= i.f, Kt.left -= i.e;\n      }\n    },\n    dragOverAnimationComplete: function dragOverAnimationComplete() {\n      Ut && (Ut = !1, Zt());\n    },\n    drop: function drop(t) {\n      var e = t.originalEvent,\n        n = t.rootEl,\n        o = t.parentEl,\n        i = t.sortable,\n        r = t.dispatchSortableEvent,\n        a = t.oldIndex,\n        l = t.putSortable,\n        s = l || this.sortable;\n      if (e) {\n        var c = this.options,\n          u = o.children;\n        if (!qt) if (c.multiDragKey && !this.multiDragKeyDown && this._deselectMultiDrag(), v(Lt, c.selectedClass, !~jt.indexOf(Lt)), ~jt.indexOf(Lt)) jt.splice(jt.indexOf(Lt), 1), Ht = null, B({\n          sortable: i,\n          rootEl: n,\n          name: \"deselect\",\n          targetEl: Lt,\n          originalEvt: e\n        });else {\n          if (jt.push(Lt), B({\n            sortable: i,\n            rootEl: n,\n            name: \"select\",\n            targetEl: Lt,\n            originalEvt: e\n          }), e.shiftKey && Ht && i.el.contains(Ht)) {\n            var d,\n              h,\n              f = C(Ht),\n              p = C(Lt);\n            if (~f && ~p && f !== p) for (p > f ? (h = f, d = p) : (h = p, d = f + 1); h < d; h++) {\n              ~jt.indexOf(u[h]) || (v(u[h], c.selectedClass, !0), jt.push(u[h]), B({\n                sortable: i,\n                rootEl: n,\n                name: \"select\",\n                targetEl: u[h],\n                originalEvt: e\n              }));\n            }\n          } else Ht = Lt;\n          Ft = s;\n        }\n        if (qt && this.isMultiDrag) {\n          if ((o[k].options.sort || o !== n) && jt.length > 1) {\n            var g = y(Lt),\n              m = C(Lt, \":not(.\" + this.options.selectedClass + \")\");\n            if (!Gt && c.animation && (Lt.thisAnimationDuration = null), s.captureAnimationState(), !Gt && (c.animation && (Lt.fromRect = g, jt.forEach(function (t) {\n              if (t.thisAnimationDuration = null, t !== Lt) {\n                var e = Ut ? y(t) : g;\n                t.fromRect = e, s.addAnimationState({\n                  target: t,\n                  rect: e\n                });\n              }\n            })), Zt(), jt.forEach(function (t) {\n              u[m] ? o.insertBefore(t, u[m]) : o.appendChild(t), m++;\n            }), a === C(Lt))) {\n              var b = !1;\n              jt.forEach(function (t) {\n                t.sortableIndex === C(t) || (b = !0);\n              }), b && r(\"update\");\n            }\n            jt.forEach(function (t) {\n              P(t);\n            }), s.animateAll();\n          }\n          Ft = s;\n        }\n        (n === o || l && \"clone\" !== l.lastPutMode) && zt.forEach(function (t) {\n          t.parentNode && t.parentNode.removeChild(t);\n        });\n      }\n    },\n    nullingGlobal: function nullingGlobal() {\n      this.isMultiDrag = qt = !1, zt.length = 0;\n    },\n    destroyGlobal: function destroyGlobal() {\n      this._deselectMultiDrag(), u(document, \"pointerup\", this._deselectMultiDrag), u(document, \"mouseup\", this._deselectMultiDrag), u(document, \"touchend\", this._deselectMultiDrag), u(document, \"keydown\", this._checkKeyDown), u(document, \"keyup\", this._checkKeyUp);\n    },\n    _deselectMultiDrag: function _deselectMultiDrag(t) {\n      if (!(void 0 !== qt && qt || Ft !== this.sortable || t && f(t.target, this.options.draggable, this.sortable.el, !1) || t && 0 !== t.button)) for (; jt.length;) {\n        var e = jt[0];\n        v(e, this.options.selectedClass, !1), jt.shift(), B({\n          sortable: this.sortable,\n          rootEl: this.sortable.el,\n          name: \"deselect\",\n          targetEl: e,\n          originalEvt: t\n        });\n      }\n    },\n    _checkKeyDown: function _checkKeyDown(t) {\n      t.key === this.options.multiDragKey && (this.multiDragKeyDown = !0);\n    },\n    _checkKeyUp: function _checkKeyUp(t) {\n      t.key === this.options.multiDragKey && (this.multiDragKeyDown = !1);\n    }\n  }, Object.assign(t, {\n    pluginName: \"multiDrag\",\n    utils: {\n      select: function select(t) {\n        var e = t.parentNode[k];\n        e && e.options.multiDrag && !~jt.indexOf(t) && (Ft && Ft !== e && (Ft.multiDrag._deselectMultiDrag(), Ft = e), v(t, e.options.selectedClass, !0), jt.push(t));\n      },\n      deselect: function deselect(t) {\n        var e = t.parentNode[k],\n          n = jt.indexOf(t);\n        e && e.options.multiDrag && ~n && (v(t, e.options.selectedClass, !1), jt.splice(n, 1));\n      }\n    },\n    eventProperties: function eventProperties() {\n      var t = this,\n        e = [],\n        n = [];\n      return jt.forEach(function (o) {\n        var i;\n        e.push({\n          multiDragElement: o,\n          index: o.sortableIndex\n        }), i = Ut && o !== Lt ? -1 : Ut ? C(o, \":not(.\" + t.options.selectedClass + \")\") : C(o), n.push({\n          multiDragElement: o,\n          index: i\n        });\n      }), {\n        items: [].concat(jt),\n        clones: [].concat(zt),\n        oldIndicies: e,\n        newIndicies: n\n      };\n    },\n    optionListeners: {\n      multiDragKey: function multiDragKey(t) {\n        return \"ctrl\" === (t = t.toLowerCase()) ? t = \"Control\" : t.length > 1 && (t = t.charAt(0).toUpperCase() + t.substr(1)), t;\n      }\n    }\n  });\n}());\nexport default It;\nexport { It as Sortable };","map":{"version":3,"mappings":"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","names":["userAgent","pattern","window","navigator","match","IE11OrLess","Edge","FireFox","Safari","IOS","ChromeForAndroid","captureMode","capture","passive","on","el","event","fn","addEventListener","off","removeEventListener","matches","selector","substring","msMatchesSelector","webkitMatchesSelector","_","getParentOrHost","host","document","nodeType","parentNode","closest","ctx","includeCTX","_throttleTimeout","R_SPACE","toggleClass","name","state","classList","className","replace","css","prop","val","style","defaultView","getComputedStyle","currentStyle","indexOf","matrix","selfOnly","appliedTransforms","transform","matrixFn","DOMMatrix","WebKitCSSMatrix","CSSMatrix","MSCSSMatrix","find","tagName","iterator","list","getElementsByTagName","i","n","length","getWindowScrollingElement","scrollingElement","documentElement","getRect","relativeToContainingBlock","relativeToNonStaticParent","undoScale","container","getBoundingClientRect","elRect","top","left","bottom","right","height","width","innerHeight","innerWidth","containerRect","parseInt","elMatrix","scaleX","a","scaleY","d","isScrolledPast","elSide","parentSide","parent","getParentAutoScrollElement","elSideVal","parentSideVal","getChild","childNum","options","currentChild","children","display","Sortable","ghost","dragged","draggable","lastChild","last","lastElementChild","previousElementSibling","index","nodeName","toUpperCase","clone","getRelativeScrollOffset","offsetLeft","offsetTop","winScroller","scrollLeft","scrollTop","includeSelf","elem","gotSelf","clientWidth","scrollWidth","clientHeight","scrollHeight","elemCSS","overflowX","overflowY","body","isRectEqual","rect1","rect2","Math","round","throttle","callback","ms","args","arguments","_this","this","call","apply","setTimeout","scrollBy","x","y","Polymer","$","jQuery","Zepto","dom","cloneNode","setRect","rect","unsetRect","expando","Date","getTime","plugins","defaults","initializeByDefault","pluginManager","mount","plugin","option","hasOwnProperty","push","pluginEvent","eventName","sortable","evt","eventCanceled","cancel","eventNameGlobal","forEach","pluginName","initializePlugins","initialized","Object","assign","modified","modifyOption","getEventProperties","eventProperties","value","modifiedValue","optionListeners","dispatchEvent","rootEl","targetEl","cloneEl","toEl","fromEl","oldIndex","newIndex","oldDraggableIndex","newDraggableIndex","originalEvent","putSortable","extraEventProperties","onName","charAt","substr","CustomEvent","createEvent","initEvent","bubbles","cancelable","to","from","item","pullMode","lastPutMode","undefined","allEventProperties","PluginManager","data","bind","dragEl","parentEl","ghostEl","nextEl","lastDownEl","cloneHidden","dragStarted","moved","activeSortable","active","hideGhostForTarget","_hideGhostForTarget","unhideGhostForTarget","_unhideGhostForTarget","cloneNowHidden","cloneNowShown","dispatchSortableEvent","_dispatchEvent","info","activeGroup","tapEvt","touchEvt","lastDx","lastDy","tapDistanceLeft","tapDistanceTop","lastTarget","lastDirection","targetMoveDistance","ghostRelativeParent","awaitingDragStarted","ignoreNextClick","sortables","pastFirstInvertThresh","isCircumstantialInvert","ghostRelativeParentInitialScroll","_silent","savedInputChecked","documentExists","PositionGhostAbsolutely","CSSFloatProperty","supportDraggable","createElement","supportCssPointerEvents","cssText","pointerEvents","_detectDirection","elCSS","elWidth","paddingLeft","paddingRight","borderLeftWidth","borderRightWidth","child1","child2","firstChildCSS","secondChildCSS","firstChildWidth","marginLeft","marginRight","secondChildWidth","flexDirection","gridTemplateColumns","split","clear","_prepareGroup","toFn","pull","group","otherGroup","join","originalGroup","checkPull","checkPut","put","revertClone","preventDefault","stopPropagation","stopImmediatePropagation","lastSwapEl","nearestEmptyInsertDetectEvent","nearest","touches","clientX","clientY","some","threshold","emptyInsertThreshold","ret","target","_onDragOver","_checkOutsideTargetEl","_isOutsideThisEl","toString","animationCallbackId","animationStates","sort","disabled","store","handle","test","swapThreshold","invertSwap","invertedSwapThreshold","removeCloneOnHide","direction","ghostClass","chosenClass","dragClass","ignore","filter","preventOnFilter","animation","easing","setData","dataTransfer","textContent","dropBubble","dragoverBubble","dataIdAttr","delay","delayOnTouchOnly","touchStartThreshold","Number","devicePixelRatio","forceFallback","fallbackClass","fallbackOnBody","fallbackTolerance","fallbackOffset","supportPointer","nativeDraggable","_onTapStart","get","captureAnimationState","slice","child","fromRect","thisAnimationDuration","childMatrix","f","e","addAnimationState","removeAnimationState","splice","arr","obj","key","indexOfObject","animateAll","clearTimeout","animating","animationTime","time","toRect","prevFromRect","prevToRect","animatingRect","targetMatrix","sqrt","pow","calculateRealTime","animate","max","animationResetTimer","currentRect","duration","translateX","translateY","animatingX","animatingY","forRepaintDummy","offsetWidth","repaint","animated","onMove","dragRect","targetRect","willInsertAfter","retVal","onMoveFn","draggedRect","related","relatedRect","_disableDraggable","_unsilent","_generateId","str","src","href","sum","charCodeAt","_nextTick","_cancelNextTick","id","prototype","constructor","contains","_getDirection","type","touch","pointerType","originalTarget","shadowRoot","path","composedPath","root","inputs","idx","checked","_saveInputCheckedState","button","isContentEditable","criteria","trim","_prepareDragStart","dragStartFn","ownerDocument","nextSibling","_lastX","_lastY","_onDrop","_disableDelayedDragEvents","_triggerDragStart","_disableDelayedDrag","_delayedDragTouchMoveHandler","_dragStartTimer","abs","floor","_onTouchMove","_onDragStart","selection","empty","getSelection","removeAllRanges","err","_dragStarted","fallback","_appendGhost","_nulling","_emulateDragOver","elementFromPoint","ghostMatrix","relativeScrollOffset","dx","dy","b","c","cssMatrix","appendChild","_hideClone","cloneId","insertBefore","_loopId","setInterval","effectAllowed","_dragStartId","revert","vertical","isOwner","canSort","fromSortable","completedFired","dragOverEvent","_ignoreWhileAnimating","completed","elLastChild","_ghostIsLast","changed","targetBeforeFirstSwap","sibling","differentLevel","differentRowCol","dragElS1Opp","targetS1Opp","_dragElInRowColumn","side1","scrolledPastTop","scrollBefore","isLastTarget","mouseOnAxis","targetLength","targetS1","targetS2","invert","_getInsertDirection","_getSwapDirection","dragIndex","nextElementSibling","after","moveVector","extra","axis","insertion","_showClone","_offMoveEvents","_offUpEvents","clearInterval","removeChild","save","handleEvent","dropEffect","_globalDragOver","toArray","order","getAttribute","items","set","destroy","Array","querySelectorAll","removeAttribute","utils","is","extend","dst","nextTick","cancelNextTick","detectDirection","element","create","version","lastMultiDragSelect","multiDragSortable","clonesFromRect","clonesHidden","multiDragElements","multiDragClones","initialFolding","folding","insertMultiDragClones","elementsInserted","sortableIndex","removeMultiDragElements","multiDragElement","drop","t","toSortable","changedTouches","onSpill","Revert","Remove","startIndex","dragStart","parentSortable","scrollEl","scrollRootEl","lastAutoScrollX","lastAutoScrollY","pointerElemChangedInterval","autoScrolls","scrolling","clearAutoScrolls","autoScroll","pid","clearPointerElemChangedInterval","isFallback","scroll","scrollCustomFn","sens","scrollSensitivity","speed","scrollSpeed","scrollThisInstance","scrollFn","layersOut","currentParent","canScrollX","canScrollY","scrollPosX","scrollPosY","vx","vy","layer","scrollOffsetY","scrollOffsetX","bubbleScroll","AutoScroll","_handleAutoScroll","_handleFallbackAutoScroll","dragOverCompleted","dragOverBubble","nulling","ogElemScroller","newElem","RemoveOnSpill","RevertOnSpill","Swap","swapClass","dragOverValid","swap","prevSwapEl","n1","n2","i1","i2","p1","p2","isEqualNode","swapItem","MultiDrag","_deselectMultiDrag","_checkKeyDown","_checkKeyUp","selectedClass","multiDragKey","multiDragKeyDown","isMultiDrag","delayStartGlobal","delayEnded","setupClone","showClone","hideClone","dragStartGlobal","multiDrag","_this2","dragOver","clonesInserted","insertMultiDragElements","dragRectAbsolute","clonesHiddenBefore","dragOverAnimationCapture","dragMatrix","dragOverAnimationComplete","originalEvt","shiftKey","lastIndex","currentIndex","multiDragIndex","update","nullingGlobal","destroyGlobal","shift","select","deselect","oldIndicies","newIndicies","_this3","clones","toLowerCase"],"sources":["../../utils/src/browser-info.ts","../../utils/src/utils.ts","../../sortable/src/PluginManager.ts","../../sortable/src/EventDispatcher.ts","../../sortable/src/Sortable.ts","../../plugins/swap/src/index.ts","../../sortable/src/Animation.ts","../../plugins/multi-drag/src/index.ts","../../plugins/on-spill/src/index.ts","../../plugins/auto-scroll/src/index.ts","../src/modular-complete.ts"],"sourcesContent":["function userAgent(pattern) {\n  if (typeof window !== \"undefined\" && window.navigator) {\n    return !!(/*@__PURE__*/ navigator.userAgent.match(pattern));\n  }\n}\n\nexport const IE11OrLess = userAgent(\n  /(?:Trident.*rv[ :]?11\\.|msie|iemobile|Windows Phone)/i\n);\nexport const Edge = userAgent(/Edge/i);\nexport const FireFox = userAgent(/firefox/i);\nexport const Safari =\n  userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);\nexport const IOS = userAgent(/iP(ad|od|hone)/i);\nexport const ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);\n","import { IE11OrLess } from \"./browser-info\";\nimport Sortable from \"../../sortable/src/Sortable\";\n\nconst captureMode = {\n  capture: false,\n  passive: false,\n};\n\nfunction on(el, event, fn) {\n  el.addEventListener(event, fn, !IE11OrLess && captureMode);\n}\n\nfunction off(el, event, fn) {\n  el.removeEventListener(event, fn, !IE11OrLess && captureMode);\n}\n\nfunction matches(/**HTMLElement*/ el, /**String*/ selector) {\n  if (!selector) return;\n\n  selector[0] === \">\" && (selector = selector.substring(1));\n\n  if (el) {\n    try {\n      if (el.matches) {\n        return el.matches(selector);\n      } else if (el.msMatchesSelector) {\n        return el.msMatchesSelector(selector);\n      } else if (el.webkitMatchesSelector) {\n        return el.webkitMatchesSelector(selector);\n      }\n    } catch (_) {\n      return false;\n    }\n  }\n\n  return false;\n}\n\nfunction getParentOrHost(el) {\n  return el.host && el !== document && el.host.nodeType\n    ? el.host\n    : el.parentNode;\n}\n\nfunction closest(\n  /**HTMLElement*/ el,\n  /**String*/ selector,\n  /**HTMLElement*/ ctx,\n  includeCTX\n) {\n  if (el) {\n    ctx = ctx || document;\n\n    do {\n      if (\n        (selector != null &&\n          (selector[0] === \">\"\n            ? el.parentNode === ctx && matches(el, selector)\n            : matches(el, selector))) ||\n        (includeCTX && el === ctx)\n      ) {\n        return el;\n      }\n\n      if (el === ctx) break;\n      /* jshint boss:true */\n    } while ((el = getParentOrHost(el)));\n  }\n\n  return null;\n}\n\nconst R_SPACE = /\\s+/g;\n\nfunction toggleClass(el, name, state) {\n  if (el && name) {\n    if (el.classList) {\n      el.classList[state ? \"add\" : \"remove\"](name);\n    } else {\n      let className = (\" \" + el.className + \" \")\n        .replace(R_SPACE, \" \")\n        .replace(\" \" + name + \" \", \" \");\n      el.className = (className + (state ? \" \" + name : \"\")).replace(\n        R_SPACE,\n        \" \"\n      );\n    }\n  }\n}\n\nfunction css(el, prop, val) {\n  let style = el && el.style;\n\n  if (style) {\n    if (val === void 0) {\n      if (document.defaultView && document.defaultView.getComputedStyle) {\n        val = document.defaultView.getComputedStyle(el, \"\");\n      } else if (el.currentStyle) {\n        val = el.currentStyle;\n      }\n\n      return prop === void 0 ? val : val[prop];\n    } else {\n      if (!(prop in style) && prop.indexOf(\"webkit\") === -1) {\n        prop = \"-webkit-\" + prop;\n      }\n\n      style[prop] = val + (typeof val === \"string\" ? \"\" : \"px\");\n    }\n  }\n}\n\nfunction matrix(el, selfOnly) {\n  let appliedTransforms = \"\";\n  if (typeof el === \"string\") {\n    appliedTransforms = el;\n  } else {\n    do {\n      //@ts-ignore\n      let transform = css(el, \"transform\");\n\n      if (transform && transform !== \"none\") {\n        appliedTransforms = transform + \" \" + appliedTransforms;\n      }\n      /* jshint boss:true */\n    } while (!selfOnly && (el = el.parentNode));\n  }\n\n  const matrixFn =\n    window.DOMMatrix ||\n    window.WebKitCSSMatrix ||\n    //@ts-ignore\n    window.CSSMatrix ||\n    //@ts-ignore\n    window.MSCSSMatrix;\n  /*jshint -W056 */\n  return matrixFn && new matrixFn(appliedTransforms);\n}\n\nfunction find(ctx, tagName, iterator) {\n  if (ctx) {\n    let list = ctx.getElementsByTagName(tagName),\n      i = 0,\n      n = list.length;\n\n    if (iterator) {\n      for (; i < n; i++) {\n        iterator(list[i], i);\n      }\n    }\n\n    return list;\n  }\n\n  return [];\n}\n\nfunction getWindowScrollingElement() {\n  let scrollingElement = document.scrollingElement;\n\n  if (scrollingElement) {\n    return scrollingElement;\n  } else {\n    return document.documentElement;\n  }\n}\n\n/**\n * Returns the \"bounding client rect\" of given element\n * @param  {HTMLElement} el                       The element whose boundingClientRect is wanted\n * @param  {[Boolean]} relativeToContainingBlock  Whether the rect should be relative to the containing block of (including) the container\n * @param  {[Boolean]} relativeToNonStaticParent  Whether the rect should be relative to the relative parent of (including) the contaienr\n * @param  {[Boolean]} undoScale                  Whether the container's scale() should be undone\n * @param  {[HTMLElement]} container              The parent the element will be placed in\n * @return {Object}                               The boundingClientRect of el, with specified adjustments\n */\nfunction getRect(\n  el,\n  relativeToContainingBlock,\n  relativeToNonStaticParent,\n  undoScale,\n  container\n) {\n  if (!el.getBoundingClientRect && el !== window) return;\n\n  let elRect, top, left, bottom, right, height, width;\n\n  if (el !== window && el !== getWindowScrollingElement()) {\n    elRect = el.getBoundingClientRect();\n    top = elRect.top;\n    left = elRect.left;\n    bottom = elRect.bottom;\n    right = elRect.right;\n    height = elRect.height;\n    width = elRect.width;\n  } else {\n    top = 0;\n    left = 0;\n    bottom = window.innerHeight;\n    right = window.innerWidth;\n    height = window.innerHeight;\n    width = window.innerWidth;\n  }\n\n  if (\n    (relativeToContainingBlock || relativeToNonStaticParent) &&\n    el !== window\n  ) {\n    // Adjust for translate()\n    container = container || el.parentNode;\n\n    // solves #1123 (see: https://stackoverflow.com/a/37953806/6088312)\n    // Not needed on <= IE11\n    if (!IE11OrLess) {\n      do {\n        if (\n          container &&\n          container.getBoundingClientRect &&\n          //@ts-ignore\n          (css(container, \"transform\") !== \"none\" ||\n            (relativeToNonStaticParent &&\n              //@ts-ignore\n              css(container, \"position\") !== \"static\"))\n        ) {\n          let containerRect = container.getBoundingClientRect();\n\n          // Set relative to edges of padding box of container\n          top -=\n            //@ts-ignore\n            containerRect.top + parseInt(css(container, \"border-top-width\"));\n          left -=\n            //@ts-ignore\n            containerRect.left + parseInt(css(container, \"border-left-width\"));\n          bottom = top + elRect.height;\n          right = left + elRect.width;\n\n          break;\n        }\n        /* jshint boss:true */\n      } while ((container = container.parentNode));\n    }\n  }\n\n  if (undoScale && el !== window) {\n    // Adjust for scale()\n    //@ts-ignore\n    let elMatrix = matrix(container || el),\n      scaleX = elMatrix && elMatrix.a,\n      scaleY = elMatrix && elMatrix.d;\n\n    if (elMatrix) {\n      top /= scaleY;\n      left /= scaleX;\n\n      width /= scaleX;\n      height /= scaleY;\n\n      bottom = top + height;\n      right = left + width;\n    }\n  }\n\n  return {\n    top: top,\n    left: left,\n    bottom: bottom,\n    right: right,\n    width: width,\n    height: height,\n  };\n}\n\n/**\n * Checks if a side of an element is scrolled past a side of its parents\n * @param  {HTMLElement}  el           The element who's side being scrolled out of view is in question\n * @param  {String}       elSide       Side of the element in question ('top', 'left', 'right', 'bottom')\n * @param  {String}       parentSide   Side of the parent in question ('top', 'left', 'right', 'bottom')\n * @return {HTMLElement}               The parent scroll element that the el's side is scrolled past, or null if there is no such element\n */\nfunction isScrolledPast(el, elSide, parentSide) {\n  let parent = getParentAutoScrollElement(el, true),\n    //@ts-ignore\n    elSideVal = getRect(el)[elSide];\n\n  /* jshint boss:true */\n  while (parent) {\n    //@ts-ignore\n    let parentSideVal = getRect(parent)[parentSide],\n      visible;\n\n    if (parentSide === \"top\" || parentSide === \"left\") {\n      visible = elSideVal >= parentSideVal;\n    } else {\n      visible = elSideVal <= parentSideVal;\n    }\n\n    if (!visible) return parent;\n\n    if (parent === getWindowScrollingElement()) break;\n\n    parent = getParentAutoScrollElement(parent, false);\n  }\n\n  return false;\n}\n\n/**\n * Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)\n * and non-draggable elements\n * @param  {HTMLElement} el       The parent element\n * @param  {Number} childNum      The index of the child\n * @param  {Object} options       Parent Sortable's options\n * @return {HTMLElement}          The child at index childNum, or null if not found\n */\nfunction getChild(el, childNum, options) {\n  let currentChild = 0,\n    i = 0,\n    children = el.children;\n\n  while (i < children.length) {\n    if (\n      children[i].style.display !== \"none\" &&\n      //@ts-ignore\n      children[i] !== Sortable.ghost &&\n      //@ts-ignore\n      children[i] !== Sortable.dragged &&\n      closest(children[i], options.draggable, el, false)\n    ) {\n      if (currentChild === childNum) {\n        return children[i];\n      }\n      currentChild++;\n    }\n\n    i++;\n  }\n  return null;\n}\n\n/**\n * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)\n * @param  {HTMLElement} el       Parent element\n * @param  {selector} selector    Any other elements that should be ignored\n * @return {HTMLElement}          The last child, ignoring ghostEl\n */\nfunction lastChild(el, selector) {\n  let last = el.lastElementChild;\n\n  while (\n    last &&\n    //@ts-ignore\n    (last === Sortable.ghost ||\n      //@ts-ignore\n      css(last, \"display\") === \"none\" ||\n      (selector && !matches(last, selector)))\n  ) {\n    last = last.previousElementSibling;\n  }\n\n  return last || null;\n}\n\n/**\n * Returns the index of an element within its parent for a selected set of\n * elements\n * @param  {HTMLElement} el\n * @param  {selector} selector\n * @return {number}\n */\nfunction index(el, selector) {\n  let index = 0;\n\n  if (!el || !el.parentNode) {\n    return -1;\n  }\n\n  /* jshint boss:true */\n  while ((el = el.previousElementSibling)) {\n    if (\n      el.nodeName.toUpperCase() !== \"TEMPLATE\" &&\n      //@ts-ignore\n      el !== Sortable.clone &&\n      (!selector || matches(el, selector))\n    ) {\n      index++;\n    }\n  }\n\n  return index;\n}\n\n/**\n * Returns the scroll offset of the given element, added with all the scroll offsets of parent elements.\n * The value is returned in real pixels.\n * @param  {HTMLElement} el\n * @return {Array}             Offsets in the format of [left, top]\n */\nfunction getRelativeScrollOffset(el) {\n  let offsetLeft = 0,\n    offsetTop = 0,\n    winScroller = getWindowScrollingElement();\n\n  if (el) {\n    do {\n      //@ts-ignore\n      let elMatrix = matrix(el),\n        scaleX = elMatrix.a,\n        scaleY = elMatrix.d;\n\n      offsetLeft += el.scrollLeft * scaleX;\n      offsetTop += el.scrollTop * scaleY;\n    } while (el !== winScroller && (el = el.parentNode));\n  }\n\n  return [offsetLeft, offsetTop];\n}\n\n/**\n * Returns the index of the object within the given array\n * @param  {Array} arr   Array that may or may not hold the object\n * @param  {Object} obj  An object that has a key-value pair unique to and identical to a key-value pair in the object you want to find\n * @return {Number}      The index of the object in the array, or -1\n */\nfunction indexOfObject(arr, obj) {\n  for (let i in arr) {\n    if (!arr.hasOwnProperty(i)) continue;\n    for (let key in obj) {\n      if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);\n    }\n  }\n  return -1;\n}\n\nfunction getParentAutoScrollElement(el, includeSelf) {\n  // skip to window\n  if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();\n\n  let elem = el;\n  let gotSelf = false;\n  do {\n    // we don't need to get elem css if it isn't even overflowing in the first place (performance)\n    if (\n      elem.clientWidth < elem.scrollWidth ||\n      elem.clientHeight < elem.scrollHeight\n    ) {\n      //@ts-ignore\n      let elemCSS = css(elem);\n      if (\n        (elem.clientWidth < elem.scrollWidth &&\n          (elemCSS.overflowX == \"auto\" || elemCSS.overflowX == \"scroll\")) ||\n        (elem.clientHeight < elem.scrollHeight &&\n          (elemCSS.overflowY == \"auto\" || elemCSS.overflowY == \"scroll\"))\n      ) {\n        if (!elem.getBoundingClientRect || elem === document.body)\n          return getWindowScrollingElement();\n\n        if (gotSelf || includeSelf) return elem;\n        gotSelf = true;\n      }\n    }\n    /* jshint boss:true */\n  } while ((elem = elem.parentNode));\n\n  return getWindowScrollingElement();\n}\n\nfunction extend(dst, src) {\n  if (dst && src) {\n    for (let key in src) {\n      if (src.hasOwnProperty(key)) {\n        dst[key] = src[key];\n      }\n    }\n  }\n\n  return dst;\n}\n\nfunction isRectEqual(rect1, rect2) {\n  return (\n    Math.round(rect1.top) === Math.round(rect2.top) &&\n    Math.round(rect1.left) === Math.round(rect2.left) &&\n    Math.round(rect1.height) === Math.round(rect2.height) &&\n    Math.round(rect1.width) === Math.round(rect2.width)\n  );\n}\n\nlet _throttleTimeout;\nfunction throttle(callback, ms) {\n  return function () {\n    if (!_throttleTimeout) {\n      let args = arguments,\n        _this = this;\n\n      if (args.length === 1) {\n        callback.call(_this, args[0]);\n      } else {\n        callback.apply(_this, args);\n      }\n\n      _throttleTimeout = setTimeout(function () {\n        _throttleTimeout = void 0;\n      }, ms);\n    }\n  };\n}\n\nfunction cancelThrottle() {\n  clearTimeout(_throttleTimeout);\n  _throttleTimeout = void 0;\n}\n\nfunction scrollBy(el, x, y) {\n  el.scrollLeft += x;\n  el.scrollTop += y;\n}\n\nfunction clone(el) {\n  //@ts-ignore\n  let Polymer = window.Polymer;\n  //@ts-ignore\n  let $ = window.jQuery || window.Zepto;\n\n  if (Polymer && Polymer.dom) {\n    return Polymer.dom(el).cloneNode(true);\n  } else if ($) {\n    return $(el).clone(true)[0];\n  } else {\n    return el.cloneNode(true);\n  }\n}\n\nfunction setRect(el, rect) {\n  css(el, \"position\", \"absolute\");\n  css(el, \"top\", rect.top);\n  css(el, \"left\", rect.left);\n  css(el, \"width\", rect.width);\n  css(el, \"height\", rect.height);\n}\n\nfunction unsetRect(el) {\n  css(el, \"position\", \"\");\n  css(el, \"top\", \"\");\n  css(el, \"left\", \"\");\n  css(el, \"width\", \"\");\n  css(el, \"height\", \"\");\n}\n\nconst expando = \"Sortable\" + new Date().getTime();\n\nexport {\n  on,\n  off,\n  matches,\n  getParentOrHost,\n  closest,\n  toggleClass,\n  css,\n  matrix,\n  find,\n  getWindowScrollingElement,\n  getRect,\n  isScrolledPast,\n  getChild,\n  lastChild,\n  index,\n  getRelativeScrollOffset,\n  indexOfObject,\n  getParentAutoScrollElement,\n  extend,\n  isRectEqual,\n  throttle,\n  cancelThrottle,\n  scrollBy,\n  clone,\n  setRect,\n  unsetRect,\n  expando,\n};\n","let plugins = [];\n\nconst defaults = {\n  initializeByDefault: true,\n};\n\nconst pluginManager = {\n  mount(plugin) {\n    // Set default static properties\n    for (let option in defaults) {\n      if (defaults.hasOwnProperty(option) && !(option in plugin)) {\n        plugin[option] = defaults[option];\n      }\n    }\n    plugins.push(plugin);\n  },\n  pluginEvent(eventName, sortable, evt) {\n    this.eventCanceled = false;\n    evt.cancel = () => {\n      this.eventCanceled = true;\n    };\n    const eventNameGlobal = eventName + \"Global\";\n    plugins.forEach((plugin) => {\n      if (!sortable[plugin.pluginName]) return;\n      // Fire global events if it exists in this sortable\n      if (sortable[plugin.pluginName][eventNameGlobal]) {\n        sortable[plugin.pluginName][eventNameGlobal]({ sortable, ...evt });\n      }\n\n      // Only fire plugin event if plugin is enabled in this sortable,\n      // and plugin has event defined\n      if (\n        sortable.options[plugin.pluginName] &&\n        sortable[plugin.pluginName][eventName]\n      ) {\n        sortable[plugin.pluginName][eventName]({ sortable, ...evt });\n      }\n    });\n  },\n  initializePlugins(sortable, el, defaults, options) {\n    plugins.forEach((plugin) => {\n      const pluginName = plugin.pluginName;\n      if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;\n\n      let initialized = new plugin(sortable, el, sortable.options);\n      initialized.sortable = sortable;\n      initialized.options = sortable.options;\n      sortable[pluginName] = initialized;\n\n      // Add default options from plugin\n      Object.assign(defaults, initialized.defaults);\n    });\n\n    for (let option in sortable.options) {\n      if (!sortable.options.hasOwnProperty(option)) continue;\n      let modified = this.modifyOption(\n        sortable,\n        option,\n        sortable.options[option]\n      );\n      if (typeof modified !== \"undefined\") {\n        sortable.options[option] = modified;\n      }\n    }\n  },\n  getEventProperties(name, sortable) {\n    let eventProperties = {};\n    plugins.forEach((plugin) => {\n      if (typeof plugin.eventProperties !== \"function\") return;\n      Object.assign(\n        eventProperties,\n        plugin.eventProperties.call(sortable[plugin.pluginName], name)\n      );\n    });\n\n    return eventProperties;\n  },\n  modifyOption(sortable, name, value) {\n    let modifiedValue;\n    plugins.forEach((plugin) => {\n      // Plugin must exist on the Sortable\n      if (!sortable[plugin.pluginName]) return;\n\n      // If static option listener exists for this option, call in the context of the Sortable's instance of this plugin\n      if (\n        plugin.optionListeners &&\n        typeof plugin.optionListeners[name] === \"function\"\n      ) {\n        modifiedValue = plugin.optionListeners[name].call(\n          sortable[plugin.pluginName],\n          value\n        );\n      }\n    });\n\n    return modifiedValue;\n  },\n};\n\nexport default pluginManager;\n","import { expando, IE11OrLess, Edge } from \"../../utils/src\";\nimport PluginManager from \"./PluginManager\";\n\nexport default function dispatchEvent({\n  sortable,\n  rootEl,\n  name,\n  targetEl,\n  cloneEl,\n  toEl,\n  fromEl,\n  oldIndex,\n  newIndex,\n  oldDraggableIndex,\n  newDraggableIndex,\n  originalEvent,\n  putSortable,\n  extraEventProperties,\n}) {\n  sortable = sortable || (rootEl && rootEl[expando]);\n  if (!sortable) return;\n\n  let evt,\n    options = sortable.options,\n    onName = \"on\" + name.charAt(0).toUpperCase() + name.substr(1);\n  // Support for new CustomEvent feature\n  if (window.CustomEvent && !IE11OrLess && !Edge) {\n    evt = new CustomEvent(name, {\n      bubbles: true,\n      cancelable: true,\n    });\n  } else {\n    evt = document.createEvent(\"Event\");\n    evt.initEvent(name, true, true);\n  }\n\n  evt.to = toEl || rootEl;\n  evt.from = fromEl || rootEl;\n  evt.item = targetEl || rootEl;\n  evt.clone = cloneEl;\n\n  evt.oldIndex = oldIndex;\n  evt.newIndex = newIndex;\n\n  evt.oldDraggableIndex = oldDraggableIndex;\n  evt.newDraggableIndex = newDraggableIndex;\n\n  evt.originalEvent = originalEvent;\n  evt.pullMode = putSortable ? putSortable.lastPutMode : undefined;\n\n  let allEventProperties = {\n    ...extraEventProperties,\n    ...PluginManager.getEventProperties(name, sortable),\n  };\n  for (let option in allEventProperties) {\n    evt[option] = allEventProperties[option];\n  }\n\n  if (rootEl) {\n    rootEl.dispatchEvent(evt);\n  }\n\n  if (options[onName]) {\n    options[onName].call(sortable, evt);\n  }\n}\n","import { version } from \"../package.json\";\nimport AnimationStateManager from \"./Animation\";\nimport PluginManager from \"./PluginManager\";\nimport dispatchEvent from \"./EventDispatcher\";\n/**\n * @todo import as namespace: import * as utils from \"../../utils/src\"\n */\nimport {\n  on,\n  off,\n  closest,\n  toggleClass,\n  css,\n  matrix,\n  find,\n  getWindowScrollingElement,\n  getRect,\n  isScrolledPast,\n  getChild,\n  lastChild,\n  index,\n  getRelativeScrollOffset,\n  extend,\n  throttle,\n  scrollBy,\n  clone,\n  expando,\n  IE11OrLess,\n  Edge,\n  FireFox,\n  Safari,\n  IOS,\n  ChromeForAndroid,\n} from \"../../utils/src\";\n\nlet pluginEvent = function (\n  eventName,\n  sortable,\n  //@ts-ignore\n  { evt: originalEvent, ...data } = {}\n) {\n  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, {\n    dragEl,\n    parentEl,\n    ghostEl,\n    rootEl,\n    nextEl,\n    lastDownEl,\n    cloneEl,\n    cloneHidden,\n    dragStarted: moved,\n    putSortable,\n    //@ts-ignore\n    activeSortable: Sortable.active,\n    originalEvent,\n\n    oldIndex,\n    oldDraggableIndex,\n    newIndex,\n    newDraggableIndex,\n\n    hideGhostForTarget: _hideGhostForTarget,\n    unhideGhostForTarget: _unhideGhostForTarget,\n\n    cloneNowHidden() {\n      cloneHidden = true;\n    },\n    cloneNowShown() {\n      cloneHidden = false;\n    },\n\n    dispatchSortableEvent(name) {\n      _dispatchEvent({ sortable, name, originalEvent });\n    },\n\n    ...data,\n  });\n};\n\nfunction _dispatchEvent(info) {\n  dispatchEvent({\n    putSortable,\n    cloneEl,\n    targetEl: dragEl,\n    rootEl,\n    oldIndex,\n    oldDraggableIndex,\n    newIndex,\n    newDraggableIndex,\n    ...info,\n  });\n}\n\nlet dragEl,\n  parentEl,\n  ghostEl,\n  rootEl,\n  nextEl,\n  lastDownEl,\n  cloneEl,\n  cloneHidden,\n  oldIndex,\n  newIndex,\n  oldDraggableIndex,\n  newDraggableIndex,\n  activeGroup,\n  putSortable,\n  awaitingDragStarted = false,\n  ignoreNextClick = false,\n  sortables = [],\n  tapEvt,\n  touchEvt,\n  lastDx,\n  lastDy,\n  tapDistanceLeft,\n  tapDistanceTop,\n  moved,\n  lastTarget,\n  lastDirection,\n  pastFirstInvertThresh = false,\n  isCircumstantialInvert = false,\n  targetMoveDistance,\n  // For positioning ghost absolutely\n  ghostRelativeParent,\n  ghostRelativeParentInitialScroll = [], // (left, top)\n  _silent = false,\n  savedInputChecked = [];\n\n/** @const */\nconst documentExists = typeof document !== \"undefined\",\n  PositionGhostAbsolutely = IOS,\n  CSSFloatProperty = Edge || IE11OrLess ? \"cssFloat\" : \"float\",\n  // This will not pass for IE9, because IE9 DnD only works on anchors\n  supportDraggable =\n    documentExists &&\n    !ChromeForAndroid &&\n    !IOS &&\n    \"draggable\" in document.createElement(\"div\"),\n  supportCssPointerEvents = (function () {\n    if (!documentExists) return;\n    // false when <= IE11\n    if (IE11OrLess) {\n      return false;\n    }\n    let el = document.createElement(\"x\");\n    el.style.cssText = \"pointer-events:auto\";\n    return el.style.pointerEvents === \"auto\";\n  })(),\n  _detectDirection = function (el, options) {\n    //@ts-ignore\n    let elCSS = css(el),\n      elWidth =\n        parseInt(elCSS.width) -\n        parseInt(elCSS.paddingLeft) -\n        parseInt(elCSS.paddingRight) -\n        parseInt(elCSS.borderLeftWidth) -\n        parseInt(elCSS.borderRightWidth),\n      child1 = getChild(el, 0, options),\n      child2 = getChild(el, 1, options),\n      //@ts-ignore\n      firstChildCSS = child1 && css(child1),\n      //@ts-ignore\n      secondChildCSS = child2 && css(child2),\n      firstChildWidth =\n        firstChildCSS &&\n        parseInt(firstChildCSS.marginLeft) +\n          parseInt(firstChildCSS.marginRight) +\n          //@ts-ignore\n          getRect(child1).width,\n      secondChildWidth =\n        secondChildCSS &&\n        parseInt(secondChildCSS.marginLeft) +\n          parseInt(secondChildCSS.marginRight) +\n          //@ts-ignore\n          getRect(child2).width;\n\n    if (elCSS.display === \"flex\") {\n      return elCSS.flexDirection === \"column\" ||\n        elCSS.flexDirection === \"column-reverse\"\n        ? \"vertical\"\n        : \"horizontal\";\n    }\n\n    if (elCSS.display === \"grid\") {\n      return elCSS.gridTemplateColumns.split(\" \").length <= 1\n        ? \"vertical\"\n        : \"horizontal\";\n    }\n\n    if (child1 && firstChildCSS.float && firstChildCSS.float !== \"none\") {\n      let touchingSideChild2 =\n        firstChildCSS.float === \"left\" ? \"left\" : \"right\";\n\n      return child2 &&\n        (secondChildCSS.clear === \"both\" ||\n          secondChildCSS.clear === touchingSideChild2)\n        ? \"vertical\"\n        : \"horizontal\";\n    }\n\n    return child1 &&\n      (firstChildCSS.display === \"block\" ||\n        firstChildCSS.display === \"flex\" ||\n        firstChildCSS.display === \"table\" ||\n        firstChildCSS.display === \"grid\" ||\n        (firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === \"none\") ||\n        (child2 &&\n          elCSS[CSSFloatProperty] === \"none\" &&\n          firstChildWidth + secondChildWidth > elWidth))\n      ? \"vertical\"\n      : \"horizontal\";\n  },\n  _dragElInRowColumn = function (dragRect, targetRect, vertical) {\n    let dragElS1Opp = vertical ? dragRect.left : dragRect.top,\n      dragElS2Opp = vertical ? dragRect.right : dragRect.bottom,\n      dragElOppLength = vertical ? dragRect.width : dragRect.height,\n      targetS1Opp = vertical ? targetRect.left : targetRect.top,\n      targetS2Opp = vertical ? targetRect.right : targetRect.bottom,\n      targetOppLength = vertical ? targetRect.width : targetRect.height;\n\n    return (\n      dragElS1Opp === targetS1Opp ||\n      dragElS2Opp === targetS2Opp ||\n      dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2\n    );\n  },\n  /**\n   * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.\n   * @param  {Number} x      X position\n   * @param  {Number} y      Y position\n   * @return {HTMLElement}   Element of the first found nearest Sortable\n   */\n  _detectNearestEmptySortable = function (x, y) {\n    let ret;\n    sortables.some((sortable) => {\n      //@ts-ignore\n      if (lastChild(sortable)) return;\n\n      //@ts-ignore\n      let rect = getRect(sortable),\n        threshold = sortable[expando].options.emptyInsertThreshold,\n        insideHorizontally =\n          x >= rect.left - threshold && x <= rect.right + threshold,\n        insideVertically =\n          y >= rect.top - threshold && y <= rect.bottom + threshold;\n\n      if (threshold && insideHorizontally && insideVertically) {\n        return (ret = sortable);\n      }\n    });\n    return ret;\n  },\n  _prepareGroup = function (options) {\n    function toFn(value, pull) {\n      return function (to, from, dragEl, evt) {\n        let sameGroup =\n          to.options.group.name &&\n          from.options.group.name &&\n          to.options.group.name === from.options.group.name;\n\n        if (value == null && (pull || sameGroup)) {\n          // Default pull value\n          // Default pull and put value if same group\n          return true;\n        } else if (value == null || value === false) {\n          return false;\n        } else if (pull && value === \"clone\") {\n          return value;\n        } else if (typeof value === \"function\") {\n          return toFn(value(to, from, dragEl, evt), pull)(\n            to,\n            from,\n            dragEl,\n            evt\n          );\n        } else {\n          let otherGroup = (pull ? to : from).options.group.name;\n\n          return (\n            value === true ||\n            (typeof value === \"string\" && value === otherGroup) ||\n            (value.join && value.indexOf(otherGroup) > -1)\n          );\n        }\n      };\n    }\n\n    let group = {};\n    let originalGroup = options.group;\n\n    if (!originalGroup || typeof originalGroup != \"object\") {\n      originalGroup = { name: originalGroup };\n    }\n\n    //@ts-ignore\n    group.name = originalGroup.name;\n    //@ts-ignore\n    group.checkPull = toFn(originalGroup.pull, true);\n    //@ts-ignore\n    group.checkPut = toFn(originalGroup.put);\n    //@ts-ignore\n    group.revertClone = originalGroup.revertClone;\n\n    options.group = group;\n  },\n  _hideGhostForTarget = function () {\n    if (!supportCssPointerEvents && ghostEl) {\n      css(ghostEl, \"display\", \"none\");\n    }\n  },\n  _unhideGhostForTarget = function () {\n    if (!supportCssPointerEvents && ghostEl) {\n      css(ghostEl, \"display\", \"\");\n    }\n  };\n\n// #1184 fix - Prevent click event on fallback if dragged but item not changed position\nif (documentExists) {\n  document.addEventListener(\n    \"click\",\n    function (evt) {\n      if (ignoreNextClick) {\n        evt.preventDefault();\n        evt.stopPropagation && evt.stopPropagation();\n        evt.stopImmediatePropagation && evt.stopImmediatePropagation();\n        ignoreNextClick = false;\n        return false;\n      }\n    },\n    true\n  );\n}\n\nlet nearestEmptyInsertDetectEvent = function (evt) {\n  if (dragEl) {\n    evt = evt.touches ? evt.touches[0] : evt;\n    let nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);\n\n    if (nearest) {\n      // Create imitation event\n      let event = {};\n      for (let i in evt) {\n        if (evt.hasOwnProperty(i)) {\n          event[i] = evt[i];\n        }\n      }\n      //@ts-ignore\n      event.target = event.rootEl = nearest;\n      //@ts-ignore\n      event.preventDefault = void 0;\n      //@ts-ignore\n      event.stopPropagation = void 0;\n      nearest[expando]._onDragOver(event);\n    }\n  }\n};\n\nlet _checkOutsideTargetEl = function (evt) {\n  if (dragEl) {\n    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);\n  }\n};\n\n/**\n * @class  Sortable\n * @param  {HTMLElement}  el\n * @param  {Object}       [options]\n */\nfunction Sortable(el, options) {\n  if (!(el && el.nodeType && el.nodeType === 1)) {\n    throw `Sortable: \\`el\\` must be an HTMLElement, not ${{}.toString.call(\n      el\n    )}`;\n  }\n\n  this.el = el; // root element\n  this.options = options = Object.assign({}, options);\n\n  // Export instance\n  el[expando] = this;\n\n  let defaults = {\n    group: null,\n    sort: true,\n    disabled: false,\n    store: null,\n    handle: null,\n    draggable: /^[uo]l$/i.test(el.nodeName) ? \">li\" : \">*\",\n    swapThreshold: 1, // percentage; 0 <= x <= 1\n    invertSwap: false, // invert always\n    invertedSwapThreshold: null, // will be set to same as swapThreshold if default\n    removeCloneOnHide: true,\n    direction: function () {\n      return _detectDirection(el, this.options);\n    },\n    ghostClass: \"sortable-ghost\",\n    chosenClass: \"sortable-chosen\",\n    dragClass: \"sortable-drag\",\n    ignore: \"a, img\",\n    filter: null,\n    preventOnFilter: true,\n    animation: 0,\n    easing: null,\n    setData: function (dataTransfer, dragEl) {\n      dataTransfer.setData(\"Text\", dragEl.textContent);\n    },\n    dropBubble: false,\n    dragoverBubble: false,\n    dataIdAttr: \"data-id\",\n    delay: 0,\n    delayOnTouchOnly: false,\n    touchStartThreshold:\n      (Number.parseInt ? Number : window).parseInt(\n        //@ts-ignore\n        window.devicePixelRatio,\n        10\n      ) || 1,\n    forceFallback: false,\n    fallbackClass: \"sortable-fallback\",\n    fallbackOnBody: false,\n    fallbackTolerance: 0,\n    fallbackOffset: { x: 0, y: 0 },\n    supportPointer:\n      //@ts-ignore\n      Sortable.supportPointer !== false && \"PointerEvent\" in window,\n    emptyInsertThreshold: 5,\n  };\n\n  //@ts-ignore\n  PluginManager.initializePlugins(this, el, defaults);\n\n  // Set default options\n  for (let name in defaults) {\n    !(name in options) && (options[name] = defaults[name]);\n  }\n\n  _prepareGroup(options);\n\n  // Bind all private methods\n  for (let fn in this) {\n    if (fn.charAt(0) === \"_\" && typeof this[fn] === \"function\") {\n      this[fn] = this[fn].bind(this);\n    }\n  }\n\n  // Setup drag mode\n  this.nativeDraggable = options.forceFallback ? false : supportDraggable;\n\n  if (this.nativeDraggable) {\n    // Touch start threshold cannot be greater than the native dragstart threshold\n    this.options.touchStartThreshold = 1;\n  }\n\n  // Bind events\n  if (options.supportPointer) {\n    on(el, \"pointerdown\", this._onTapStart);\n  } else {\n    on(el, \"mousedown\", this._onTapStart);\n    on(el, \"touchstart\", this._onTapStart);\n  }\n\n  if (this.nativeDraggable) {\n    on(el, \"dragover\", this);\n    on(el, \"dragenter\", this);\n  }\n\n  sortables.push(this.el);\n\n  // Restore sorting\n  options.store &&\n    options.store.get &&\n    this.sort(options.store.get(this) || []);\n\n  // Add animation state manager\n  Object.assign(this, AnimationStateManager());\n}\n\nSortable.prototype = /** @lends Sortable.prototype */ {\n  constructor: Sortable,\n\n  _isOutsideThisEl: function (target) {\n    if (!this.el.contains(target) && target !== this.el) {\n      lastTarget = null;\n    }\n  },\n\n  _getDirection: function (evt, target) {\n    return typeof this.options.direction === \"function\"\n      ? this.options.direction.call(this, evt, target, dragEl)\n      : this.options.direction;\n  },\n\n  _onTapStart: function (/** Event|TouchEvent */ evt) {\n    if (!evt.cancelable) return;\n    let _this = this,\n      el = this.el,\n      options = this.options,\n      preventOnFilter = options.preventOnFilter,\n      type = evt.type,\n      touch =\n        (evt.touches && evt.touches[0]) ||\n        (evt.pointerType && evt.pointerType === \"touch\" && evt),\n      target = (touch || evt).target,\n      originalTarget =\n        (evt.target.shadowRoot &&\n          ((evt.path && evt.path[0]) ||\n            (evt.composedPath && evt.composedPath()[0]))) ||\n        target,\n      filter = options.filter;\n\n    _saveInputCheckedState(el);\n\n    // Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.\n    if (dragEl) {\n      return;\n    }\n\n    if (\n      (/mousedown|pointerdown/.test(type) && evt.button !== 0) ||\n      options.disabled\n    ) {\n      return; // only left button and enabled\n    }\n\n    // cancel dnd if original target is content editable\n    if (originalTarget.isContentEditable) {\n      return;\n    }\n\n    // Safari ignores further event handling after mousedown\n    if (\n      !this.nativeDraggable &&\n      Safari &&\n      target &&\n      target.tagName.toUpperCase() === \"SELECT\"\n    ) {\n      return;\n    }\n\n    target = closest(target, options.draggable, el, false);\n\n    if (target && target.animated) {\n      return;\n    }\n\n    if (lastDownEl === target) {\n      // Ignoring duplicate `down`\n      return;\n    }\n\n    // Get the index of the dragged element within its parent\n    //@ts-ignore\n    oldIndex = index(target);\n    oldDraggableIndex = index(target, options.draggable);\n\n    // Check filter\n    if (typeof filter === \"function\") {\n      if (filter.call(this, evt, target, this)) {\n        _dispatchEvent({\n          sortable: _this,\n          rootEl: originalTarget,\n          name: \"filter\",\n          targetEl: target,\n          toEl: el,\n          fromEl: el,\n        });\n        pluginEvent(\"filter\", _this, { evt });\n        preventOnFilter && evt.cancelable && evt.preventDefault();\n        return; // cancel dnd\n      }\n    } else if (filter) {\n      filter = filter.split(\",\").some(function (criteria) {\n        criteria = closest(originalTarget, criteria.trim(), el, false);\n\n        if (criteria) {\n          _dispatchEvent({\n            sortable: _this,\n            rootEl: criteria,\n            name: \"filter\",\n            targetEl: target,\n            fromEl: el,\n            toEl: el,\n          });\n          pluginEvent(\"filter\", _this, { evt });\n          return true;\n        }\n      });\n\n      if (filter) {\n        preventOnFilter && evt.cancelable && evt.preventDefault();\n        return; // cancel dnd\n      }\n    }\n\n    if (options.handle && !closest(originalTarget, options.handle, el, false)) {\n      return;\n    }\n\n    // Prepare `dragstart`\n    this._prepareDragStart(evt, touch, target);\n  },\n\n  _prepareDragStart: function (\n    /** Event */ evt,\n    /** Touch */ touch,\n    /** HTMLElement */ target\n  ) {\n    let _this = this,\n      el = _this.el,\n      options = _this.options,\n      ownerDocument = el.ownerDocument,\n      dragStartFn;\n\n    if (target && !dragEl && target.parentNode === el) {\n      //@ts-ignore\n      let dragRect = getRect(target);\n      rootEl = el;\n      dragEl = target;\n      parentEl = dragEl.parentNode;\n      nextEl = dragEl.nextSibling;\n      lastDownEl = target;\n      activeGroup = options.group;\n\n      //@ts-ignore\n      Sortable.dragged = dragEl;\n\n      tapEvt = {\n        target: dragEl,\n        clientX: (touch || evt).clientX,\n        clientY: (touch || evt).clientY,\n      };\n\n      tapDistanceLeft = tapEvt.clientX - dragRect.left;\n      tapDistanceTop = tapEvt.clientY - dragRect.top;\n\n      this._lastX = (touch || evt).clientX;\n      this._lastY = (touch || evt).clientY;\n\n      dragEl.style[\"will-change\"] = \"all\";\n\n      dragStartFn = function () {\n        pluginEvent(\"delayEnded\", _this, { evt });\n        //@ts-ignore\n        if (Sortable.eventCanceled) {\n          _this._onDrop();\n          return;\n        }\n        // Delayed drag has been triggered\n        // we can re-enable the events: touchmove/mousemove\n        _this._disableDelayedDragEvents();\n\n        if (!FireFox && _this.nativeDraggable) {\n          dragEl.draggable = true;\n        }\n\n        // Bind the events: dragstart/dragend\n        _this._triggerDragStart(evt, touch);\n\n        // Drag start event\n        _dispatchEvent({\n          sortable: _this,\n          name: \"choose\",\n          originalEvent: evt,\n        });\n\n        // Chosen item\n        toggleClass(dragEl, options.chosenClass, true);\n      };\n\n      // Disable \"draggable\"\n      options.ignore.split(\",\").forEach(function (criteria) {\n        find(dragEl, criteria.trim(), _disableDraggable);\n      });\n\n      on(ownerDocument, \"dragover\", nearestEmptyInsertDetectEvent);\n      on(ownerDocument, \"mousemove\", nearestEmptyInsertDetectEvent);\n      on(ownerDocument, \"touchmove\", nearestEmptyInsertDetectEvent);\n\n      on(ownerDocument, \"mouseup\", _this._onDrop);\n      on(ownerDocument, \"touchend\", _this._onDrop);\n      on(ownerDocument, \"touchcancel\", _this._onDrop);\n\n      // Make dragEl draggable (must be before delay for FireFox)\n      if (FireFox && this.nativeDraggable) {\n        this.options.touchStartThreshold = 4;\n        dragEl.draggable = true;\n      }\n\n      pluginEvent(\"delayStart\", this, { evt });\n\n      // Delay is impossible for native DnD in Edge or IE\n      if (\n        options.delay &&\n        (!options.delayOnTouchOnly || touch) &&\n        (!this.nativeDraggable || !(Edge || IE11OrLess))\n      ) {\n        //@ts-ignore\n        if (Sortable.eventCanceled) {\n          this._onDrop();\n          return;\n        }\n        // If the user moves the pointer or let go the click or touch\n        // before the delay has been reached:\n        // disable the delayed drag\n        on(ownerDocument, \"mouseup\", _this._disableDelayedDrag);\n        on(ownerDocument, \"touchend\", _this._disableDelayedDrag);\n        on(ownerDocument, \"touchcancel\", _this._disableDelayedDrag);\n        on(ownerDocument, \"mousemove\", _this._delayedDragTouchMoveHandler);\n        on(ownerDocument, \"touchmove\", _this._delayedDragTouchMoveHandler);\n        options.supportPointer &&\n          on(ownerDocument, \"pointermove\", _this._delayedDragTouchMoveHandler);\n\n        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);\n      } else {\n        dragStartFn();\n      }\n    }\n  },\n\n  _delayedDragTouchMoveHandler: function (/** TouchEvent|PointerEvent **/ e) {\n    let touch = e.touches ? e.touches[0] : e;\n    if (\n      Math.max(\n        Math.abs(touch.clientX - this._lastX),\n        Math.abs(touch.clientY - this._lastY)\n      ) >=\n      Math.floor(\n        this.options.touchStartThreshold /\n          ((this.nativeDraggable && window.devicePixelRatio) || 1)\n      )\n    ) {\n      this._disableDelayedDrag();\n    }\n  },\n\n  _disableDelayedDrag: function () {\n    dragEl && _disableDraggable(dragEl);\n    clearTimeout(this._dragStartTimer);\n\n    this._disableDelayedDragEvents();\n  },\n\n  _disableDelayedDragEvents: function () {\n    let ownerDocument = this.el.ownerDocument;\n    off(ownerDocument, \"mouseup\", this._disableDelayedDrag);\n    off(ownerDocument, \"touchend\", this._disableDelayedDrag);\n    off(ownerDocument, \"touchcancel\", this._disableDelayedDrag);\n    off(ownerDocument, \"mousemove\", this._delayedDragTouchMoveHandler);\n    off(ownerDocument, \"touchmove\", this._delayedDragTouchMoveHandler);\n    off(ownerDocument, \"pointermove\", this._delayedDragTouchMoveHandler);\n  },\n\n  _triggerDragStart: function (/** Event */ evt, /** Touch */ touch) {\n    touch = touch || (evt.pointerType == \"touch\" && evt);\n\n    if (!this.nativeDraggable || touch) {\n      if (this.options.supportPointer) {\n        on(document, \"pointermove\", this._onTouchMove);\n      } else if (touch) {\n        on(document, \"touchmove\", this._onTouchMove);\n      } else {\n        on(document, \"mousemove\", this._onTouchMove);\n      }\n    } else {\n      on(dragEl, \"dragend\", this);\n      on(rootEl, \"dragstart\", this._onDragStart);\n    }\n\n    try {\n      //@ts-ignore\n      if (document.selection) {\n        // Timeout neccessary for IE9\n        _nextTick(function () {\n          //@ts-ignore\n          document.selection.empty();\n        });\n      } else {\n        window.getSelection().removeAllRanges();\n      }\n    } catch (err) {}\n  },\n\n  _dragStarted: function (fallback, evt) {\n    let _this = this;\n    awaitingDragStarted = false;\n    if (rootEl && dragEl) {\n      pluginEvent(\"dragStarted\", this, { evt });\n\n      if (this.nativeDraggable) {\n        on(document, \"dragover\", _checkOutsideTargetEl);\n      }\n      let options = this.options;\n\n      // Apply effect\n      !fallback && toggleClass(dragEl, options.dragClass, false);\n      toggleClass(dragEl, options.ghostClass, true);\n\n      //@ts-ignore\n      Sortable.active = this;\n\n      fallback && this._appendGhost();\n\n      // Drag start event\n      _dispatchEvent({\n        sortable: this,\n        name: \"start\",\n        originalEvent: evt,\n      });\n    } else {\n      this._nulling();\n    }\n  },\n\n  _emulateDragOver: function () {\n    if (touchEvt) {\n      this._lastX = touchEvt.clientX;\n      this._lastY = touchEvt.clientY;\n\n      _hideGhostForTarget();\n\n      let target = document.elementFromPoint(\n        touchEvt.clientX,\n        touchEvt.clientY\n      );\n      let parent = target;\n\n      while (target && target.shadowRoot) {\n        target = target.shadowRoot.elementFromPoint(\n          touchEvt.clientX,\n          touchEvt.clientY\n        );\n        if (target === parent) break;\n        parent = target;\n      }\n\n      dragEl.parentNode[expando]._isOutsideThisEl(target);\n\n      if (parent) {\n        do {\n          if (parent[expando]) {\n            let inserted;\n\n            inserted = parent[expando]._onDragOver({\n              clientX: touchEvt.clientX,\n              clientY: touchEvt.clientY,\n              target: target,\n              rootEl: parent,\n            });\n\n            if (inserted && !this.options.dragoverBubble) {\n              break;\n            }\n          }\n\n          target = parent; // store last element\n        } while (\n          /* jshint boss:true */\n          //@ts-ignore\n          (parent = parent.parentNode)\n        );\n      }\n\n      _unhideGhostForTarget();\n    }\n  },\n\n  _onTouchMove: function (/**TouchEvent*/ evt) {\n    if (tapEvt) {\n      let options = this.options,\n        fallbackTolerance = options.fallbackTolerance,\n        fallbackOffset = options.fallbackOffset,\n        touch = evt.touches ? evt.touches[0] : evt,\n        ghostMatrix = ghostEl && matrix(ghostEl, true),\n        scaleX = ghostEl && ghostMatrix && ghostMatrix.a,\n        scaleY = ghostEl && ghostMatrix && ghostMatrix.d,\n        relativeScrollOffset =\n          PositionGhostAbsolutely &&\n          ghostRelativeParent &&\n          getRelativeScrollOffset(ghostRelativeParent),\n        dx =\n          (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) +\n          (relativeScrollOffset\n            ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0]\n            : 0) /\n            (scaleX || 1),\n        dy =\n          (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) +\n          (relativeScrollOffset\n            ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1]\n            : 0) /\n            (scaleY || 1);\n\n      // only set the status to dragging, when we are actually dragging\n      //@ts-ignore\n      if (!Sortable.active && !awaitingDragStarted) {\n        if (\n          fallbackTolerance &&\n          Math.max(\n            Math.abs(touch.clientX - this._lastX),\n            Math.abs(touch.clientY - this._lastY)\n          ) < fallbackTolerance\n        ) {\n          return;\n        }\n        this._onDragStart(evt, true);\n      }\n\n      if (ghostEl) {\n        if (ghostMatrix) {\n          ghostMatrix.e += dx - (lastDx || 0);\n          ghostMatrix.f += dy - (lastDy || 0);\n        } else {\n          ghostMatrix = {\n            a: 1,\n            b: 0,\n            c: 0,\n            d: 1,\n            e: dx,\n            f: dy,\n          };\n        }\n\n        let cssMatrix = `matrix(${ghostMatrix.a},${ghostMatrix.b},${ghostMatrix.c},${ghostMatrix.d},${ghostMatrix.e},${ghostMatrix.f})`;\n\n        css(ghostEl, \"webkitTransform\", cssMatrix);\n        css(ghostEl, \"mozTransform\", cssMatrix);\n        css(ghostEl, \"msTransform\", cssMatrix);\n        css(ghostEl, \"transform\", cssMatrix);\n\n        lastDx = dx;\n        lastDy = dy;\n\n        touchEvt = touch;\n      }\n\n      evt.cancelable && evt.preventDefault();\n    }\n  },\n\n  _appendGhost: function () {\n    // Bug if using scale(): https://stackoverflow.com/questions/2637058\n    // Not being adjusted for\n    if (!ghostEl) {\n      let container = this.options.fallbackOnBody ? document.body : rootEl,\n        rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container),\n        options = this.options;\n\n      // Position absolutely\n      if (PositionGhostAbsolutely) {\n        // Get relatively positioned parent\n        ghostRelativeParent = container;\n\n        while (\n          //@ts-ignore\n          css(ghostRelativeParent, \"position\") === \"static\" &&\n          //@ts-ignore\n          css(ghostRelativeParent, \"transform\") === \"none\" &&\n          ghostRelativeParent !== document\n        ) {\n          ghostRelativeParent = ghostRelativeParent.parentNode;\n        }\n\n        if (\n          ghostRelativeParent !== document.body &&\n          ghostRelativeParent !== document.documentElement\n        ) {\n          if (ghostRelativeParent === document)\n            ghostRelativeParent = getWindowScrollingElement();\n\n          rect.top += ghostRelativeParent.scrollTop;\n          rect.left += ghostRelativeParent.scrollLeft;\n        } else {\n          ghostRelativeParent = getWindowScrollingElement();\n        }\n        ghostRelativeParentInitialScroll = getRelativeScrollOffset(\n          ghostRelativeParent\n        );\n      }\n\n      ghostEl = dragEl.cloneNode(true);\n\n      toggleClass(ghostEl, options.ghostClass, false);\n      toggleClass(ghostEl, options.fallbackClass, true);\n      toggleClass(ghostEl, options.dragClass, true);\n\n      css(ghostEl, \"transition\", \"\");\n      css(ghostEl, \"transform\", \"\");\n\n      css(ghostEl, \"box-sizing\", \"border-box\");\n      css(ghostEl, \"margin\", 0);\n      css(ghostEl, \"top\", rect.top);\n      css(ghostEl, \"left\", rect.left);\n      css(ghostEl, \"width\", rect.width);\n      css(ghostEl, \"height\", rect.height);\n      css(ghostEl, \"opacity\", \"0.8\");\n      css(ghostEl, \"position\", PositionGhostAbsolutely ? \"absolute\" : \"fixed\");\n      css(ghostEl, \"zIndex\", \"100000\");\n      css(ghostEl, \"pointerEvents\", \"none\");\n\n      //@ts-ignore\n      Sortable.ghost = ghostEl;\n\n      container.appendChild(ghostEl);\n\n      // Set transform-origin\n      css(\n        ghostEl,\n        \"transform-origin\",\n        (tapDistanceLeft / parseInt(ghostEl.style.width)) * 100 +\n          \"% \" +\n          (tapDistanceTop / parseInt(ghostEl.style.height)) * 100 +\n          \"%\"\n      );\n    }\n  },\n\n  _onDragStart: function (/**Event*/ evt, /**boolean*/ fallback) {\n    let _this = this;\n    let dataTransfer = evt.dataTransfer;\n    let options = _this.options;\n\n    pluginEvent(\"dragStart\", this, { evt });\n    //@ts-ignore\n    if (Sortable.eventCanceled) {\n      this._onDrop();\n      return;\n    }\n\n    pluginEvent(\"setupClone\", this);\n    //@ts-ignore\n    if (!Sortable.eventCanceled) {\n      cloneEl = clone(dragEl);\n\n      cloneEl.draggable = false;\n      cloneEl.style[\"will-change\"] = \"\";\n\n      this._hideClone();\n\n      toggleClass(cloneEl, this.options.chosenClass, false);\n      //@ts-ignore\n      Sortable.clone = cloneEl;\n    }\n\n    // #1143: IFrame support workaround\n    _this.cloneId = _nextTick(function () {\n      pluginEvent(\"clone\", _this);\n      //@ts-ignore\n      if (Sortable.eventCanceled) return;\n\n      if (!_this.options.removeCloneOnHide) {\n        rootEl.insertBefore(cloneEl, dragEl);\n      }\n      _this._hideClone();\n\n      _dispatchEvent({\n        sortable: _this,\n        name: \"clone\",\n      });\n    });\n\n    !fallback && toggleClass(dragEl, options.dragClass, true);\n\n    // Set proper drop events\n    if (fallback) {\n      ignoreNextClick = true;\n      _this._loopId = setInterval(_this._emulateDragOver, 50);\n    } else {\n      // Undo what was set in _prepareDragStart before drag started\n      off(document, \"mouseup\", _this._onDrop);\n      off(document, \"touchend\", _this._onDrop);\n      off(document, \"touchcancel\", _this._onDrop);\n\n      if (dataTransfer) {\n        dataTransfer.effectAllowed = \"move\";\n        options.setData && options.setData.call(_this, dataTransfer, dragEl);\n      }\n\n      on(document, \"drop\", _this);\n\n      // #1276 fix:\n      css(dragEl, \"transform\", \"translateZ(0)\");\n    }\n\n    awaitingDragStarted = true;\n\n    _this._dragStartId = _nextTick(\n      _this._dragStarted.bind(_this, fallback, evt)\n    );\n    on(document, \"selectstart\", _this);\n\n    moved = true;\n\n    if (Safari) {\n      css(document.body, \"user-select\", \"none\");\n    }\n  },\n\n  // Returns true - if no further action is needed (either inserted or another condition)\n  _onDragOver: function (/**Event*/ evt) {\n    let el = this.el,\n      target = evt.target,\n      dragRect,\n      targetRect,\n      revert,\n      options = this.options,\n      group = options.group,\n      //@ts-ignore\n      activeSortable = Sortable.active,\n      isOwner = activeGroup === group,\n      canSort = options.sort,\n      fromSortable = putSortable || activeSortable,\n      vertical,\n      _this = this,\n      completedFired = false;\n\n    if (_silent) return;\n\n    function dragOverEvent(name, extra) {\n      pluginEvent(name, _this, {\n        evt,\n        isOwner,\n        axis: vertical ? \"vertical\" : \"horizontal\",\n        revert,\n        dragRect,\n        targetRect,\n        canSort,\n        fromSortable,\n        target,\n        completed,\n        onMove(target, after) {\n          return onMove(\n            rootEl,\n            el,\n            dragEl,\n            dragRect,\n            target,\n            //@ts-ignore\n            getRect(target),\n            evt,\n            after\n          );\n        },\n        changed,\n        ...extra,\n      });\n    }\n\n    // Capture animation state\n    function capture() {\n      //@ts-ignore\n      dragOverEvent(\"dragOverAnimationCapture\");\n\n      _this.captureAnimationState();\n      if (_this !== fromSortable) {\n        fromSortable.captureAnimationState();\n      }\n    }\n\n    // Return invocation when dragEl is inserted (or completed)\n    function completed(insertion) {\n      dragOverEvent(\"dragOverCompleted\", { insertion });\n\n      if (insertion) {\n        // Clones must be hidden before folding animation to capture dragRectAbsolute properly\n        if (isOwner) {\n          activeSortable._hideClone();\n        } else {\n          activeSortable._showClone(_this);\n        }\n\n        if (_this !== fromSortable) {\n          // Set ghost class to new sortable's ghost class\n          toggleClass(\n            dragEl,\n            putSortable\n              ? putSortable.options.ghostClass\n              : activeSortable.options.ghostClass,\n            false\n          );\n          toggleClass(dragEl, options.ghostClass, true);\n        }\n\n        //@ts-ignore\n        if (putSortable !== _this && _this !== Sortable.active) {\n          putSortable = _this;\n          //@ts-ignore\n        } else if (_this === Sortable.active && putSortable) {\n          putSortable = null;\n        }\n\n        // Animation\n        if (fromSortable === _this) {\n          _this._ignoreWhileAnimating = target;\n        }\n        _this.animateAll(function () {\n          //@ts-ignore\n          dragOverEvent(\"dragOverAnimationComplete\");\n          _this._ignoreWhileAnimating = null;\n        });\n        if (_this !== fromSortable) {\n          fromSortable.animateAll();\n          fromSortable._ignoreWhileAnimating = null;\n        }\n      }\n\n      // Null lastTarget if it is not inside a previously swapped element\n      if (\n        (target === dragEl && !dragEl.animated) ||\n        (target === el && !target.animated)\n      ) {\n        lastTarget = null;\n      }\n\n      // no bubbling and not fallback\n      if (!options.dragoverBubble && !evt.rootEl && target !== document) {\n        dragEl.parentNode[expando]._isOutsideThisEl(evt.target);\n\n        // Do not detect for empty insert if already inserted\n        !insertion && nearestEmptyInsertDetectEvent(evt);\n      }\n\n      !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();\n\n      return (completedFired = true);\n    }\n\n    // Call when dragEl has been inserted\n    function changed() {\n      //@ts-ignore\n      newIndex = index(dragEl);\n      newDraggableIndex = index(dragEl, options.draggable);\n      _dispatchEvent({\n        sortable: _this,\n        name: \"change\",\n        toEl: el,\n        newIndex,\n        newDraggableIndex,\n        originalEvent: evt,\n      });\n    }\n\n    if (evt.preventDefault !== void 0) {\n      evt.cancelable && evt.preventDefault();\n    }\n\n    target = closest(target, options.draggable, el, true);\n\n    //@ts-ignore\n    dragOverEvent(\"dragOver\");\n    //@ts-ignore\n    if (Sortable.eventCanceled) return completedFired;\n\n    if (\n      dragEl.contains(evt.target) ||\n      (target.animated && target.animatingX && target.animatingY) ||\n      _this._ignoreWhileAnimating === target\n    ) {\n      return completed(false);\n    }\n\n    ignoreNextClick = false;\n\n    if (\n      activeSortable &&\n      !options.disabled &&\n      (isOwner\n        ? canSort || (revert = !rootEl.contains(dragEl)) // Reverting item into the original list\n        : putSortable === this ||\n          ((this.lastPutMode = activeGroup.checkPull(\n            this,\n            activeSortable,\n            dragEl,\n            evt\n          )) &&\n            group.checkPut(this, activeSortable, dragEl, evt)))\n    ) {\n      vertical = this._getDirection(evt, target) === \"vertical\";\n\n      //@ts-ignore\n      dragRect = getRect(dragEl);\n\n      //@ts-ignore\n      dragOverEvent(\"dragOverValid\");\n      //@ts-ignore\n      if (Sortable.eventCanceled) return completedFired;\n\n      if (revert) {\n        parentEl = rootEl; // actualization\n        capture();\n\n        this._hideClone();\n\n        //@ts-ignore\n        dragOverEvent(\"revert\");\n\n        //@ts-ignore\n        if (!Sortable.eventCanceled) {\n          if (nextEl) {\n            rootEl.insertBefore(dragEl, nextEl);\n          } else {\n            rootEl.appendChild(dragEl);\n          }\n        }\n\n        return completed(true);\n      }\n\n      let elLastChild = lastChild(el, options.draggable);\n\n      if (\n        !elLastChild ||\n        (_ghostIsLast(evt, vertical, this) && !elLastChild.animated)\n      ) {\n        // If already at end of list: Do not insert\n        if (elLastChild === dragEl) {\n          return completed(false);\n        }\n\n        // assign target only if condition is true\n        if (elLastChild && el === evt.target) {\n          target = elLastChild;\n        }\n\n        if (target) {\n          //@ts-ignore\n          targetRect = getRect(target);\n        }\n\n        if (\n          onMove(\n            rootEl,\n            el,\n            dragEl,\n            dragRect,\n            target,\n            targetRect,\n            evt,\n            !!target\n          ) !== false\n        ) {\n          capture();\n          el.appendChild(dragEl);\n          parentEl = el; // actualization\n\n          changed();\n          return completed(true);\n        }\n      } else if (target.parentNode === el) {\n        //@ts-ignore\n        targetRect = getRect(target);\n        let direction = 0,\n          targetBeforeFirstSwap,\n          differentLevel = dragEl.parentNode !== el,\n          differentRowCol = !_dragElInRowColumn(\n            (dragEl.animated && dragEl.toRect) || dragRect,\n            (target.animated && target.toRect) || targetRect,\n            vertical\n          ),\n          side1 = vertical ? \"top\" : \"left\",\n          scrolledPastTop =\n            isScrolledPast(target, \"top\", \"top\") ||\n            isScrolledPast(dragEl, \"top\", \"top\"),\n          scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;\n\n        if (lastTarget !== target) {\n          targetBeforeFirstSwap = targetRect[side1];\n          pastFirstInvertThresh = false;\n          isCircumstantialInvert =\n            (!differentRowCol && options.invertSwap) || differentLevel;\n        }\n\n        direction = _getSwapDirection(\n          evt,\n          target,\n          targetRect,\n          vertical,\n          differentRowCol ? 1 : options.swapThreshold,\n          options.invertedSwapThreshold == null\n            ? options.swapThreshold\n            : options.invertedSwapThreshold,\n          isCircumstantialInvert,\n          lastTarget === target\n        );\n\n        let sibling;\n\n        if (direction !== 0) {\n          // Check if target is beside dragEl in respective direction (ignoring hidden elements)\n          //@ts-ignore\n          let dragIndex = index(dragEl);\n\n          do {\n            dragIndex -= direction;\n            sibling = parentEl.children[dragIndex];\n          } while (\n            sibling &&\n            //@ts-ignore\n            (css(sibling, \"display\") === \"none\" || sibling === ghostEl)\n          );\n        }\n        // If dragEl is already beside target: Do not insert\n        if (direction === 0 || sibling === target) {\n          return completed(false);\n        }\n\n        lastTarget = target;\n\n        lastDirection = direction;\n\n        let nextSibling = target.nextElementSibling,\n          after = false;\n\n        after = direction === 1;\n\n        let moveVector = onMove(\n          rootEl,\n          el,\n          dragEl,\n          dragRect,\n          target,\n          targetRect,\n          evt,\n          after\n        );\n\n        if (moveVector !== false) {\n          if (moveVector === 1 || moveVector === -1) {\n            after = moveVector === 1;\n          }\n\n          _silent = true;\n          setTimeout(_unsilent, 30);\n\n          capture();\n\n          if (after && !nextSibling) {\n            el.appendChild(dragEl);\n          } else {\n            target.parentNode.insertBefore(\n              dragEl,\n              after ? nextSibling : target\n            );\n          }\n\n          // Undo chrome's scroll adjustment (has no effect on other browsers)\n          if (scrolledPastTop) {\n            scrollBy(\n              scrolledPastTop,\n              0,\n              scrollBefore - scrolledPastTop.scrollTop\n            );\n          }\n\n          parentEl = dragEl.parentNode; // actualization\n\n          // must be done before animation\n          if (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {\n            targetMoveDistance = Math.abs(\n              //@ts-ignore\n              targetBeforeFirstSwap - getRect(target)[side1]\n            );\n          }\n          changed();\n\n          return completed(true);\n        }\n      }\n\n      if (el.contains(dragEl)) {\n        return completed(false);\n      }\n    }\n\n    return false;\n  },\n\n  _ignoreWhileAnimating: null,\n\n  _offMoveEvents: function () {\n    off(document, \"mousemove\", this._onTouchMove);\n    off(document, \"touchmove\", this._onTouchMove);\n    off(document, \"pointermove\", this._onTouchMove);\n    off(document, \"dragover\", nearestEmptyInsertDetectEvent);\n    off(document, \"mousemove\", nearestEmptyInsertDetectEvent);\n    off(document, \"touchmove\", nearestEmptyInsertDetectEvent);\n  },\n\n  _offUpEvents: function () {\n    let ownerDocument = this.el.ownerDocument;\n\n    off(ownerDocument, \"mouseup\", this._onDrop);\n    off(ownerDocument, \"touchend\", this._onDrop);\n    off(ownerDocument, \"pointerup\", this._onDrop);\n    off(ownerDocument, \"touchcancel\", this._onDrop);\n    off(document, \"selectstart\", this);\n  },\n\n  _onDrop: function (/**Event*/ evt) {\n    let el = this.el,\n      options = this.options;\n\n    // Get the index of the dragged element within its parent\n    //@ts-ignore\n    newIndex = index(dragEl);\n    newDraggableIndex = index(dragEl, options.draggable);\n\n    pluginEvent(\"drop\", this, {\n      evt,\n    });\n\n    parentEl = dragEl && dragEl.parentNode;\n\n    // Get again after plugin event\n    //@ts-ignore\n    newIndex = index(dragEl);\n    newDraggableIndex = index(dragEl, options.draggable);\n\n    //@ts-ignore\n    if (Sortable.eventCanceled) {\n      this._nulling();\n      return;\n    }\n\n    awaitingDragStarted = false;\n    isCircumstantialInvert = false;\n    pastFirstInvertThresh = false;\n\n    clearInterval(this._loopId);\n\n    clearTimeout(this._dragStartTimer);\n\n    _cancelNextTick(this.cloneId);\n    _cancelNextTick(this._dragStartId);\n\n    // Unbind events\n    if (this.nativeDraggable) {\n      off(document, \"drop\", this);\n      off(el, \"dragstart\", this._onDragStart);\n    }\n    this._offMoveEvents();\n    this._offUpEvents();\n\n    if (Safari) {\n      css(document.body, \"user-select\", \"\");\n    }\n\n    css(dragEl, \"transform\", \"\");\n\n    if (evt) {\n      if (moved) {\n        evt.cancelable && evt.preventDefault();\n        !options.dropBubble && evt.stopPropagation();\n      }\n\n      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);\n\n      if (\n        rootEl === parentEl ||\n        (putSortable && putSortable.lastPutMode !== \"clone\")\n      ) {\n        // Remove clone(s)\n        cloneEl &&\n          cloneEl.parentNode &&\n          cloneEl.parentNode.removeChild(cloneEl);\n      }\n\n      if (dragEl) {\n        if (this.nativeDraggable) {\n          off(dragEl, \"dragend\", this);\n        }\n\n        _disableDraggable(dragEl);\n        dragEl.style[\"will-change\"] = \"\";\n\n        // Remove classes\n        // ghostClass is added in dragStarted\n        if (moved && !awaitingDragStarted) {\n          toggleClass(\n            dragEl,\n            putSortable\n              ? putSortable.options.ghostClass\n              : this.options.ghostClass,\n            false\n          );\n        }\n        toggleClass(dragEl, this.options.chosenClass, false);\n\n        // Drag stop event\n        _dispatchEvent({\n          sortable: this,\n          name: \"unchoose\",\n          toEl: parentEl,\n          newIndex: null,\n          newDraggableIndex: null,\n          originalEvent: evt,\n        });\n\n        if (rootEl !== parentEl) {\n          if (newIndex >= 0) {\n            // Add event\n            _dispatchEvent({\n              rootEl: parentEl,\n              name: \"add\",\n              toEl: parentEl,\n              fromEl: rootEl,\n              originalEvent: evt,\n            });\n\n            // Remove event\n            _dispatchEvent({\n              sortable: this,\n              name: \"remove\",\n              toEl: parentEl,\n              originalEvent: evt,\n            });\n\n            // drag from one list and drop into another\n            _dispatchEvent({\n              rootEl: parentEl,\n              name: \"sort\",\n              toEl: parentEl,\n              fromEl: rootEl,\n              originalEvent: evt,\n            });\n\n            _dispatchEvent({\n              sortable: this,\n              name: \"sort\",\n              toEl: parentEl,\n              originalEvent: evt,\n            });\n          }\n\n          putSortable && putSortable.save();\n        } else {\n          if (newIndex !== oldIndex) {\n            if (newIndex >= 0) {\n              // drag & drop within the same list\n              _dispatchEvent({\n                sortable: this,\n                name: \"update\",\n                toEl: parentEl,\n                originalEvent: evt,\n              });\n\n              _dispatchEvent({\n                sortable: this,\n                name: \"sort\",\n                toEl: parentEl,\n                originalEvent: evt,\n              });\n            }\n          }\n        }\n\n        //@ts-ignore\n        if (Sortable.active) {\n          /* jshint eqnull:true */\n          if (newIndex == null || newIndex === -1) {\n            newIndex = oldIndex;\n            newDraggableIndex = oldDraggableIndex;\n          }\n\n          _dispatchEvent({\n            sortable: this,\n            name: \"end\",\n            toEl: parentEl,\n            originalEvent: evt,\n          });\n\n          // Save sorting\n          this.save();\n        }\n      }\n    }\n    this._nulling();\n  },\n\n  _nulling: function () {\n    pluginEvent(\"nulling\", this);\n    //@ts-ignore\n    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;\n\n    savedInputChecked.forEach(function (el) {\n      el.checked = true;\n    });\n\n    savedInputChecked.length = lastDx = lastDy = 0;\n  },\n\n  handleEvent: function (/**Event*/ evt) {\n    switch (evt.type) {\n      case \"drop\":\n      case \"dragend\":\n        this._onDrop(evt);\n        break;\n\n      case \"dragenter\":\n      case \"dragover\":\n        if (dragEl) {\n          this._onDragOver(evt);\n          _globalDragOver(evt);\n        }\n        break;\n\n      case \"selectstart\":\n        evt.preventDefault();\n        break;\n    }\n  },\n\n  /**\n   * Serializes the item into an array of string.\n   * @returns {String[]}\n   */\n  toArray: function () {\n    let order = [],\n      el,\n      children = this.el.children,\n      i = 0,\n      n = children.length,\n      options = this.options;\n\n    for (; i < n; i++) {\n      el = children[i];\n      if (closest(el, options.draggable, this.el, false)) {\n        order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));\n      }\n    }\n\n    return order;\n  },\n\n  /**\n   * Sorts the elements according to the array.\n   * @param  {String[]}  order  order of the items\n   */\n  sort: function (order) {\n    let items = {},\n      rootEl = this.el;\n\n    this.toArray().forEach(function (id, i) {\n      let el = rootEl.children[i];\n\n      if (closest(el, this.options.draggable, rootEl, false)) {\n        items[id] = el;\n      }\n    }, this);\n\n    order.forEach(function (id) {\n      if (items[id]) {\n        rootEl.removeChild(items[id]);\n        rootEl.appendChild(items[id]);\n      }\n    });\n  },\n\n  /**\n   * Save the current sorting\n   */\n  save: function () {\n    let store = this.options.store;\n    store && store.set && store.set(this);\n  },\n\n  /**\n   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.\n   * @param   {HTMLElement}  el\n   * @param   {String}       [selector]  default: `options.draggable`\n   * @returns {HTMLElement|null}\n   */\n  closest: function (el, selector) {\n    return closest(el, selector || this.options.draggable, this.el, false);\n  },\n\n  /**\n   * Set/get option\n   * @param   {string} name\n   * @param   {*}      [value]\n   * @returns {*}\n   */\n  option: function (name, value) {\n    let options = this.options;\n\n    if (value === void 0) {\n      return options[name];\n    } else {\n      let modifiedValue = PluginManager.modifyOption(this, name, value);\n      if (typeof modifiedValue !== \"undefined\") {\n        options[name] = modifiedValue;\n      } else {\n        options[name] = value;\n      }\n\n      if (name === \"group\") {\n        _prepareGroup(options);\n      }\n    }\n  },\n\n  /**\n   * Destroy\n   */\n  destroy: function () {\n    pluginEvent(\"destroy\", this);\n    let el = this.el;\n\n    el[expando] = null;\n\n    off(el, \"mousedown\", this._onTapStart);\n    off(el, \"touchstart\", this._onTapStart);\n    off(el, \"pointerdown\", this._onTapStart);\n\n    if (this.nativeDraggable) {\n      off(el, \"dragover\", this);\n      off(el, \"dragenter\", this);\n    }\n    // Remove draggable attributes\n    Array.prototype.forEach.call(el.querySelectorAll(\"[draggable]\"), function (\n      el\n    ) {\n      el.removeAttribute(\"draggable\");\n    });\n\n    this._onDrop();\n\n    this._disableDelayedDragEvents();\n\n    sortables.splice(sortables.indexOf(this.el), 1);\n\n    this.el = el = null;\n  },\n\n  _hideClone: function () {\n    if (!cloneHidden) {\n      pluginEvent(\"hideClone\", this);\n      //@ts-ignore\n      if (Sortable.eventCanceled) return;\n\n      css(cloneEl, \"display\", \"none\");\n      if (this.options.removeCloneOnHide && cloneEl.parentNode) {\n        cloneEl.parentNode.removeChild(cloneEl);\n      }\n      cloneHidden = true;\n    }\n  },\n\n  _showClone: function (putSortable) {\n    if (putSortable.lastPutMode !== \"clone\") {\n      this._hideClone();\n      return;\n    }\n\n    if (cloneHidden) {\n      pluginEvent(\"showClone\", this);\n      //@ts-ignore\n      if (Sortable.eventCanceled) return;\n\n      // show clone at dragEl or original position\n      if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {\n        rootEl.insertBefore(cloneEl, dragEl);\n      } else if (nextEl) {\n        rootEl.insertBefore(cloneEl, nextEl);\n      } else {\n        rootEl.appendChild(cloneEl);\n      }\n\n      if (this.options.group.revertClone) {\n        this.animate(dragEl, cloneEl);\n      }\n\n      css(cloneEl, \"display\", \"\");\n      cloneHidden = false;\n    }\n  },\n};\n\nfunction _globalDragOver(/**Event*/ evt) {\n  if (evt.dataTransfer) {\n    evt.dataTransfer.dropEffect = \"move\";\n  }\n  evt.cancelable && evt.preventDefault();\n}\n\nfunction onMove(\n  fromEl,\n  toEl,\n  dragEl,\n  dragRect,\n  targetEl,\n  targetRect,\n  originalEvent,\n  willInsertAfter\n) {\n  let evt,\n    sortable = fromEl[expando],\n    onMoveFn = sortable.options.onMove,\n    retVal;\n  // Support for new CustomEvent feature\n  if (window.CustomEvent && !IE11OrLess && !Edge) {\n    evt = new CustomEvent(\"move\", {\n      bubbles: true,\n      cancelable: true,\n    });\n  } else {\n    evt = document.createEvent(\"Event\");\n    evt.initEvent(\"move\", true, true);\n  }\n\n  evt.to = toEl;\n  evt.from = fromEl;\n  evt.dragged = dragEl;\n  evt.draggedRect = dragRect;\n  evt.related = targetEl || toEl;\n  //@ts-ignore\n  evt.relatedRect = targetRect || getRect(toEl);\n  evt.willInsertAfter = willInsertAfter;\n\n  evt.originalEvent = originalEvent;\n\n  fromEl.dispatchEvent(evt);\n\n  if (onMoveFn) {\n    retVal = onMoveFn.call(sortable, evt, originalEvent);\n  }\n\n  return retVal;\n}\n\nfunction _disableDraggable(el) {\n  el.draggable = false;\n}\n\nfunction _unsilent() {\n  _silent = false;\n}\n\nfunction _ghostIsLast(evt, vertical, sortable) {\n  //@ts-ignore\n  let rect = getRect(lastChild(sortable.el, sortable.options.draggable));\n  const spacer = 10;\n\n  return vertical\n    ? evt.clientX > rect.right + spacer ||\n        (evt.clientX <= rect.right &&\n          evt.clientY > rect.bottom &&\n          evt.clientX >= rect.left)\n    : (evt.clientX > rect.right && evt.clientY > rect.top) ||\n        (evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer);\n}\n\nfunction _getSwapDirection(\n  evt,\n  target,\n  targetRect,\n  vertical,\n  swapThreshold,\n  invertedSwapThreshold,\n  invertSwap,\n  isLastTarget\n) {\n  let mouseOnAxis = vertical ? evt.clientY : evt.clientX,\n    targetLength = vertical ? targetRect.height : targetRect.width,\n    targetS1 = vertical ? targetRect.top : targetRect.left,\n    targetS2 = vertical ? targetRect.bottom : targetRect.right,\n    invert = false;\n\n  if (!invertSwap) {\n    // Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold\n    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {\n      // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2\n      // check if past first invert threshold on side opposite of lastDirection\n      if (\n        !pastFirstInvertThresh &&\n        (lastDirection === 1\n          ? mouseOnAxis > targetS1 + (targetLength * invertedSwapThreshold) / 2\n          : mouseOnAxis < targetS2 - (targetLength * invertedSwapThreshold) / 2)\n      ) {\n        // past first invert threshold, do not restrict inverted threshold to dragEl shadow\n        pastFirstInvertThresh = true;\n      }\n\n      if (!pastFirstInvertThresh) {\n        // dragEl shadow (target move distance shadow)\n        if (\n          lastDirection === 1\n            ? mouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow\n            : mouseOnAxis > targetS2 - targetMoveDistance\n        ) {\n          return -lastDirection;\n        }\n      } else {\n        invert = true;\n      }\n    } else {\n      // Regular\n      if (\n        mouseOnAxis > targetS1 + (targetLength * (1 - swapThreshold)) / 2 &&\n        mouseOnAxis < targetS2 - (targetLength * (1 - swapThreshold)) / 2\n      ) {\n        return _getInsertDirection(target);\n      }\n    }\n  }\n\n  invert = invert || invertSwap;\n\n  if (invert) {\n    // Invert of regular\n    if (\n      mouseOnAxis < targetS1 + (targetLength * invertedSwapThreshold) / 2 ||\n      mouseOnAxis > targetS2 - (targetLength * invertedSwapThreshold) / 2\n    ) {\n      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;\n    }\n  }\n\n  return 0;\n}\n\n/**\n * Gets the direction dragEl must be swapped relative to target in order to make it\n * seem that dragEl has been \"inserted\" into that element's position\n * @param  {HTMLElement} target       The target whose position dragEl is being inserted at\n * @return {Number}                   Direction dragEl must be swapped\n */\nfunction _getInsertDirection(target) {\n  //@ts-ignore\n  if (index(dragEl) < index(target)) {\n    return 1;\n  } else {\n    return -1;\n  }\n}\n\n/**\n * Generate id\n * @param   {HTMLElement} el\n * @returns {String}\n * @private\n */\nfunction _generateId(el) {\n  let str = el.tagName + el.className + el.src + el.href + el.textContent,\n    i = str.length,\n    sum = 0;\n\n  while (i--) {\n    sum += str.charCodeAt(i);\n  }\n\n  return sum.toString(36);\n}\n\nfunction _saveInputCheckedState(root) {\n  savedInputChecked.length = 0;\n\n  let inputs = root.getElementsByTagName(\"input\");\n  let idx = inputs.length;\n\n  while (idx--) {\n    let el = inputs[idx];\n    el.checked && savedInputChecked.push(el);\n  }\n}\n\nfunction _nextTick(fn) {\n  return setTimeout(fn, 0);\n}\n\nfunction _cancelNextTick(id) {\n  return clearTimeout(id);\n}\n\n// Fixed #973:\nif (documentExists) {\n  on(document, \"touchmove\", function (evt) {\n    //@ts-ignore\n    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {\n      evt.preventDefault();\n    }\n  });\n}\n\n// Export utils\nSortable.utils = {\n  on: on,\n  off: off,\n  css: css,\n  find: find,\n  is: function (el, selector) {\n    return !!closest(el, selector, el, false);\n  },\n  extend: extend,\n  throttle: throttle,\n  closest: closest,\n  toggleClass: toggleClass,\n  clone: clone,\n  index: index,\n  nextTick: _nextTick,\n  cancelNextTick: _cancelNextTick,\n  detectDirection: _detectDirection,\n  getChild: getChild,\n};\n\n/**\n * Get the Sortable instance of an element\n * @param  {HTMLElement} element The element\n * @return {Sortable|undefined}         The instance of Sortable\n */\nSortable.get = function (element) {\n  return element[expando];\n};\n\n/**\n * Mount a plugin to Sortable\n * @param  {...SortablePlugin|SortablePlugin[]} plugins       Plugins being mounted\n */\nSortable.mount = function (...plugins) {\n  if (plugins[0].constructor === Array) plugins = plugins[0];\n\n  plugins.forEach((plugin) => {\n    if (!plugin.prototype || !plugin.prototype.constructor) {\n      throw `Sortable: Mounted plugin must be a constructor function, not ${{}.toString.call(\n        plugin\n      )}`;\n    }\n    if (plugin.utils) Sortable.utils = { ...Sortable.utils, ...plugin.utils };\n\n    PluginManager.mount(plugin);\n  });\n};\n\n/**\n * Create sortable instance\n * @param {HTMLElement}  el\n * @param {Object}      [options]\n */\nSortable.create = function (el, options) {\n  return new Sortable(el, options);\n};\n\n// Export\nSortable.version = version;\n\nexport default Sortable;\n","import { toggleClass, index } from \"../../../utils/src\";\n\nlet lastSwapEl;\n\nfunction SwapPlugin() {\n  function Swap() {\n    this.defaults = {\n      swapClass: \"sortable-swap-highlight\",\n    };\n  }\n\n  Swap.prototype = {\n    dragStart({ dragEl }) {\n      lastSwapEl = dragEl;\n    },\n    dragOverValid({\n      completed,\n      target,\n      onMove,\n      activeSortable,\n      changed,\n      cancel,\n    }) {\n      if (!activeSortable.options.swap) return;\n      let el = this.sortable.el,\n        options = this.options;\n      if (target && target !== el) {\n        let prevSwapEl = lastSwapEl;\n        if (onMove(target) !== false) {\n          toggleClass(target, options.swapClass, true);\n          lastSwapEl = target;\n        } else {\n          lastSwapEl = null;\n        }\n\n        if (prevSwapEl && prevSwapEl !== lastSwapEl) {\n          toggleClass(prevSwapEl, options.swapClass, false);\n        }\n      }\n      changed();\n\n      completed(true);\n      cancel();\n    },\n    drop({ activeSortable, putSortable, dragEl }) {\n      let toSortable = putSortable || this.sortable;\n      let options = this.options;\n      lastSwapEl && toggleClass(lastSwapEl, options.swapClass, false);\n      if (\n        lastSwapEl &&\n        (options.swap || (putSortable && putSortable.options.swap))\n      ) {\n        if (dragEl !== lastSwapEl) {\n          toSortable.captureAnimationState();\n          if (toSortable !== activeSortable)\n            activeSortable.captureAnimationState();\n          swapNodes(dragEl, lastSwapEl);\n\n          toSortable.animateAll();\n          if (toSortable !== activeSortable) activeSortable.animateAll();\n        }\n      }\n    },\n    nulling() {\n      lastSwapEl = null;\n    },\n  };\n\n  return Object.assign(Swap, {\n    pluginName: \"swap\",\n    eventProperties() {\n      return {\n        swapItem: lastSwapEl,\n      };\n    },\n  });\n}\n\nfunction swapNodes(n1, n2) {\n  let p1 = n1.parentNode,\n    p2 = n2.parentNode,\n    i1,\n    i2;\n\n  if (!p1 || !p2 || p1.isEqualNode(n2) || p2.isEqualNode(n1)) return;\n\n  //@ts-ignore\n  i1 = index(n1);\n  //@ts-ignore\n  i2 = index(n2);\n\n  if (p1.isEqualNode(p2) && i1 < i2) {\n    i2++;\n  }\n  p1.insertBefore(n2, p1.children[i1]);\n  p2.insertBefore(n1, p2.children[i2]);\n}\n\nexport default SwapPlugin;\n","import {\n  getRect,\n  css,\n  matrix,\n  isRectEqual,\n  indexOfObject,\n} from \"../../utils/src\";\nimport * as Sortable from \"./Sortable\";\n\nexport default function AnimationStateManager() {\n  let animationStates = [],\n    animationCallbackId;\n\n  return {\n    captureAnimationState() {\n      animationStates = [];\n      if (!this.options.animation) return;\n      let children = [].slice.call(this.el.children);\n\n      children.forEach((child) => {\n        //@ts-ignore\n        if (css(child, \"display\") === \"none\" || child === Sortable.ghost)\n          return;\n        animationStates.push({\n          target: child,\n          //@ts-ignore\n          rect: getRect(child),\n        });\n        let fromRect = { ...animationStates[animationStates.length - 1].rect };\n\n        // If animating: compensate for current animation\n        if (child.thisAnimationDuration) {\n          let childMatrix = matrix(child, true);\n          if (childMatrix) {\n            fromRect.top -= childMatrix.f;\n            fromRect.left -= childMatrix.e;\n          }\n        }\n\n        child.fromRect = fromRect;\n      });\n    },\n\n    addAnimationState(state) {\n      animationStates.push(state);\n    },\n\n    removeAnimationState(target) {\n      animationStates.splice(indexOfObject(animationStates, { target }), 1);\n    },\n\n    animateAll(callback) {\n      if (!this.options.animation) {\n        clearTimeout(animationCallbackId);\n        if (typeof callback === \"function\") callback();\n        return;\n      }\n\n      let animating = false,\n        animationTime = 0;\n\n      animationStates.forEach((state) => {\n        let time = 0,\n          animatingThis = false,\n          target = state.target,\n          fromRect = target.fromRect,\n          //@ts-ignore\n          toRect = getRect(target),\n          prevFromRect = target.prevFromRect,\n          prevToRect = target.prevToRect,\n          animatingRect = state.rect,\n          targetMatrix = matrix(target, true);\n\n        if (targetMatrix) {\n          // Compensate for current animation\n          toRect.top -= targetMatrix.f;\n          toRect.left -= targetMatrix.e;\n        }\n\n        target.toRect = toRect;\n\n        if (target.thisAnimationDuration) {\n          // Could also check if animatingRect is between fromRect and toRect\n          if (\n            isRectEqual(prevFromRect, toRect) &&\n            !isRectEqual(fromRect, toRect) &&\n            // Make sure animatingRect is on line between toRect & fromRect\n            (animatingRect.top - toRect.top) /\n              (animatingRect.left - toRect.left) ===\n              (fromRect.top - toRect.top) / (fromRect.left - toRect.left)\n          ) {\n            // If returning to same place as started from animation and on same axis\n            time = calculateRealTime(\n              animatingRect,\n              prevFromRect,\n              prevToRect,\n              this.options\n            );\n          }\n        }\n\n        // if fromRect != toRect: animate\n        if (!isRectEqual(toRect, fromRect)) {\n          target.prevFromRect = fromRect;\n          target.prevToRect = toRect;\n\n          if (!time) {\n            time = this.options.animation;\n          }\n          this.animate(target, animatingRect, toRect, time);\n        }\n\n        if (time) {\n          animating = true;\n          animationTime = Math.max(animationTime, time);\n          clearTimeout(target.animationResetTimer);\n          target.animationResetTimer = setTimeout(function () {\n            target.animationTime = 0;\n            target.prevFromRect = null;\n            target.fromRect = null;\n            target.prevToRect = null;\n            target.thisAnimationDuration = null;\n          }, time);\n          target.thisAnimationDuration = time;\n        }\n      });\n\n      clearTimeout(animationCallbackId);\n      if (!animating) {\n        if (typeof callback === \"function\") callback();\n      } else {\n        animationCallbackId = setTimeout(function () {\n          if (typeof callback === \"function\") callback();\n        }, animationTime);\n      }\n      animationStates = [];\n    },\n\n    animate(target, currentRect, toRect, duration) {\n      if (duration) {\n        css(target, \"transition\", \"\");\n        css(target, \"transform\", \"\");\n        //@ts-ignore\n        let elMatrix = matrix(this.el),\n          scaleX = elMatrix && elMatrix.a,\n          scaleY = elMatrix && elMatrix.d,\n          translateX = (currentRect.left - toRect.left) / (scaleX || 1),\n          translateY = (currentRect.top - toRect.top) / (scaleY || 1);\n\n        target.animatingX = !!translateX;\n        target.animatingY = !!translateY;\n\n        css(\n          target,\n          \"transform\",\n          \"translate3d(\" + translateX + \"px,\" + translateY + \"px,0)\"\n        );\n\n        this.forRepaintDummy = repaint(target); // repaint\n\n        css(\n          target,\n          \"transition\",\n          \"transform \" +\n            duration +\n            \"ms\" +\n            (this.options.easing ? \" \" + this.options.easing : \"\")\n        );\n        css(target, \"transform\", \"translate3d(0,0,0)\");\n        typeof target.animated === \"number\" && clearTimeout(target.animated);\n        target.animated = setTimeout(function () {\n          css(target, \"transition\", \"\");\n          css(target, \"transform\", \"\");\n          target.animated = false;\n\n          target.animatingX = false;\n          target.animatingY = false;\n        }, duration);\n      }\n    },\n  };\n}\n\nfunction repaint(target) {\n  return target.offsetWidth;\n}\n\nfunction calculateRealTime(animatingRect, fromRect, toRect, options) {\n  return (\n    (Math.sqrt(\n      Math.pow(fromRect.top - animatingRect.top, 2) +\n        Math.pow(fromRect.left - animatingRect.left, 2)\n    ) /\n      Math.sqrt(\n        Math.pow(fromRect.top - toRect.top, 2) +\n          Math.pow(fromRect.left - toRect.left, 2)\n      )) *\n    options.animation\n  );\n}\n","import {\n  toggleClass,\n  getRect,\n  index,\n  closest,\n  on,\n  off,\n  clone,\n  css,\n  setRect,\n  unsetRect,\n  matrix,\n  expando,\n} from \"../../../utils/src\";\n\nimport dispatchEvent from \"../../../sortable/src/EventDispatcher\";\n\nlet multiDragElements = [],\n  multiDragClones = [],\n  lastMultiDragSelect, // for selection with modifier key down (SHIFT)\n  multiDragSortable,\n  initialFolding = false, // Initial multi-drag fold when drag started\n  folding = false, // Folding any other time\n  dragStarted = false,\n  dragEl,\n  clonesFromRect,\n  clonesHidden;\n\nfunction MultiDragPlugin() {\n  function MultiDrag(sortable) {\n    // Bind all private methods\n    for (let fn in this) {\n      if (fn.charAt(0) === \"_\" && typeof this[fn] === \"function\") {\n        this[fn] = this[fn].bind(this);\n      }\n    }\n\n    if (sortable.options.supportPointer) {\n      on(document, \"pointerup\", this._deselectMultiDrag);\n    } else {\n      on(document, \"mouseup\", this._deselectMultiDrag);\n      on(document, \"touchend\", this._deselectMultiDrag);\n    }\n\n    on(document, \"keydown\", this._checkKeyDown);\n    on(document, \"keyup\", this._checkKeyUp);\n\n    this.defaults = {\n      selectedClass: \"sortable-selected\",\n      multiDragKey: null,\n      setData(dataTransfer, dragEl) {\n        let data = \"\";\n        if (multiDragElements.length && multiDragSortable === sortable) {\n          multiDragElements.forEach((multiDragElement, i) => {\n            data += (!i ? \"\" : \", \") + multiDragElement.textContent;\n          });\n        } else {\n          data = dragEl.textContent;\n        }\n        dataTransfer.setData(\"Text\", data);\n      },\n    };\n  }\n\n  MultiDrag.prototype = {\n    multiDragKeyDown: false,\n    isMultiDrag: false,\n\n    delayStartGlobal({ dragEl: dragged }) {\n      dragEl = dragged;\n    },\n\n    delayEnded() {\n      this.isMultiDrag = ~multiDragElements.indexOf(dragEl);\n    },\n\n    setupClone({ sortable, cancel }) {\n      if (!this.isMultiDrag) return;\n      for (let i = 0; i < multiDragElements.length; i++) {\n        multiDragClones.push(clone(multiDragElements[i]));\n\n        multiDragClones[i].sortableIndex = multiDragElements[i].sortableIndex;\n\n        multiDragClones[i].draggable = false;\n        multiDragClones[i].style[\"will-change\"] = \"\";\n\n        toggleClass(multiDragClones[i], this.options.selectedClass, false);\n        multiDragElements[i] === dragEl &&\n          toggleClass(multiDragClones[i], this.options.chosenClass, false);\n      }\n\n      sortable._hideClone();\n      cancel();\n    },\n\n    clone({ sortable, rootEl, dispatchSortableEvent, cancel }) {\n      if (!this.isMultiDrag) return;\n      if (!this.options.removeCloneOnHide) {\n        if (multiDragElements.length && multiDragSortable === sortable) {\n          insertMultiDragClones(true, rootEl);\n          dispatchSortableEvent(\"clone\");\n\n          cancel();\n        }\n      }\n    },\n\n    showClone({ cloneNowShown, rootEl, cancel }) {\n      if (!this.isMultiDrag) return;\n      insertMultiDragClones(false, rootEl);\n      multiDragClones.forEach((clone) => {\n        css(clone, \"display\", \"\");\n      });\n\n      cloneNowShown();\n      clonesHidden = false;\n      cancel();\n    },\n\n    hideClone({ sortable, cloneNowHidden, cancel }) {\n      if (!this.isMultiDrag) return;\n      multiDragClones.forEach((clone) => {\n        css(clone, \"display\", \"none\");\n        if (this.options.removeCloneOnHide && clone.parentNode) {\n          clone.parentNode.removeChild(clone);\n        }\n      });\n\n      cloneNowHidden();\n      clonesHidden = true;\n      cancel();\n    },\n\n    dragStartGlobal({ sortable }) {\n      if (!this.isMultiDrag && multiDragSortable) {\n        multiDragSortable.multiDrag._deselectMultiDrag();\n      }\n\n      multiDragElements.forEach((multiDragElement) => {\n        //@ts-ignore\n        multiDragElement.sortableIndex = index(multiDragElement);\n      });\n\n      // Sort multi-drag elements\n      multiDragElements = multiDragElements.sort(function (a, b) {\n        return a.sortableIndex - b.sortableIndex;\n      });\n      dragStarted = true;\n    },\n\n    dragStarted({ sortable }) {\n      if (!this.isMultiDrag) return;\n      if (this.options.sort) {\n        // Capture rects,\n        // hide multi drag elements (by positioning them absolute),\n        // set multi drag elements rects to dragRect,\n        // show multi drag elements,\n        // animate to rects,\n        // unset rects & remove from DOM\n\n        sortable.captureAnimationState();\n\n        if (this.options.animation) {\n          multiDragElements.forEach((multiDragElement) => {\n            if (multiDragElement === dragEl) return;\n            css(multiDragElement, \"position\", \"absolute\");\n          });\n\n          //@ts-ignore\n          let dragRect = getRect(dragEl, false, true, true);\n\n          multiDragElements.forEach((multiDragElement) => {\n            if (multiDragElement === dragEl) return;\n            setRect(multiDragElement, dragRect);\n          });\n\n          folding = true;\n          initialFolding = true;\n        }\n      }\n\n      sortable.animateAll(() => {\n        folding = false;\n        initialFolding = false;\n\n        if (this.options.animation) {\n          multiDragElements.forEach((multiDragElement) => {\n            unsetRect(multiDragElement);\n          });\n        }\n\n        // Remove all auxiliary multidrag items from el, if sorting enabled\n        if (this.options.sort) {\n          removeMultiDragElements();\n        }\n      });\n    },\n\n    dragOver({ target, completed, cancel }) {\n      if (folding && ~multiDragElements.indexOf(target)) {\n        completed(false);\n        cancel();\n      }\n    },\n\n    revert({ fromSortable, rootEl, sortable, dragRect }) {\n      if (multiDragElements.length > 1) {\n        // Setup unfold animation\n        multiDragElements.forEach((multiDragElement) => {\n          sortable.addAnimationState({\n            target: multiDragElement,\n            //@ts-ignore\n            rect: folding ? getRect(multiDragElement) : dragRect,\n          });\n\n          unsetRect(multiDragElement);\n\n          multiDragElement.fromRect = dragRect;\n\n          fromSortable.removeAnimationState(multiDragElement);\n        });\n        folding = false;\n        insertMultiDragElements(!this.options.removeCloneOnHide, rootEl);\n      }\n    },\n\n    dragOverCompleted({\n      sortable,\n      isOwner,\n      insertion,\n      activeSortable,\n      parentEl,\n      putSortable,\n    }) {\n      let options = this.options;\n      if (insertion) {\n        // Clones must be hidden before folding animation to capture dragRectAbsolute properly\n        if (isOwner) {\n          activeSortable._hideClone();\n        }\n\n        initialFolding = false;\n        // If leaving sort:false root, or already folding - Fold to new location\n        if (\n          options.animation &&\n          multiDragElements.length > 1 &&\n          (folding ||\n            (!isOwner && !activeSortable.options.sort && !putSortable))\n        ) {\n          //@ts-ignore\n          // Fold: Set all multi drag elements's rects to dragEl's rect when multi-drag elements are invisible\n          let dragRectAbsolute = getRect(dragEl, false, true, true);\n\n          multiDragElements.forEach((multiDragElement) => {\n            if (multiDragElement === dragEl) return;\n            setRect(multiDragElement, dragRectAbsolute);\n\n            // Move element(s) to end of parentEl so that it does not interfere with multi-drag clones insertion if they are inserted\n            // while folding, and so that we can capture them again because old sortable will no longer be fromSortable\n            parentEl.appendChild(multiDragElement);\n          });\n\n          folding = true;\n        }\n\n        // Clones must be shown (and check to remove multi drags) after folding when interfering multiDragElements are moved out\n        if (!isOwner) {\n          // Only remove if not folding (folding will remove them anyways)\n          if (!folding) {\n            removeMultiDragElements();\n          }\n\n          if (multiDragElements.length > 1) {\n            let clonesHiddenBefore = clonesHidden;\n            activeSortable._showClone(sortable);\n\n            // Unfold animation for clones if showing from hidden\n            if (\n              activeSortable.options.animation &&\n              !clonesHidden &&\n              clonesHiddenBefore\n            ) {\n              multiDragClones.forEach((clone) => {\n                activeSortable.addAnimationState({\n                  target: clone,\n                  rect: clonesFromRect,\n                });\n\n                clone.fromRect = clonesFromRect;\n                clone.thisAnimationDuration = null;\n              });\n            }\n          } else {\n            activeSortable._showClone(sortable);\n          }\n        }\n      }\n    },\n\n    dragOverAnimationCapture({ dragRect, isOwner, activeSortable }) {\n      multiDragElements.forEach((multiDragElement) => {\n        multiDragElement.thisAnimationDuration = null;\n      });\n\n      if (\n        activeSortable.options.animation &&\n        !isOwner &&\n        activeSortable.multiDrag.isMultiDrag\n      ) {\n        clonesFromRect = Object.assign({}, dragRect);\n        let dragMatrix = matrix(dragEl, true);\n        clonesFromRect.top -= dragMatrix.f;\n        clonesFromRect.left -= dragMatrix.e;\n      }\n    },\n\n    dragOverAnimationComplete() {\n      if (folding) {\n        folding = false;\n        removeMultiDragElements();\n      }\n    },\n\n    drop({\n      originalEvent: evt,\n      rootEl,\n      parentEl,\n      sortable,\n      dispatchSortableEvent,\n      oldIndex,\n      putSortable,\n    }) {\n      let toSortable = putSortable || this.sortable;\n\n      if (!evt) return;\n\n      let options = this.options,\n        children = parentEl.children;\n\n      // Multi-drag selection\n      if (!dragStarted) {\n        if (options.multiDragKey && !this.multiDragKeyDown) {\n          this._deselectMultiDrag();\n        }\n        toggleClass(\n          dragEl,\n          options.selectedClass,\n          !~multiDragElements.indexOf(dragEl)\n        );\n\n        if (!~multiDragElements.indexOf(dragEl)) {\n          multiDragElements.push(dragEl);\n          dispatchEvent({\n            sortable,\n            rootEl,\n            name: \"select\",\n            targetEl: dragEl,\n            //@ts-ignore\n            originalEvt: evt,\n          });\n\n          // Modifier activated, select from last to dragEl\n          if (\n            evt.shiftKey &&\n            lastMultiDragSelect &&\n            sortable.el.contains(lastMultiDragSelect)\n          ) {\n            //@ts-ignore\n            let lastIndex = index(lastMultiDragSelect),\n              //@ts-ignore\n              currentIndex = index(dragEl);\n\n            if (~lastIndex && ~currentIndex && lastIndex !== currentIndex) {\n              // Must include lastMultiDragSelect (select it), in case modified selection from no selection\n              // (but previous selection existed)\n              let n, i;\n              if (currentIndex > lastIndex) {\n                i = lastIndex;\n                n = currentIndex;\n              } else {\n                i = currentIndex;\n                n = lastIndex + 1;\n              }\n\n              for (; i < n; i++) {\n                if (~multiDragElements.indexOf(children[i])) continue;\n                toggleClass(children[i], options.selectedClass, true);\n                multiDragElements.push(children[i]);\n\n                dispatchEvent({\n                  sortable,\n                  rootEl,\n                  name: \"select\",\n                  targetEl: children[i],\n                  //@ts-ignore\n                  originalEvt: evt,\n                });\n              }\n            }\n          } else {\n            lastMultiDragSelect = dragEl;\n          }\n\n          multiDragSortable = toSortable;\n        } else {\n          multiDragElements.splice(multiDragElements.indexOf(dragEl), 1);\n          lastMultiDragSelect = null;\n          dispatchEvent({\n            sortable,\n            rootEl,\n            name: \"deselect\",\n            targetEl: dragEl,\n            //@ts-ignore\n            originalEvt: evt,\n          });\n        }\n      }\n\n      // Multi-drag drop\n      if (dragStarted && this.isMultiDrag) {\n        // Do not \"unfold\" after around dragEl if reverted\n        if (\n          (parentEl[expando].options.sort || parentEl !== rootEl) &&\n          multiDragElements.length > 1\n        ) {\n          //@ts-ignore\n          let dragRect = getRect(dragEl),\n            multiDragIndex = index(\n              dragEl,\n              \":not(.\" + this.options.selectedClass + \")\"\n            );\n\n          if (!initialFolding && options.animation)\n            dragEl.thisAnimationDuration = null;\n\n          toSortable.captureAnimationState();\n\n          if (!initialFolding) {\n            if (options.animation) {\n              dragEl.fromRect = dragRect;\n              multiDragElements.forEach((multiDragElement) => {\n                multiDragElement.thisAnimationDuration = null;\n                if (multiDragElement !== dragEl) {\n                  //@ts-ignore\n                  let rect = folding ? getRect(multiDragElement) : dragRect;\n                  multiDragElement.fromRect = rect;\n\n                  // Prepare unfold animation\n                  toSortable.addAnimationState({\n                    target: multiDragElement,\n                    rect: rect,\n                  });\n                }\n              });\n            }\n\n            // Multi drag elements are not necessarily removed from the DOM on drop, so to reinsert\n            // properly they must all be removed\n            removeMultiDragElements();\n\n            multiDragElements.forEach((multiDragElement) => {\n              if (children[multiDragIndex]) {\n                parentEl.insertBefore(\n                  multiDragElement,\n                  children[multiDragIndex]\n                );\n              } else {\n                parentEl.appendChild(multiDragElement);\n              }\n              multiDragIndex++;\n            });\n\n            // If initial folding is done, the elements may have changed position because they are now\n            // unfolding around dragEl, even though dragEl may not have his index changed, so update event\n            // must be fired here as Sortable will not.\n            //@ts-ignore\n            if (oldIndex === index(dragEl)) {\n              let update = false;\n              multiDragElements.forEach((multiDragElement) => {\n                //@ts-ignore\n                if (\n                  //@ts-ignore\n                  multiDragElement.sortableIndex !== index(multiDragElement)\n                ) {\n                  update = true;\n                  return;\n                }\n              });\n\n              if (update) {\n                dispatchSortableEvent(\"update\");\n              }\n            }\n          }\n\n          // Must be done after capturing individual rects (scroll bar)\n          multiDragElements.forEach((multiDragElement) => {\n            unsetRect(multiDragElement);\n          });\n\n          toSortable.animateAll();\n        }\n\n        multiDragSortable = toSortable;\n      }\n\n      // Remove clones if necessary\n      if (\n        rootEl === parentEl ||\n        (putSortable && putSortable.lastPutMode !== \"clone\")\n      ) {\n        multiDragClones.forEach((clone) => {\n          clone.parentNode && clone.parentNode.removeChild(clone);\n        });\n      }\n    },\n\n    nullingGlobal() {\n      this.isMultiDrag = dragStarted = false;\n      multiDragClones.length = 0;\n    },\n\n    destroyGlobal() {\n      this._deselectMultiDrag();\n      off(document, \"pointerup\", this._deselectMultiDrag);\n      off(document, \"mouseup\", this._deselectMultiDrag);\n      off(document, \"touchend\", this._deselectMultiDrag);\n\n      off(document, \"keydown\", this._checkKeyDown);\n      off(document, \"keyup\", this._checkKeyUp);\n    },\n\n    _deselectMultiDrag(evt) {\n      if (typeof dragStarted !== \"undefined\" && dragStarted) return;\n\n      // Only deselect if selection is in this sortable\n      if (multiDragSortable !== this.sortable) return;\n\n      // Only deselect if target is not item in this sortable\n      if (\n        evt &&\n        closest(evt.target, this.options.draggable, this.sortable.el, false)\n      )\n        return;\n\n      // Only deselect if left click\n      if (evt && evt.button !== 0) return;\n\n      while (multiDragElements.length) {\n        let el = multiDragElements[0];\n        toggleClass(el, this.options.selectedClass, false);\n        multiDragElements.shift();\n        dispatchEvent({\n          sortable: this.sortable,\n          rootEl: this.sortable.el,\n          name: \"deselect\",\n          //@ts-ignore\n          targetEl: el,\n          //@ts-ignore\n          originalEvt: evt,\n        });\n      }\n    },\n\n    _checkKeyDown(evt) {\n      if (evt.key === this.options.multiDragKey) {\n        this.multiDragKeyDown = true;\n      }\n    },\n\n    _checkKeyUp(evt) {\n      if (evt.key === this.options.multiDragKey) {\n        this.multiDragKeyDown = false;\n      }\n    },\n  };\n\n  return Object.assign(MultiDrag, {\n    // Static methods & properties\n    pluginName: \"multiDrag\",\n    utils: {\n      /**\n       * Selects the provided multi-drag item\n       * @param  {HTMLElement} el    The element to be selected\n       */\n      select(el) {\n        let sortable = el.parentNode[expando];\n        if (\n          !sortable ||\n          !sortable.options.multiDrag ||\n          ~multiDragElements.indexOf(el)\n        )\n          return;\n        if (multiDragSortable && multiDragSortable !== sortable) {\n          multiDragSortable.multiDrag._deselectMultiDrag();\n          multiDragSortable = sortable;\n        }\n        toggleClass(el, sortable.options.selectedClass, true);\n        multiDragElements.push(el);\n      },\n      /**\n       * Deselects the provided multi-drag item\n       * @param  {HTMLElement} el    The element to be deselected\n       */\n      deselect(el) {\n        let sortable = el.parentNode[expando],\n          index = multiDragElements.indexOf(el);\n        if (!sortable || !sortable.options.multiDrag || !~index) return;\n        toggleClass(el, sortable.options.selectedClass, false);\n        multiDragElements.splice(index, 1);\n      },\n    },\n    eventProperties() {\n      const oldIndicies = [],\n        newIndicies = [];\n\n      multiDragElements.forEach((multiDragElement) => {\n        oldIndicies.push({\n          multiDragElement,\n          index: multiDragElement.sortableIndex,\n        });\n\n        // multiDragElements will already be sorted if folding\n        let newIndex;\n        if (folding && multiDragElement !== dragEl) {\n          newIndex = -1;\n        } else if (folding) {\n          newIndex = index(\n            multiDragElement,\n            \":not(.\" + this.options.selectedClass + \")\"\n          );\n        } else {\n          //@ts-ignore\n          newIndex = index(multiDragElement);\n        }\n        newIndicies.push({\n          multiDragElement,\n          index: newIndex,\n        });\n      });\n      return {\n        items: [...multiDragElements],\n        clones: [...multiDragClones],\n        oldIndicies,\n        newIndicies,\n      };\n    },\n    optionListeners: {\n      multiDragKey(key) {\n        key = key.toLowerCase();\n        if (key === \"ctrl\") {\n          key = \"Control\";\n        } else if (key.length > 1) {\n          key = key.charAt(0).toUpperCase() + key.substr(1);\n        }\n        return key;\n      },\n    },\n  });\n}\n\nfunction insertMultiDragElements(clonesInserted, rootEl) {\n  multiDragElements.forEach((multiDragElement, i) => {\n    let target =\n      rootEl.children[\n        multiDragElement.sortableIndex + (clonesInserted ? Number(i) : 0)\n      ];\n    if (target) {\n      rootEl.insertBefore(multiDragElement, target);\n    } else {\n      rootEl.appendChild(multiDragElement);\n    }\n  });\n}\n\n/**\n * Insert multi-drag clones\n * @param  {[Boolean]} elementsInserted  Whether the multi-drag elements are inserted\n * @param  {HTMLElement} rootEl\n */\nfunction insertMultiDragClones(elementsInserted, rootEl) {\n  multiDragClones.forEach((clone, i) => {\n    let target =\n      rootEl.children[clone.sortableIndex + (elementsInserted ? Number(i) : 0)];\n    if (target) {\n      rootEl.insertBefore(clone, target);\n    } else {\n      rootEl.appendChild(clone);\n    }\n  });\n}\n\nfunction removeMultiDragElements() {\n  multiDragElements.forEach((multiDragElement) => {\n    if (multiDragElement === dragEl) return;\n    multiDragElement.parentNode &&\n      multiDragElement.parentNode.removeChild(multiDragElement);\n  });\n}\n\nexport default MultiDragPlugin;\n","import { getChild } from \"../../../utils/src\";\n\nconst drop = function ({\n  originalEvent,\n  putSortable,\n  dragEl,\n  activeSortable,\n  dispatchSortableEvent,\n  hideGhostForTarget,\n  unhideGhostForTarget,\n}) {\n  if (!originalEvent) return;\n  let toSortable = putSortable || activeSortable;\n  hideGhostForTarget();\n  let touch =\n    originalEvent.changedTouches && originalEvent.changedTouches.length\n      ? originalEvent.changedTouches[0]\n      : originalEvent;\n  let target = document.elementFromPoint(touch.clientX, touch.clientY);\n  unhideGhostForTarget();\n  if (toSortable && !toSortable.el.contains(target)) {\n    dispatchSortableEvent(\"spill\");\n    this.onSpill({ dragEl, putSortable });\n  }\n};\n\nfunction Revert() {}\n\nRevert.prototype = {\n  startIndex: null,\n  dragStart({ oldDraggableIndex }) {\n    this.startIndex = oldDraggableIndex;\n  },\n  onSpill({ dragEl, putSortable }) {\n    this.sortable.captureAnimationState();\n    if (putSortable) {\n      putSortable.captureAnimationState();\n    }\n    let nextSibling = getChild(this.sortable.el, this.startIndex, this.options);\n\n    if (nextSibling) {\n      this.sortable.el.insertBefore(dragEl, nextSibling);\n    } else {\n      this.sortable.el.appendChild(dragEl);\n    }\n    this.sortable.animateAll();\n    if (putSortable) {\n      putSortable.animateAll();\n    }\n  },\n  drop,\n};\n\nObject.assign(Revert, {\n  pluginName: \"revertOnSpill\",\n});\n\nfunction Remove() {}\n\nRemove.prototype = {\n  onSpill({ dragEl, putSortable }) {\n    const parentSortable = putSortable || this.sortable;\n    parentSortable.captureAnimationState();\n    dragEl.parentNode && dragEl.parentNode.removeChild(dragEl);\n    parentSortable.animateAll();\n  },\n  drop,\n};\n\nObject.assign(Remove, {\n  pluginName: \"removeOnSpill\",\n});\n\nexport default [Remove, Revert];\n\nexport { Remove as RemoveOnSpill, Revert as RevertOnSpill };\n","import {\n  on,\n  off,\n  css,\n  throttle,\n  cancelThrottle,\n  scrollBy,\n  getParentAutoScrollElement,\n  expando,\n  getRect,\n  getWindowScrollingElement,\n  Edge,\n  IE11OrLess,\n  Safari,\n} from \"../../../utils/src\";\n\nimport Sortable from \"../../../sortable/src/Sortable\";\n\nlet autoScrolls = [],\n  scrollEl,\n  scrollRootEl,\n  scrolling = false,\n  lastAutoScrollX,\n  lastAutoScrollY,\n  touchEvt,\n  pointerElemChangedInterval;\n\nfunction AutoScrollPlugin() {\n  function AutoScroll() {\n    this.defaults = {\n      scroll: true,\n      scrollSensitivity: 30,\n      scrollSpeed: 10,\n      bubbleScroll: true,\n    };\n\n    // Bind all private methods\n    for (let fn in this) {\n      if (fn.charAt(0) === \"_\" && typeof this[fn] === \"function\") {\n        this[fn] = this[fn].bind(this);\n      }\n    }\n  }\n\n  AutoScroll.prototype = {\n    dragStarted({ originalEvent }) {\n      if (this.sortable.nativeDraggable) {\n        on(document, \"dragover\", this._handleAutoScroll);\n      } else {\n        if (this.options.supportPointer) {\n          on(document, \"pointermove\", this._handleFallbackAutoScroll);\n        } else if (originalEvent.touches) {\n          on(document, \"touchmove\", this._handleFallbackAutoScroll);\n        } else {\n          on(document, \"mousemove\", this._handleFallbackAutoScroll);\n        }\n      }\n    },\n\n    dragOverCompleted({ originalEvent }) {\n      // For when bubbling is canceled and using fallback (fallback 'touchmove' always reached)\n      if (!this.options.dragOverBubble && !originalEvent.rootEl) {\n        this._handleAutoScroll(originalEvent);\n      }\n    },\n\n    drop() {\n      if (this.sortable.nativeDraggable) {\n        off(document, \"dragover\", this._handleAutoScroll);\n      } else {\n        off(document, \"pointermove\", this._handleFallbackAutoScroll);\n        off(document, \"touchmove\", this._handleFallbackAutoScroll);\n        off(document, \"mousemove\", this._handleFallbackAutoScroll);\n      }\n\n      clearPointerElemChangedInterval();\n      clearAutoScrolls();\n      cancelThrottle();\n    },\n\n    nulling() {\n      touchEvt = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;\n\n      autoScrolls.length = 0;\n    },\n\n    _handleFallbackAutoScroll(evt) {\n      this._handleAutoScroll(evt, true);\n    },\n\n    _handleAutoScroll(evt, fallback) {\n      const x = (evt.touches ? evt.touches[0] : evt).clientX,\n        y = (evt.touches ? evt.touches[0] : evt).clientY,\n        elem = document.elementFromPoint(x, y);\n\n      touchEvt = evt;\n\n      // IE does not seem to have native autoscroll,\n      // Edge's autoscroll seems too conditional,\n      // MACOS Safari does not have autoscroll,\n      // Firefox and Chrome are good\n      if (fallback || Edge || IE11OrLess || Safari) {\n        //@ts-ignore\n        autoScroll(evt, this.options, elem, fallback);\n\n        // Listener for pointer element change\n        let ogElemScroller = getParentAutoScrollElement(elem, true);\n        if (\n          scrolling &&\n          (!pointerElemChangedInterval ||\n            x !== lastAutoScrollX ||\n            y !== lastAutoScrollY)\n        ) {\n          pointerElemChangedInterval && clearPointerElemChangedInterval();\n          // Detect for pointer elem change, emulating native DnD behaviour\n          pointerElemChangedInterval = setInterval(() => {\n            let newElem = getParentAutoScrollElement(\n              document.elementFromPoint(x, y),\n              true\n            );\n            if (newElem !== ogElemScroller) {\n              ogElemScroller = newElem;\n              clearAutoScrolls();\n            }\n            //@ts-ignore\n            autoScroll(evt, this.options, newElem, fallback);\n          }, 10);\n          lastAutoScrollX = x;\n          lastAutoScrollY = y;\n        }\n      } else {\n        // if DnD is enabled (and browser has good autoscrolling), first autoscroll will already scroll, so get parent autoscroll of first autoscroll\n        if (\n          !this.options.bubbleScroll ||\n          getParentAutoScrollElement(elem, true) === getWindowScrollingElement()\n        ) {\n          clearAutoScrolls();\n          return;\n        }\n        autoScroll(\n          //@ts-ignore\n          evt,\n          this.options,\n          getParentAutoScrollElement(elem, false),\n          false\n        );\n      }\n    },\n  };\n\n  return Object.assign(AutoScroll, {\n    pluginName: \"scroll\",\n    initializeByDefault: true,\n  });\n}\n\nfunction clearAutoScrolls() {\n  autoScrolls.forEach(function (autoScroll) {\n    clearInterval(autoScroll.pid);\n  });\n  autoScrolls = [];\n}\n\nfunction clearPointerElemChangedInterval() {\n  clearInterval(pointerElemChangedInterval);\n}\n\nconst autoScroll = throttle(function (evt, options, rootEl, isFallback) {\n  // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521\n  if (!options.scroll) return;\n  const x = (evt.touches ? evt.touches[0] : evt).clientX,\n    y = (evt.touches ? evt.touches[0] : evt).clientY,\n    sens = options.scrollSensitivity,\n    speed = options.scrollSpeed,\n    winScroller = getWindowScrollingElement();\n\n  let scrollThisInstance = false,\n    scrollCustomFn;\n\n  // New scroll root, set scrollEl\n  if (scrollRootEl !== rootEl) {\n    scrollRootEl = rootEl;\n\n    clearAutoScrolls();\n\n    scrollEl = options.scroll;\n    scrollCustomFn = options.scrollFn;\n\n    if (scrollEl === true) {\n      scrollEl = getParentAutoScrollElement(rootEl, true);\n    }\n  }\n\n  let layersOut = 0;\n  let currentParent = scrollEl;\n  do {\n    let el = currentParent,\n      //@ts-ignore\n      rect = getRect(el),\n      top = rect.top,\n      bottom = rect.bottom,\n      left = rect.left,\n      right = rect.right,\n      width = rect.width,\n      height = rect.height,\n      canScrollX,\n      canScrollY,\n      scrollWidth = el.scrollWidth,\n      scrollHeight = el.scrollHeight,\n      //@ts-ignore\n      elCSS = css(el),\n      scrollPosX = el.scrollLeft,\n      scrollPosY = el.scrollTop;\n\n    if (el === winScroller) {\n      canScrollX =\n        width < scrollWidth &&\n        (elCSS.overflowX === \"auto\" ||\n          elCSS.overflowX === \"scroll\" ||\n          elCSS.overflowX === \"visible\");\n      canScrollY =\n        height < scrollHeight &&\n        (elCSS.overflowY === \"auto\" ||\n          elCSS.overflowY === \"scroll\" ||\n          elCSS.overflowY === \"visible\");\n    } else {\n      canScrollX =\n        width < scrollWidth &&\n        (elCSS.overflowX === \"auto\" || elCSS.overflowX === \"scroll\");\n      canScrollY =\n        height < scrollHeight &&\n        (elCSS.overflowY === \"auto\" || elCSS.overflowY === \"scroll\");\n    }\n\n    let vx =\n      canScrollX &&\n      //@ts-ignore\n      (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) -\n        //@ts-ignore\n        (Math.abs(left - x) <= sens && !!scrollPosX);\n    let vy =\n      canScrollY &&\n      //@ts-ignore\n      (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) -\n        //@ts-ignore\n        (Math.abs(top - y) <= sens && !!scrollPosY);\n\n    if (!autoScrolls[layersOut]) {\n      for (let i = 0; i <= layersOut; i++) {\n        if (!autoScrolls[i]) {\n          autoScrolls[i] = {};\n        }\n      }\n    }\n\n    if (\n      autoScrolls[layersOut].vx != vx ||\n      autoScrolls[layersOut].vy != vy ||\n      autoScrolls[layersOut].el !== el\n    ) {\n      autoScrolls[layersOut].el = el;\n      autoScrolls[layersOut].vx = vx;\n      autoScrolls[layersOut].vy = vy;\n\n      clearInterval(autoScrolls[layersOut].pid);\n\n      if (vx != 0 || vy != 0) {\n        scrollThisInstance = true;\n        /* jshint loopfunc:true */\n        autoScrolls[layersOut].pid = setInterval(\n          function () {\n            // emulate drag over during autoscroll (fallback), emulating native DnD behaviour\n            if (isFallback && this.layer === 0) {\n              //@ts-ignore\n              Sortable.active._onTouchMove(touchEvt); // To move ghost if it is positioned absolutely\n            }\n            let scrollOffsetY = autoScrolls[this.layer].vy\n              ? autoScrolls[this.layer].vy * speed\n              : 0;\n            let scrollOffsetX = autoScrolls[this.layer].vx\n              ? autoScrolls[this.layer].vx * speed\n              : 0;\n\n            if (typeof scrollCustomFn === \"function\") {\n              if (\n                scrollCustomFn.call(\n                  //@ts-ignore\n                  Sortable.dragged.parentNode[expando],\n                  scrollOffsetX,\n                  scrollOffsetY,\n                  evt,\n                  touchEvt,\n                  autoScrolls[this.layer].el\n                ) !== \"continue\"\n              ) {\n                return;\n              }\n            }\n\n            scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);\n          }.bind({ layer: layersOut }),\n          24\n        );\n      }\n    }\n    layersOut++;\n  } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));\n  scrolling = scrollThisInstance; // in case another function catches scrolling as false in between when it is not\n}, 30);\n\nexport default AutoScrollPlugin;\n","import Sortable from \"../../sortable/src/Sortable\";\nimport Swap from \"../../plugins/swap/src\";\nimport MultiDrag from \"../../plugins/multi-drag/src\";\nimport { RemoveOnSpill, RevertOnSpill } from \"../../plugins/on-spill/src\";\nimport AutoScroll from \"../../plugins/auto-scroll/src\";\n\n//@ts-ignore\nSortable.mount(new AutoScroll());\nSortable.mount(RemoveOnSpill, RevertOnSpill);\n//@ts-ignore\nSortable.mount(new Swap());\n//@ts-ignore\nSortable.mount(new MultiDrag());\n\nexport default Sortable;\nexport { Sortable };\n"]},"metadata":{},"sourceType":"module"}