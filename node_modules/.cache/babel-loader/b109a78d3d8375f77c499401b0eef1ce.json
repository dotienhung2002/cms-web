{"ast":null,"code":"function t(t, r) {\n  for (var n = 0; n < r.length; n++) {\n    var i = r[n];\n    i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);\n  }\n}\nfunction r() {\n  return (r = Object.assign || function (t) {\n    for (var r = 1; r < arguments.length; r++) {\n      var n = arguments[r];\n      for (var i in n) {\n        Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);\n      }\n    }\n    return t;\n  }).apply(this, arguments);\n}\nfunction n(t, r) {\n  t.prototype = Object.create(r.prototype), t.prototype.constructor = t, t.__proto__ = r;\n}\nvar i = function () {\n    function r(t, r) {\n      this.operator = t, this.value = r, Object.defineProperty(this, \"t\", {\n        writable: !0\n      });\n    }\n    var n, i, e;\n    return r.prototype.addNote = function (t) {\n      this.t = this.t || [], this.t.push(t);\n    }, n = r, (i = [{\n      key: \"notes\",\n      get: function get() {\n        return this.t;\n      }\n    }]) && t(n.prototype, i), e && t(n, e), r;\n  }(),\n  e = function (t) {\n    function r() {\n      return t.apply(this, arguments) || this;\n    }\n    return n(r, t), r;\n  }(i),\n  o = function (t) {\n    function r(r, n) {\n      if (!Array.isArray(n)) throw new Error('\"' + r + '\" operator expects to receive an array of conditions');\n      return t.call(this, r, n) || this;\n    }\n    return n(r, t), r;\n  }(e),\n  u = \"__itself__\",\n  f = function (t) {\n    function r(r, n, i) {\n      var e;\n      return (e = t.call(this, r, i) || this).field = n, e;\n    }\n    return n(r, t), r;\n  }(i),\n  a = new e(\"__null__\", null),\n  c = Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty);\nfunction s(t, r) {\n  return r instanceof o && r.operator === t;\n}\nfunction h(t, r) {\n  return 1 === r.length ? r[0] : new o(t, function t(r, n, i) {\n    for (var e = i || [], o = 0, u = n.length; o < u; o++) {\n      var f = n[o];\n      s(r, f) ? t(r, f.value, e) : e.push(f);\n    }\n    return e;\n  }(t, r));\n}\nvar v = function v(t) {\n    return t;\n  },\n  d = function d() {\n    return Object.create(null);\n  },\n  l = Object.defineProperty(d(), \"__@type@__\", {\n    value: \"ignore value\"\n  });\nfunction p(t, r, n) {\n  if (void 0 === n && (n = !1), !t || t && t.constructor !== Object) return !1;\n  for (var i in t) {\n    if (c(t, i) && c(r, i) && (!n || t[i] !== l)) return !0;\n  }\n  return !1;\n}\nfunction w(t) {\n  var r = [];\n  for (var n in t) {\n    c(t, n) && t[n] !== l && r.push(n);\n  }\n  return r;\n}\nfunction b(t, r) {\n  r !== a && t.push(r);\n}\nvar y = function y(t) {\n    return h(\"and\", t);\n  },\n  O = function O(t) {\n    return h(\"or\", t);\n  },\n  j = {\n    compound: function compound(t, r, n) {\n      var i = (Array.isArray(r) ? r : [r]).map(function (t) {\n        return n.parse(t);\n      });\n      return new o(t.name, i);\n    },\n    field: function field(t, r, n) {\n      return new f(t.name, n.field, r);\n    },\n    document: function document(t, r) {\n      return new e(t.name, r);\n    }\n  },\n  _ = function () {\n    function t(t, n) {\n      var i = this;\n      void 0 === n && (n = d()), this.i = void 0, this.o = void 0, this.u = void 0, this.s = void 0, this.h = void 0, this.parse = this.parse.bind(this), this.s = {\n        operatorToConditionName: n.operatorToConditionName || v,\n        defaultOperatorName: n.defaultOperatorName || \"eq\",\n        mergeFinalConditions: n.mergeFinalConditions || y\n      }, this.i = Object.keys(t).reduce(function (n, e) {\n        return n[e] = r({\n          name: i.s.operatorToConditionName(e)\n        }, t[e]), n;\n      }, {}), this.o = r({}, n.fieldContext, {\n        field: \"\",\n        query: {},\n        parse: this.parse,\n        hasOperators: function hasOperators(t) {\n          return p(t, i.i, n.useIgnoreValue);\n        }\n      }), this.u = r({}, n.documentContext, {\n        parse: this.parse,\n        query: {}\n      }), this.h = n.useIgnoreValue ? w : Object.keys;\n    }\n    var n = t.prototype;\n    return n.setParse = function (t) {\n      this.parse = t, this.o.parse = t, this.u.parse = t;\n    }, n.parseField = function (t, r, n, i) {\n      var e = this.i[r];\n      if (!e) throw new Error('Unsupported operator \"' + r + '\"');\n      if (\"field\" !== e.type) throw new Error(\"Unexpected \" + e.type + ' operator \"' + r + '\" at field level');\n      return this.o.field = t, this.o.query = i, this.parseInstruction(e, n, this.o);\n    }, n.parseInstruction = function (t, r, n) {\n      return \"function\" == typeof t.validate && t.validate(t, r), (t.parse || j[t.type])(t, r, n);\n    }, n.parseFieldOperators = function (t, r) {\n      for (var n = [], i = this.h(r), e = 0, o = i.length; e < o; e++) {\n        var u = i[e];\n        if (!this.i[u]) throw new Error('Field query for \"' + t + '\" may contain only operators or a plain object as a value');\n        b(n, this.parseField(t, u, r[u], r));\n      }\n      return n;\n    }, n.parse = function (t) {\n      var r = [],\n        n = this.h(t);\n      this.u.query = t;\n      for (var i = 0, e = n.length; i < e; i++) {\n        var o = n[i],\n          u = t[o],\n          f = this.i[o];\n        if (f) {\n          if (\"document\" !== f.type && \"compound\" !== f.type) throw new Error('Cannot use parsing instruction for operator \"' + o + '\" in \"document\" context as it is supposed to be used in  \"' + f.type + '\" context');\n          b(r, this.parseInstruction(f, u, this.u));\n        } else this.o.hasOperators(u) ? r.push.apply(r, this.parseFieldOperators(o, u)) : b(r, this.parseField(o, this.s.defaultOperatorName, u, t));\n      }\n      return this.s.mergeFinalConditions(r);\n    }, t;\n  }();\nfunction m(t, r) {\n  var n = t[r];\n  if (\"function\" != typeof n) throw new Error('Unable to interpret \"' + r + '\" condition. Did you forget to register interpreter for it?');\n  return n;\n}\nfunction g(t) {\n  return t.operator;\n}\nfunction E(t, n) {\n  var i,\n    e = n,\n    o = e && e.getInterpreterName || g;\n  switch (e ? e.numberOfArguments : 0) {\n    case 1:\n      i = function i(r) {\n        var n = o(r, e);\n        return m(t, n)(r, u);\n      };\n      break;\n    case 3:\n      i = function i(r, n, _i) {\n        var f = o(r, e);\n        return m(t, f)(r, n, _i, u);\n      };\n      break;\n    default:\n      i = function i(r, n) {\n        var i = o(r, e);\n        return m(t, i)(r, n, u);\n      };\n  }\n  var u = r({}, e, {\n    interpret: i\n  });\n  return u.interpret;\n}\nfunction x(t, r) {\n  return function (n) {\n    for (var i = arguments.length, e = new Array(i > 1 ? i - 1 : 0), o = 1; o < i; o++) {\n      e[o - 1] = arguments[o];\n    }\n    var u = t.apply(void 0, [n].concat(e)),\n      f = r.bind(null, u);\n    return f.ast = u, f;\n  };\n}\nvar q = _.prototype.parseInstruction;\nexport { o as CompoundCondition, i as Condition, e as DocumentCondition, f as FieldCondition, u as ITSELF, a as NULL_CONDITION, _ as ObjectQueryParser, y as buildAnd, O as buildOr, E as createInterpreter, x as createTranslatorFactory, j as defaultInstructionParsers, p as hasOperators, v as identity, l as ignoreValue, s as isCompound, d as object, h as optimizedCompoundCondition, q as parseInstruction };","map":{"version":3,"sources":["../../src/Condition.ts","../../src/utils.ts","../../src/builder.ts","../../src/parsers/defaultInstructionParsers.ts","../../src/parsers/ObjectQueryParser.ts","../../src/interpreter.ts","../../src/translator.ts","../../src/index.ts"],"names":["Condition","operator","value","Object","defineProperty","this","writable","_notes","addNote","note","push","DocumentCondition","CompoundCondition","conditions","Array","isArray","Error","_DocumentCondition","ITSELF","FieldCondition","field","NULL_CONDITION","hasOwnProperty","prototype","call","bind","isCompound","condition","flattenConditions","aggregatedResult","flatConditions","i","length","currentNode","optimizedCompoundCondition","identity","x","object","create","ignoreValue","hasOperators","instructions","skipIgnore","constructor","prop","objectKeysSkipIgnore","anyObject","keys","key","pushIfNonNullCondition","buildAnd","buildOr","defaultInstructionParsers","compound","instruction","context","map","parse","query","name","document","ObjectQueryParser","_instructions","_fieldInstructionContext","_documentInstructionContext","_options","_objectKeys","options","operatorToConditionName","defaultOperatorName","mergeFinalConditions","reduce","all","_this","fieldContext","useIgnoreValue","documentContext","setParse","parseField","parentQuery","type","parseInstruction","validate","parseFieldOperators","op","getInterpreter","interpreters","interpret","defaultInterpreterName","createInterpreter","rawOptions","getInterpreterName","numberOfArguments","interpreterName","interpretOperator","defaultContext","params","createTranslatorFactory","args","ast","translate"],"mappings":"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","sourcesContent":["export interface Note<T> {\n  type: string\n  message?: string\n  originalValue?: T\n}\n\nexport abstract class Condition<T = unknown> {\n  private _notes!: Note<T>[];\n\n  constructor(\n    public readonly operator: string,\n    public readonly value: T\n  ) {\n    Object.defineProperty(this, '_notes', {\n      writable: true\n    });\n  }\n\n  get notes(): ReadonlyArray<Note<T>> | undefined {\n    return this._notes;\n  }\n\n  addNote(note: Note<T>) {\n    this._notes = this._notes || [];\n    this._notes.push(note);\n  }\n}\n\nexport class DocumentCondition<T> extends Condition<T> {\n}\n\nexport class CompoundCondition<T extends Condition = Condition> extends DocumentCondition<T[]> {\n  constructor(operator: string, conditions: T[]) {\n    if (!Array.isArray(conditions)) {\n      throw new Error(`\"${operator}\" operator expects to receive an array of conditions`);\n    }\n\n    super(operator, conditions);\n  }\n}\n\nexport const ITSELF = '__itself__';\nexport class FieldCondition<T = unknown> extends Condition<T> {\n  public readonly field!: string | typeof ITSELF;\n\n  constructor(operator: string, field: string | typeof ITSELF, value: T) {\n    super(operator, value);\n    this.field = field;\n  }\n}\n\nexport const NULL_CONDITION = new DocumentCondition('__null__', null);\nexport type ConditionValue<T> = T extends Condition<infer V> ? V : unknown;\n","import { Condition, CompoundCondition, NULL_CONDITION } from './Condition';\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty);\n\nexport function isCompound(operator: string, condition: Condition): condition is CompoundCondition {\n  return condition instanceof CompoundCondition && condition.operator === operator;\n}\n\nfunction flattenConditions<T extends Condition>(\n  operator: string,\n  conditions: T[],\n  aggregatedResult?: T[]\n) {\n  const flatConditions: T[] = aggregatedResult || [];\n\n  for (let i = 0, length = conditions.length; i < length; i++) {\n    const currentNode = conditions[i];\n\n    if (isCompound(operator, currentNode)) {\n      flattenConditions(operator, currentNode.value as T[], flatConditions);\n    } else {\n      flatConditions.push(currentNode);\n    }\n  }\n\n  return flatConditions;\n}\n\nexport function optimizedCompoundCondition<T extends Condition>(operator: string, conditions: T[]) {\n  if (conditions.length === 1) {\n    return conditions[0];\n  }\n\n  return new CompoundCondition(operator, flattenConditions(operator, conditions));\n}\n\nexport const identity = <T>(x: T) => x;\nexport const object = () => Object.create(null);\n\nexport const ignoreValue: IgnoreValue = Object.defineProperty(object(), '__@type@__', {\n  value: 'ignore value'\n});\nexport interface IgnoreValue {\n  readonly ['__@type@__']: 'ignore value'\n}\n\nexport function hasOperators<T>(\n  value: any,\n  instructions: Record<string, unknown>,\n  skipIgnore = false,\n): value is T {\n  if (!value || value && value.constructor !== Object) {\n    return false;\n  }\n\n  for (const prop in value) { // eslint-disable-line no-restricted-syntax, guard-for-in\n    const hasProp = hasOwnProperty(value, prop) && hasOwnProperty(instructions, prop);\n    if (hasProp && (!skipIgnore || value[prop] !== ignoreValue)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport function objectKeysSkipIgnore(anyObject: Record<string, unknown>) {\n  const keys: string[] = [];\n  for (const key in anyObject) { // eslint-disable-line no-restricted-syntax\n    if (hasOwnProperty(anyObject, key) && anyObject[key] !== ignoreValue) {\n      keys.push(key);\n    }\n  }\n\n  return keys;\n}\n\nexport function pushIfNonNullCondition(conditions: Condition[], condition: Condition) {\n  if (condition !== NULL_CONDITION) {\n    conditions.push(condition);\n  }\n}\n","import { Condition } from './Condition';\nimport { optimizedCompoundCondition } from './utils';\n\nexport const buildAnd = (conditions: Condition[]) => optimizedCompoundCondition('and', conditions);\nexport const buildOr = (conditions: Condition[]) => optimizedCompoundCondition('or', conditions);\n","import {\n  FieldCondition,\n  CompoundCondition,\n  DocumentCondition,\n} from '../Condition';\nimport {\n  DocumentInstruction,\n  CompoundInstruction,\n  FieldInstruction,\n} from '../types';\n\ninterface DefaultParsers {\n  compound: Exclude<CompoundInstruction['parse'], undefined>,\n  field: Exclude<FieldInstruction['parse'], undefined>,\n  document: Exclude<DocumentInstruction['parse'], undefined>\n}\n\nexport const defaultInstructionParsers: DefaultParsers = {\n  compound(instruction, value, context) {\n    const queries = Array.isArray(value) ? value : [value];\n    const conditions = queries.map(query => context.parse(query));\n    return new CompoundCondition(instruction.name, conditions);\n  },\n  field(instruction, value, context) {\n    return new FieldCondition(instruction.name, context.field, value);\n  },\n  document(instruction, value) {\n    return new DocumentCondition(instruction.name, value);\n  }\n};\n","import { Condition } from '../Condition';\nimport {\n  NamedInstruction,\n  ParsingInstruction,\n  FieldParsingContext,\n  ParsingContext,\n} from '../types';\nimport { buildAnd } from '../builder';\nimport { defaultInstructionParsers } from './defaultInstructionParsers';\nimport {\n  identity,\n  hasOperators,\n  object,\n  pushIfNonNullCondition,\n  objectKeysSkipIgnore,\n} from '../utils';\n\nexport type FieldQueryOperators<T extends {}> = {\n  [K in keyof T]: T[K] extends {} ? T[K] : never\n}[keyof T];\n\ntype ParsingInstructions = Record<string, NamedInstruction>;\n\nexport interface QueryOptions {\n  operatorToConditionName?(name: string): string\n  defaultOperatorName?: string\n  fieldContext?: Record<string, unknown>\n  documentContext?: Record<string, unknown>\n  useIgnoreValue?: boolean\n  mergeFinalConditions?(conditions: Condition[]): Condition\n}\n\nexport type ObjectQueryFieldParsingContext = ParsingContext<FieldParsingContext & {\n  query: {},\n  hasOperators<T>(value: unknown): value is T\n}>;\n\nexport class ObjectQueryParser<\n  T extends Record<any, any>,\n  U extends FieldQueryOperators<T> = FieldQueryOperators<T>\n> {\n  private readonly _instructions: ParsingInstructions;\n  private _fieldInstructionContext: ObjectQueryFieldParsingContext;\n  private _documentInstructionContext: ParsingContext<{ query: {} }>;\n  private readonly _options: Required<\n  Pick<QueryOptions, 'operatorToConditionName' | 'defaultOperatorName' | 'mergeFinalConditions'>\n  >;\n\n  private readonly _objectKeys: typeof Object.keys;\n\n  constructor(instructions: Record<string, ParsingInstruction>, options: QueryOptions = object()) {\n    this.parse = this.parse.bind(this);\n    this._options = {\n      operatorToConditionName: options.operatorToConditionName || identity,\n      defaultOperatorName: options.defaultOperatorName || 'eq',\n      mergeFinalConditions: options.mergeFinalConditions || buildAnd,\n    };\n    this._instructions = Object.keys(instructions).reduce((all, name) => {\n      all[name] = { name: this._options.operatorToConditionName(name), ...instructions[name] };\n      return all;\n    }, {} as ParsingInstructions);\n    this._fieldInstructionContext = {\n      ...options.fieldContext,\n      field: '',\n      query: {},\n      parse: this.parse,\n      hasOperators: <T>(value: unknown): value is T => hasOperators(\n        value,\n        this._instructions,\n        options.useIgnoreValue\n      ),\n    };\n    this._documentInstructionContext = {\n      ...options.documentContext,\n      parse: this.parse,\n      query: {}\n    };\n    this._objectKeys = options.useIgnoreValue ? objectKeysSkipIgnore : Object.keys;\n  }\n\n  setParse(parse: this['parse']) {\n    this.parse = parse;\n    this._fieldInstructionContext.parse = parse;\n    this._documentInstructionContext.parse = parse;\n  }\n\n  protected parseField(field: string, operator: string, value: unknown, parentQuery: {}) {\n    const instruction = this._instructions[operator];\n\n    if (!instruction) {\n      throw new Error(`Unsupported operator \"${operator}\"`);\n    }\n\n    if (instruction.type !== 'field') {\n      throw new Error(`Unexpected ${instruction.type} operator \"${operator}\" at field level`);\n    }\n\n    this._fieldInstructionContext.field = field;\n    this._fieldInstructionContext.query = parentQuery;\n\n    return this.parseInstruction(instruction, value, this._fieldInstructionContext);\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  protected parseInstruction(\n    instruction: NamedInstruction,\n    value: unknown,\n    context: ParsingContext<{}>\n  ) {\n    if (typeof instruction.validate === 'function') {\n      instruction.validate(instruction, value);\n    }\n\n    const parse: typeof instruction.parse = instruction.parse\n      || defaultInstructionParsers[instruction.type as keyof typeof defaultInstructionParsers];\n    return parse(instruction, value, context);\n  }\n\n  protected parseFieldOperators(field: string, value: U) {\n    const conditions: Condition[] = [];\n    const keys = this._objectKeys(value);\n\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const op = keys[i];\n      const instruction = this._instructions[op];\n\n      if (!instruction) {\n        throw new Error(`Field query for \"${field}\" may contain only operators or a plain object as a value`);\n      }\n\n      const condition = this.parseField(field, op, value[op as keyof U], value);\n      pushIfNonNullCondition(conditions, condition);\n    }\n\n    return conditions;\n  }\n\n  parse<Q extends T>(query: Q): Condition {\n    const conditions = [];\n    const keys = this._objectKeys(query);\n\n    this._documentInstructionContext.query = query;\n\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const key = keys[i];\n      const value = query[key];\n      const instruction = this._instructions[key];\n\n      if (instruction) {\n        if (instruction.type !== 'document' && instruction.type !== 'compound') {\n          throw new Error(`Cannot use parsing instruction for operator \"${key}\" in \"document\" context as it is supposed to be used in  \"${instruction.type}\" context`);\n        }\n\n        pushIfNonNullCondition(\n          conditions,\n          this.parseInstruction(instruction, value, this._documentInstructionContext)\n        );\n      } else if (this._fieldInstructionContext.hasOperators<U>(value)) {\n        conditions.push(...this.parseFieldOperators(key, value));\n      } else {\n        pushIfNonNullCondition(\n          conditions,\n          this.parseField(key, this._options.defaultOperatorName, value, query)\n        );\n      }\n    }\n\n    return this._options.mergeFinalConditions(conditions);\n  }\n}\n","import { Condition } from './Condition';\n\ntype ArgsExceptLast<F extends (...args: any[]) => any> =\n  F extends (a: any, c: any) => any\n    ? Parameters<(condition: Condition) => 0>\n    : F extends (a: any, b: any, c: any) => any\n      ? Parameters<(condition: Condition, value: Parameters<F>[1]) => 0>\n      : Parameters<(\n        condition: Condition,\n        value: Parameters<F>[1],\n        options: Parameters<F>[2],\n        ...args: unknown[]\n      ) => 0>;\n\nexport type Interpreter<T extends Condition, R> = (condition: T, ...args: any[]) => R;\nexport type AnyInterpreter = Interpreter<any, any>;\nexport interface InterpretationContext<T extends AnyInterpreter> {\n  interpret(...args: ArgsExceptLast<T>): ReturnType<T>;\n}\n\nfunction getInterpreter<T extends Record<string, AnyInterpreter>>(\n  interpreters: T,\n  operator: keyof T\n) {\n  const interpret = interpreters[operator];\n\n  if (typeof interpret !== 'function') {\n    throw new Error(`Unable to interpret \"${operator}\" condition. Did you forget to register interpreter for it?`);\n  }\n\n  return interpret;\n}\n\nexport interface InterpreterOptions {\n  numberOfArguments?: 1 | 2 | 3\n  getInterpreterName?(condition: Condition, context: this): string\n}\n\nfunction defaultInterpreterName(condition: Condition) {\n  return condition.operator;\n}\n\nexport function createInterpreter<T extends AnyInterpreter, U extends {} = {}>(\n  interpreters: Record<string, T>,\n  rawOptions?: U\n) {\n  const options = rawOptions as U & InterpreterOptions;\n  const getInterpreterName = options && options.getInterpreterName || defaultInterpreterName;\n  let interpret;\n\n  switch (options ? options.numberOfArguments : 0) {\n    case 1:\n      interpret = ((condition) => {\n        const interpreterName = getInterpreterName(condition, options);\n        const interpretOperator = getInterpreter(interpreters, interpreterName);\n        return interpretOperator(condition, defaultContext); // eslint-disable-line @typescript-eslint/no-use-before-define\n      }) as InterpretationContext<T>['interpret'];\n      break;\n    case 3:\n      interpret = ((condition, value, params) => {\n        const interpreterName = getInterpreterName(condition, options);\n        const interpretOperator = getInterpreter(interpreters, interpreterName);\n        return interpretOperator(condition, value, params, defaultContext); // eslint-disable-line @typescript-eslint/no-use-before-define\n      }) as InterpretationContext<T>['interpret'];\n      break;\n    default:\n      interpret = ((condition, value) => {\n        const interpreterName = getInterpreterName(condition, options);\n        const interpretOperator = getInterpreter(interpreters, interpreterName);\n        return interpretOperator(condition, value, defaultContext); // eslint-disable-line @typescript-eslint/no-use-before-define\n      }) as InterpretationContext<T>['interpret'];\n      break;\n  }\n\n  const defaultContext = {\n    ...options,\n    interpret,\n  } as InterpretationContext<T> & U;\n\n  return defaultContext.interpret;\n}\n","import { Condition } from './Condition';\nimport { Parse } from './types';\nimport { AnyInterpreter } from './interpreter';\n\ntype Bound<T> = T extends (first: Condition, ...args: infer A) => any\n  ? { (...args: A): ReturnType<T>, ast: Condition }\n  : never;\n\nexport function createTranslatorFactory<Lang, Interpreter extends AnyInterpreter>(\n  parse: Parse<Lang>,\n  interpret: Interpreter\n) {\n  return (query: Lang, ...args: unknown[]): Bound<Interpreter> => {\n    const ast = parse(query, ...args);\n    const translate = (interpret as any).bind(null, ast);\n    translate.ast = ast;\n    return translate;\n  };\n}\n","import { ObjectQueryParser } from './parsers/ObjectQueryParser';\n\nexport * from './Condition';\nexport * from './types';\nexport * from './interpreter';\nexport * from './translator';\nexport * from './builder';\nexport {\n  isCompound,\n  hasOperators,\n  identity,\n  object,\n  optimizedCompoundCondition,\n  ignoreValue,\n} from './utils';\nexport type {\n  IgnoreValue\n} from './utils';\nexport * from './parsers/ObjectQueryParser';\nexport * from './parsers/defaultInstructionParsers';\n/**\n * @deprecated use `ObjectQueryParser#parseInstruction` instead\n * TODO(major): remove\n */\nexport const parseInstruction = (ObjectQueryParser.prototype as any).parseInstruction;\n"]},"metadata":{},"sourceType":"module"}