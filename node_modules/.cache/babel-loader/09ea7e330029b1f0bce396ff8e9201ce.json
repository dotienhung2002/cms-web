{"ast":null,"code":"// ** React Imports\nimport { useContext } from 'react';\nimport { AbilityContext } from '@src/utility/context/Can';\n/**\n * Return which component to render based on it's data/context\n * @param {Object} item nav menu item\n */\n\nexport const resolveVerticalNavMenuItemComponent = item => {\n  if (item.header) return 'VerticalNavMenuSectionHeader';\n  if (item.children) return 'VerticalNavMenuGroup';\n  return 'VerticalNavMenuLink';\n};\n/**\n * Return which component to render based on it's data/context\n * @param {Object} item nav menu item\n */\n\nexport const resolveHorizontalNavMenuItemComponent = item => {\n  if (item.children) return 'HorizontalNavMenuGroup';\n  return 'HorizontalNavMenuLink';\n};\n/**\n * Check if nav-link is active\n * @param {Object} link nav-link object\n */\n// export const isNavLinkActive = (link, currentURL, match) => {\n//   // return currentURL === link || (URLParams && Object.keys(URLParams).length && currentURLFilter === item.navLink)\n//   const getFirstObjProp = obj => obj[Object.keys(obj)[0]]\n//   return (\n//     currentURL === link ||\n//     (match !== null && match !== undefined && match.url === `${link}/${getFirstObjProp(match.params)}`)\n//   )\n// }\n\nexport const isNavLinkActive = (link, currentURL, routerProps) => {\n  return currentURL === link || routerProps && routerProps.meta && routerProps.meta.navLink && routerProps.meta.navLink === link; // return currentURL === link\n};\n/**\n * Check if nav group is\n * @param {Array} children Group children\n */\n// export const isNavGroupActive = (children, currentURL, match) => {\n//   return children.some(child => {\n//     // If child have children => It's group => Go deeper(recursive)\n//     if (child.children) {\n//       return isNavGroupActive(child.children, currentURL, match)\n//     }\n//     // else it's link => Check for matched Route\n//     return isNavLinkActive(child.navLink, currentURL, match)\n//   })\n// }\n\nexport const isNavGroupActive = (children, currentURL, routerProps) => {\n  return children.some(child => {\n    // If child have children => It's group => Go deeper(recursive)\n    if (child.children) {\n      return isNavGroupActive(child.children, currentURL, routerProps);\n    } // else it's link => Check for matched Route\n\n\n    return isNavLinkActive(child.navLink, currentURL, routerProps);\n  });\n};\n/**\n * Search for parent object\n * @param {Array} navigation Group children\n * @param {string} currentURL current URL\n */\n// export const search = (navigation, currentURL, match) => {\n//   let result\n//   navigation.some(child => {\n//     let children\n//     // If child have children => It's group => Go deeper(recursive)\n//     if (child.children && (children = search(child.children, currentURL, match))) {\n//       return (result = {\n//         id: child.id,\n//         children\n//       })\n//     }\n//     // else it's link => Check for matched Route\n//     if (isNavLinkActive(child.navLink, currentURL, match)) {\n//       return (result = {\n//         id: child.id\n//       })\n//     }\n//   })\n//   return result\n// }\n\nexport const search = (navigation, currentURL, routerProps) => {\n  let result;\n  navigation.some(child => {\n    let children; // If child have children => It's group => Go deeper(recursive)\n\n    if (child.children && (children = search(child.children, currentURL, routerProps))) {\n      return result = {\n        id: child.id,\n        children\n      };\n    } // else it's link => Check for matched Route\n\n\n    if (isNavLinkActive(child.navLink, currentURL, routerProps)) {\n      return result = {\n        id: child.id\n      };\n    }\n  });\n  return result;\n};\n/**\n * Loop through nested object\n * @param {object} obj nested object\n */\n\nexport const getAllParents = (obj, match) => {\n  const res = [];\n\n  const recurse = (obj, current) => {\n    for (const key in obj) {\n      const value = obj[key];\n\n      if (value !== undefined) {\n        if (value && typeof value === 'object') {\n          recurse(value, key);\n        } else {\n          if (key === match) {\n            res.push(value);\n          }\n        }\n      }\n    }\n  };\n\n  recurse(obj);\n  return res;\n};\nexport const canViewMenuGroup = item => {\n  // const ability = useContext(AbilityContext)\n  // // ! This same logic is used in canViewHorizontalNavMenuGroup and canViewHorizontalNavMenuHeaderGroup. So make sure to update logic in them as well\n  // const hasAnyVisibleChild = item.children && item.children.some(i => ability.can(i.action, i.resource))\n  // // ** If resource and action is defined in item => Return based on children visibility (Hide group if no child is visible)\n  // // ** Else check for ability using provided resource and action along with checking if has any visible child\n  // if (!(item.action && item.resource)) {\n  //   return hasAnyVisibleChild\n  // }\n  // return ability.can(item.action, item.resource) && hasAnyVisibleChild\n  return true;\n};\nexport const canViewMenuItem = item => {\n  // const ability = useContext(AbilityContext)\n  // return ability.can(item.action, item.resource)\n  const userData = JSON.parse(localStorage.getItem('userData') || `{}`);\n  const {\n    permissions\n  } = userData;\n  const arrayPers = !permissions || permissions === '' ? [] : permissions.split(',');\n  const permissionsCheck = item.permissions || [];\n  let check = true; // permissionsCheck.forEach(element => {\n  //   const index = arrayPers.findIndex(el2 => el2 === element)\n  //   if (index !== -1) {\n  //     check = true\n  //   }\n  // });\n\n  return check;\n};","map":{"version":3,"sources":["/Users/abc/Downloads/Workspace/projectFPT/cms-fusamate/cms-fusamate/cms-fusamte/src/@core/layouts/utils.js"],"names":["useContext","AbilityContext","resolveVerticalNavMenuItemComponent","item","header","children","resolveHorizontalNavMenuItemComponent","isNavLinkActive","link","currentURL","routerProps","meta","navLink","isNavGroupActive","some","child","search","navigation","result","id","getAllParents","obj","match","res","recurse","current","key","value","undefined","push","canViewMenuGroup","canViewMenuItem","userData","JSON","parse","localStorage","getItem","permissions","arrayPers","split","permissionsCheck","check"],"mappings":"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","sourcesContent":["// ** React Imports\nimport { useContext } from 'react'\nimport { AbilityContext } from '@src/utility/context/Can'\n\n/**\n * Return which component to render based on it's data/context\n * @param {Object} item nav menu item\n */\nexport const resolveVerticalNavMenuItemComponent = item => {\n  if (item.header) return 'VerticalNavMenuSectionHeader'\n  if (item.children) return 'VerticalNavMenuGroup'\n  return 'VerticalNavMenuLink'\n}\n\n/**\n * Return which component to render based on it's data/context\n * @param {Object} item nav menu item\n */\nexport const resolveHorizontalNavMenuItemComponent = item => {\n  if (item.children) return 'HorizontalNavMenuGroup'\n  return 'HorizontalNavMenuLink'\n}\n\n/**\n * Check if nav-link is active\n * @param {Object} link nav-link object\n */\n// export const isNavLinkActive = (link, currentURL, match) => {\n//   // return currentURL === link || (URLParams && Object.keys(URLParams).length && currentURLFilter === item.navLink)\n//   const getFirstObjProp = obj => obj[Object.keys(obj)[0]]\n//   return (\n//     currentURL === link ||\n//     (match !== null && match !== undefined && match.url === `${link}/${getFirstObjProp(match.params)}`)\n//   )\n// }\n\nexport const isNavLinkActive = (link, currentURL, routerProps) => {\n  return (\n    currentURL === link ||\n    (routerProps && routerProps.meta && routerProps.meta.navLink && routerProps.meta.navLink === link)\n  )\n  // return currentURL === link\n}\n\n/**\n * Check if nav group is\n * @param {Array} children Group children\n */\n// export const isNavGroupActive = (children, currentURL, match) => {\n//   return children.some(child => {\n//     // If child have children => It's group => Go deeper(recursive)\n//     if (child.children) {\n//       return isNavGroupActive(child.children, currentURL, match)\n//     }\n//     // else it's link => Check for matched Route\n//     return isNavLinkActive(child.navLink, currentURL, match)\n//   })\n// }\nexport const isNavGroupActive = (children, currentURL, routerProps) => {\n  return children.some(child => {\n    // If child have children => It's group => Go deeper(recursive)\n    if (child.children) {\n      return isNavGroupActive(child.children, currentURL, routerProps)\n    }\n    // else it's link => Check for matched Route\n    return isNavLinkActive(child.navLink, currentURL, routerProps)\n  })\n}\n\n/**\n * Search for parent object\n * @param {Array} navigation Group children\n * @param {string} currentURL current URL\n */\n// export const search = (navigation, currentURL, match) => {\n//   let result\n//   navigation.some(child => {\n//     let children\n//     // If child have children => It's group => Go deeper(recursive)\n//     if (child.children && (children = search(child.children, currentURL, match))) {\n//       return (result = {\n//         id: child.id,\n//         children\n//       })\n//     }\n\n//     // else it's link => Check for matched Route\n//     if (isNavLinkActive(child.navLink, currentURL, match)) {\n//       return (result = {\n//         id: child.id\n//       })\n//     }\n//   })\n//   return result\n// }\n\nexport const search = (navigation, currentURL, routerProps) => {\n  let result\n  navigation.some(child => {\n    let children\n    // If child have children => It's group => Go deeper(recursive)\n    if (child.children && (children = search(child.children, currentURL, routerProps))) {\n      return (result = {\n        id: child.id,\n        children\n      })\n    }\n\n    // else it's link => Check for matched Route\n    if (isNavLinkActive(child.navLink, currentURL, routerProps)) {\n      return (result = {\n        id: child.id\n      })\n    }\n  })\n  return result\n}\n\n/**\n * Loop through nested object\n * @param {object} obj nested object\n */\nexport const getAllParents = (obj, match) => {\n  const res = []\n  const recurse = (obj, current) => {\n    for (const key in obj) {\n      const value = obj[key]\n      if (value !== undefined) {\n        if (value && typeof value === 'object') {\n          recurse(value, key)\n        } else {\n          if (key === match) {\n            res.push(value)\n          }\n        }\n      }\n    }\n  }\n  recurse(obj)\n  return res\n}\n\nexport const canViewMenuGroup = item => {\n  // const ability = useContext(AbilityContext)\n  // // ! This same logic is used in canViewHorizontalNavMenuGroup and canViewHorizontalNavMenuHeaderGroup. So make sure to update logic in them as well\n  // const hasAnyVisibleChild = item.children && item.children.some(i => ability.can(i.action, i.resource))\n\n  // // ** If resource and action is defined in item => Return based on children visibility (Hide group if no child is visible)\n  // // ** Else check for ability using provided resource and action along with checking if has any visible child\n  // if (!(item.action && item.resource)) {\n  //   return hasAnyVisibleChild\n  // }\n  // return ability.can(item.action, item.resource) && hasAnyVisibleChild\n  return true\n}\n\nexport const canViewMenuItem = item => {\n  // const ability = useContext(AbilityContext)\n  // return ability.can(item.action, item.resource)\n  const userData = JSON.parse(localStorage.getItem('userData') || `{}`)\n  const { permissions } = userData\n\n  const arrayPers = !permissions || permissions === '' ? [] : permissions.split(',')\n  const permissionsCheck = item.permissions || []\n  let check = true\n  // permissionsCheck.forEach(element => {\n  //   const index = arrayPers.findIndex(el2 => el2 === element)\n  //   if (index !== -1) {\n  //     check = true\n  //   }\n  // });\n\n  return check\n}\n"]},"metadata":{},"sourceType":"module"}