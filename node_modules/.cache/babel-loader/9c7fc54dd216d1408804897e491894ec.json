{"ast":null,"code":"import _isEqual from \"lodash/isEqual\";\nimport _sortBy from \"lodash/sortBy\";\nimport _isNaN from \"lodash/isNaN\";\nimport _upperFirst from \"lodash/upperFirst\";\nimport _isString from \"lodash/isString\";\nimport _isArray from \"lodash/isArray\";\nimport _max from \"lodash/max\";\nimport _min from \"lodash/min\";\nimport _flatMap from \"lodash/flatMap\";\nimport _isFunction from \"lodash/isFunction\";\nimport _get from \"lodash/get\";\nimport _isNil from \"lodash/isNil\";\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nimport { getNiceTickValues, getTickValuesFixedDomain } from 'recharts-scale';\nimport * as d3Scales from 'd3-scale';\nimport { stack as shapeStack, stackOrderNone, stackOffsetExpand, stackOffsetNone, stackOffsetSilhouette, stackOffsetWiggle } from 'd3-shape';\nimport { isNumOrStr, uniqueId, isNumber, getPercentValue, mathSign, findEntryInArray } from './DataUtils';\nimport { Legend } from '../component/Legend';\nimport { findAllByType, findChildByType, getDisplayName } from './ReactUtils'; // TODO: Cause of circular dependency. Needs refactor.\n// import { RadiusAxisProps, AngleAxisProps } from '../polar/types';\n\nexport function getValueByDataKey(obj, dataKey, defaultValue) {\n  if (_isNil(obj) || _isNil(dataKey)) {\n    return defaultValue;\n  }\n  if (isNumOrStr(dataKey)) {\n    return _get(obj, dataKey, defaultValue);\n  }\n  if (_isFunction(dataKey)) {\n    return dataKey(obj);\n  }\n  return defaultValue;\n}\n/**\n * Get domain of data by key\n * @param  {Array}   data      The data displayed in the chart\n * @param  {String}  key       The unique key of a group of data\n * @param  {String}  type      The type of axis\n * @param  {Boolean} filterNil Whether or not filter nil values\n * @return {Array} Domain of data\n */\n\nexport function getDomainOfDataByKey(data, key, type, filterNil) {\n  var flattenData = _flatMap(data, function (entry) {\n    return getValueByDataKey(entry, key);\n  });\n  if (type === 'number') {\n    var domain = flattenData.filter(function (entry) {\n      return isNumber(entry) || parseFloat(entry);\n    });\n    return domain.length ? [_min(domain), _max(domain)] : [Infinity, -Infinity];\n  }\n  var validateData = filterNil ? flattenData.filter(function (entry) {\n    return !_isNil(entry);\n  }) : flattenData; // 支持Date类型的x轴\n\n  return validateData.map(function (entry) {\n    return isNumOrStr(entry) || entry instanceof Date ? entry : '';\n  });\n}\nexport var calculateActiveTickIndex = function calculateActiveTickIndex(coordinate) {\n  var _ticks$length;\n  var ticks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var unsortedTicks = arguments.length > 2 ? arguments[2] : undefined;\n  var axis = arguments.length > 3 ? arguments[3] : undefined;\n  var index = -1;\n  var len = (_ticks$length = ticks === null || ticks === void 0 ? void 0 : ticks.length) !== null && _ticks$length !== void 0 ? _ticks$length : 0;\n  if (len > 1) {\n    if (axis && axis.axisType === 'angleAxis' && Math.abs(Math.abs(axis.range[1] - axis.range[0]) - 360) <= 1e-6) {\n      var range = axis.range; // ticks are distributed in a circle\n\n      for (var i = 0; i < len; i++) {\n        var before = i > 0 ? unsortedTicks[i - 1].coordinate : unsortedTicks[len - 1].coordinate;\n        var cur = unsortedTicks[i].coordinate;\n        var after = i >= len - 1 ? unsortedTicks[0].coordinate : unsortedTicks[i + 1].coordinate;\n        var sameDirectionCoord = void 0;\n        if (mathSign(cur - before) !== mathSign(after - cur)) {\n          var diffInterval = [];\n          if (mathSign(after - cur) === mathSign(range[1] - range[0])) {\n            sameDirectionCoord = after;\n            var curInRange = cur + range[1] - range[0];\n            diffInterval[0] = Math.min(curInRange, (curInRange + before) / 2);\n            diffInterval[1] = Math.max(curInRange, (curInRange + before) / 2);\n          } else {\n            sameDirectionCoord = before;\n            var afterInRange = after + range[1] - range[0];\n            diffInterval[0] = Math.min(cur, (afterInRange + cur) / 2);\n            diffInterval[1] = Math.max(cur, (afterInRange + cur) / 2);\n          }\n          var sameInterval = [Math.min(cur, (sameDirectionCoord + cur) / 2), Math.max(cur, (sameDirectionCoord + cur) / 2)];\n          if (coordinate > sameInterval[0] && coordinate <= sameInterval[1] || coordinate >= diffInterval[0] && coordinate <= diffInterval[1]) {\n            index = unsortedTicks[i].index;\n            break;\n          }\n        } else {\n          var min = Math.min(before, after);\n          var max = Math.max(before, after);\n          if (coordinate > (min + cur) / 2 && coordinate <= (max + cur) / 2) {\n            index = unsortedTicks[i].index;\n            break;\n          }\n        }\n      }\n    } else {\n      // ticks are distributed in a single direction\n      for (var _i = 0; _i < len; _i++) {\n        if (_i === 0 && coordinate <= (ticks[_i].coordinate + ticks[_i + 1].coordinate) / 2 || _i > 0 && _i < len - 1 && coordinate > (ticks[_i].coordinate + ticks[_i - 1].coordinate) / 2 && coordinate <= (ticks[_i].coordinate + ticks[_i + 1].coordinate) / 2 || _i === len - 1 && coordinate > (ticks[_i].coordinate + ticks[_i - 1].coordinate) / 2) {\n          index = ticks[_i].index;\n          break;\n        }\n      }\n    }\n  } else {\n    index = 0;\n  }\n  return index;\n};\n/**\n * Get the main color of each graphic item\n * @param  {ReactElement} item A graphic item\n * @return {String}            Color\n */\n\nexport var getMainColorOfGraphicItem = function getMainColorOfGraphicItem(item) {\n  var _ref = item,\n    displayName = _ref.type.displayName; // TODO: check if displayName is valid.\n\n  var _item$props = item.props,\n    stroke = _item$props.stroke,\n    fill = _item$props.fill;\n  var result;\n  switch (displayName) {\n    case 'Line':\n      result = stroke;\n      break;\n    case 'Area':\n    case 'Radar':\n      result = stroke && stroke !== 'none' ? stroke : fill;\n      break;\n    default:\n      result = fill;\n      break;\n  }\n  return result;\n}; // TODO: Formated -> Formatted.\n\nexport var getLegendProps = function getLegendProps(_ref2) {\n  var children = _ref2.children,\n    formatedGraphicalItems = _ref2.formatedGraphicalItems,\n    legendWidth = _ref2.legendWidth,\n    legendContent = _ref2.legendContent;\n  var legendItem = findChildByType(children, Legend.displayName);\n  if (!legendItem) {\n    return null;\n  }\n  var legendData;\n  if (legendItem.props && legendItem.props.payload) {\n    legendData = legendItem.props && legendItem.props.payload;\n  } else if (legendContent === 'children') {\n    legendData = (formatedGraphicalItems || []).reduce(function (result, _ref3) {\n      var item = _ref3.item,\n        props = _ref3.props;\n      var data = props.sectors || props.data || [];\n      return result.concat(data.map(function (entry) {\n        return {\n          type: legendItem.props.iconType || item.props.legendType,\n          value: entry.name,\n          color: entry.fill,\n          payload: entry\n        };\n      }));\n    }, []);\n  } else {\n    legendData = (formatedGraphicalItems || []).map(function (_ref4) {\n      var item = _ref4.item;\n      var _item$props2 = item.props,\n        dataKey = _item$props2.dataKey,\n        name = _item$props2.name,\n        legendType = _item$props2.legendType,\n        hide = _item$props2.hide;\n      return {\n        inactive: hide,\n        dataKey: dataKey,\n        type: legendItem.props.iconType || legendType || 'square',\n        color: getMainColorOfGraphicItem(item),\n        value: name || dataKey,\n        payload: item.props\n      };\n    });\n  }\n  return _objectSpread(_objectSpread(_objectSpread({}, legendItem.props), Legend.getWithHeight(legendItem, legendWidth)), {}, {\n    payload: legendData,\n    item: legendItem\n  });\n};\n/**\n * Calculate the size of all groups for stacked bar graph\n * @param  {Object} stackGroups The items grouped by axisId and stackId\n * @return {Object} The size of all groups\n */\n\nexport var getBarSizeList = function getBarSizeList(_ref5) {\n  var globalSize = _ref5.barSize,\n    _ref5$stackGroups = _ref5.stackGroups,\n    stackGroups = _ref5$stackGroups === void 0 ? {} : _ref5$stackGroups;\n  if (!stackGroups) {\n    return {};\n  }\n  var result = {};\n  var numericAxisIds = Object.keys(stackGroups);\n  for (var i = 0, len = numericAxisIds.length; i < len; i++) {\n    var sgs = stackGroups[numericAxisIds[i]].stackGroups;\n    var stackIds = Object.keys(sgs);\n    for (var j = 0, sLen = stackIds.length; j < sLen; j++) {\n      var _sgs$stackIds$j = sgs[stackIds[j]],\n        items = _sgs$stackIds$j.items,\n        cateAxisId = _sgs$stackIds$j.cateAxisId;\n      var barItems = items.filter(function (item) {\n        return getDisplayName(item.type).indexOf('Bar') >= 0;\n      });\n      if (barItems && barItems.length) {\n        var selfSize = barItems[0].props.barSize;\n        var cateId = barItems[0].props[cateAxisId];\n        if (!result[cateId]) {\n          result[cateId] = [];\n        }\n        result[cateId].push({\n          item: barItems[0],\n          stackList: barItems.slice(1),\n          barSize: _isNil(selfSize) ? globalSize : selfSize\n        });\n      }\n    }\n  }\n  return result;\n};\n/**\n * Calculate the size of each bar and the gap between two bars\n * @param  {Number} bandSize  The size of each category\n * @param  {sizeList} sizeList  The size of all groups\n * @param  {maxBarSize} maxBarSize The maximum size of bar\n * @return {Number} The size of each bar and the gap between two bars\n */\n\nexport var getBarPosition = function getBarPosition(_ref6) {\n  var barGap = _ref6.barGap,\n    barCategoryGap = _ref6.barCategoryGap,\n    bandSize = _ref6.bandSize,\n    _ref6$sizeList = _ref6.sizeList,\n    sizeList = _ref6$sizeList === void 0 ? [] : _ref6$sizeList,\n    maxBarSize = _ref6.maxBarSize;\n  var len = sizeList.length;\n  if (len < 1) return null;\n  var realBarGap = getPercentValue(barGap, bandSize, 0, true);\n  var result; // whether or not is barSize setted by user\n\n  if (sizeList[0].barSize === +sizeList[0].barSize) {\n    var useFull = false;\n    var fullBarSize = bandSize / len;\n    var sum = sizeList.reduce(function (res, entry) {\n      return res + entry.barSize || 0;\n    }, 0);\n    sum += (len - 1) * realBarGap;\n    if (sum >= bandSize) {\n      sum -= (len - 1) * realBarGap;\n      realBarGap = 0;\n    }\n    if (sum >= bandSize && fullBarSize > 0) {\n      useFull = true;\n      fullBarSize *= 0.9;\n      sum = len * fullBarSize;\n    }\n    var offset = (bandSize - sum) / 2 >> 0;\n    var prev = {\n      offset: offset - realBarGap,\n      size: 0\n    };\n    result = sizeList.reduce(function (res, entry) {\n      var newRes = [].concat(_toConsumableArray(res), [{\n        item: entry.item,\n        position: {\n          offset: prev.offset + prev.size + realBarGap,\n          size: useFull ? fullBarSize : entry.barSize\n        }\n      }]);\n      prev = newRes[newRes.length - 1].position;\n      if (entry.stackList && entry.stackList.length) {\n        entry.stackList.forEach(function (item) {\n          newRes.push({\n            item: item,\n            position: prev\n          });\n        });\n      }\n      return newRes;\n    }, []);\n  } else {\n    var _offset = getPercentValue(barCategoryGap, bandSize, 0, true);\n    if (bandSize - 2 * _offset - (len - 1) * realBarGap <= 0) {\n      realBarGap = 0;\n    }\n    var originalSize = (bandSize - 2 * _offset - (len - 1) * realBarGap) / len;\n    if (originalSize > 1) {\n      originalSize >>= 0;\n    }\n    var size = maxBarSize === +maxBarSize ? Math.min(originalSize, maxBarSize) : originalSize;\n    result = sizeList.reduce(function (res, entry, i) {\n      var newRes = [].concat(_toConsumableArray(res), [{\n        item: entry.item,\n        position: {\n          offset: _offset + (originalSize + realBarGap) * i + (originalSize - size) / 2,\n          size: size\n        }\n      }]);\n      if (entry.stackList && entry.stackList.length) {\n        entry.stackList.forEach(function (item) {\n          newRes.push({\n            item: item,\n            position: newRes[newRes.length - 1].position\n          });\n        });\n      }\n      return newRes;\n    }, []);\n  }\n  return result;\n};\nexport var appendOffsetOfLegend = function appendOffsetOfLegend(offset, items, props, legendBox) {\n  var children = props.children,\n    width = props.width,\n    margin = props.margin;\n  var legendWidth = width - (margin.left || 0) - (margin.right || 0); // const legendHeight = height - (margin.top || 0) - (margin.bottom || 0);\n\n  var legendProps = getLegendProps({\n    children: children,\n    legendWidth: legendWidth\n  });\n  var newOffset = offset;\n  if (legendProps) {\n    var box = legendBox || {};\n    var align = legendProps.align,\n      verticalAlign = legendProps.verticalAlign,\n      layout = legendProps.layout;\n    if ((layout === 'vertical' || layout === 'horizontal' && verticalAlign === 'center') && isNumber(offset[align])) {\n      newOffset = _objectSpread(_objectSpread({}, offset), {}, _defineProperty({}, align, newOffset[align] + (box.width || 0)));\n    }\n    if ((layout === 'horizontal' || layout === 'vertical' && align === 'center') && isNumber(offset[verticalAlign])) {\n      newOffset = _objectSpread(_objectSpread({}, offset), {}, _defineProperty({}, verticalAlign, newOffset[verticalAlign] + (box.height || 0)));\n    }\n  }\n  return newOffset;\n};\nexport var getDomainOfErrorBars = function getDomainOfErrorBars(data, item, dataKey, axisType) {\n  var children = item.props.children;\n  var errorBars = findAllByType(children, 'ErrorBar').filter(function (errorBarChild) {\n    var direction = errorBarChild.props.direction;\n    return _isNil(direction) || _isNil(axisType) ? true : axisType.indexOf(direction) >= 0;\n  });\n  if (errorBars && errorBars.length) {\n    var keys = errorBars.map(function (errorBarChild) {\n      return errorBarChild.props.dataKey;\n    });\n    return data.reduce(function (result, entry) {\n      var entryValue = getValueByDataKey(entry, dataKey, 0);\n      var mainValue = _isArray(entryValue) ? [_min(entryValue), _max(entryValue)] : [entryValue, entryValue];\n      var errorDomain = keys.reduce(function (prevErrorArr, k) {\n        var errorValue = getValueByDataKey(entry, k, 0);\n        var lowerValue = mainValue[0] - Math.abs(_isArray(errorValue) ? errorValue[0] : errorValue);\n        var upperValue = mainValue[1] + Math.abs(_isArray(errorValue) ? errorValue[1] : errorValue);\n        return [Math.min(lowerValue, prevErrorArr[0]), Math.max(upperValue, prevErrorArr[1])];\n      }, [Infinity, -Infinity]);\n      return [Math.min(errorDomain[0], result[0]), Math.max(errorDomain[1], result[1])];\n    }, [Infinity, -Infinity]);\n  }\n  return null;\n};\nexport var parseErrorBarsOfAxis = function parseErrorBarsOfAxis(data, items, dataKey, axisType) {\n  var domains = items.map(function (item) {\n    return getDomainOfErrorBars(data, item, dataKey, axisType);\n  }).filter(function (entry) {\n    return !_isNil(entry);\n  });\n  if (domains && domains.length) {\n    return domains.reduce(function (result, entry) {\n      return [Math.min(result[0], entry[0]), Math.max(result[1], entry[1])];\n    }, [Infinity, -Infinity]);\n  }\n  return null;\n};\n/**\n * Get domain of data by the configuration of item element\n * @param  {Array}   data      The data displayed in the chart\n * @param  {Array}   items     The instances of item\n * @param  {String}  type      The type of axis, number - Number Axis, category - Category Axis\n * @param  {Boolean} filterNil Whether or not filter nil values\n * @return {Array}        Domain\n */\n\nexport var getDomainOfItemsWithSameAxis = function getDomainOfItemsWithSameAxis(data, items, type, filterNil) {\n  var domains = items.map(function (item) {\n    var dataKey = item.props.dataKey;\n    if (type === 'number' && dataKey) {\n      return getDomainOfErrorBars(data, item, dataKey) || getDomainOfDataByKey(data, dataKey, type, filterNil);\n    }\n    return getDomainOfDataByKey(data, dataKey, type, filterNil);\n  });\n  if (type === 'number') {\n    // Calculate the domain of number axis\n    return domains.reduce(function (result, entry) {\n      return [Math.min(result[0], entry[0]), Math.max(result[1], entry[1])];\n    }, [Infinity, -Infinity]);\n  }\n  var tag = {}; // Get the union set of category axis\n\n  return domains.reduce(function (result, entry) {\n    for (var i = 0, len = entry.length; i < len; i++) {\n      if (!tag[entry[i]]) {\n        tag[entry[i]] = true;\n        result.push(entry[i]);\n      }\n    }\n    return result;\n  }, []);\n};\nexport var isCategoricalAxis = function isCategoricalAxis(layout, axisType) {\n  return layout === 'horizontal' && axisType === 'xAxis' || layout === 'vertical' && axisType === 'yAxis' || layout === 'centric' && axisType === 'angleAxis' || layout === 'radial' && axisType === 'radiusAxis';\n};\n/**\n * Calculate the Coordinates of grid\n * @param  {Array} ticks The ticks in axis\n * @param {Number} min   The minimun value of axis\n * @param {Number} max   The maximun value of axis\n * @return {Array}       Coordinates\n */\n\nexport var getCoordinatesOfGrid = function getCoordinatesOfGrid(ticks, min, max) {\n  var hasMin, hasMax;\n  var values = ticks.map(function (entry) {\n    if (entry.coordinate === min) {\n      hasMin = true;\n    }\n    if (entry.coordinate === max) {\n      hasMax = true;\n    }\n    return entry.coordinate;\n  });\n  if (!hasMin) {\n    values.push(min);\n  }\n  if (!hasMax) {\n    values.push(max);\n  }\n  return values;\n};\n/**\n * Get the ticks of an axis\n * @param  {Object}  axis The configuration of an axis\n * @param {Boolean} isGrid Whether or not are the ticks in grid\n * @param {Boolean} isAll Return the ticks of all the points or not\n * @return {Array}  Ticks\n */\n\nexport var getTicksOfAxis = function getTicksOfAxis(axis, isGrid, isAll) {\n  if (!axis) return null;\n  var scale = axis.scale;\n  var duplicateDomain = axis.duplicateDomain,\n    type = axis.type,\n    range = axis.range;\n  var offset = (isGrid || isAll) && type === 'category' && scale.bandwidth ? scale.bandwidth() / 2 : 0;\n  offset = axis.axisType === 'angleAxis' ? mathSign(range[0] - range[1]) * 2 * offset : offset; // The ticks setted by user should only affect the ticks adjacent to axis line\n\n  if (isGrid && (axis.ticks || axis.niceTicks)) {\n    return (axis.ticks || axis.niceTicks).map(function (entry) {\n      var scaleContent = duplicateDomain ? duplicateDomain.indexOf(entry) : entry;\n      return {\n        coordinate: scale(scaleContent) + offset,\n        value: entry,\n        offset: offset\n      };\n    });\n  } // When axis is a categorial axis, but the type of axis is number or the scale of axis is not \"auto\"\n\n  if (axis.isCategorical && axis.categoricalDomain) {\n    return axis.categoricalDomain.map(function (entry, index) {\n      return {\n        coordinate: scale(entry) + offset,\n        value: entry,\n        index: index,\n        offset: offset\n      };\n    });\n  }\n  if (scale.ticks && !isAll) {\n    return scale.ticks(axis.tickCount).map(function (entry) {\n      return {\n        coordinate: scale(entry) + offset,\n        value: entry,\n        offset: offset\n      };\n    });\n  } // When axis has duplicated text, serial numbers are used to generate scale\n\n  return scale.domain().map(function (entry, index) {\n    return {\n      coordinate: scale(entry) + offset,\n      value: duplicateDomain ? duplicateDomain[entry] : entry,\n      index: index,\n      offset: offset\n    };\n  });\n};\n/**\n * combine the handlers\n * @param  {Function} defaultHandler Internal private handler\n * @param  {Function} parentHandler  Handler function specified in parent component\n * @param  {Function} childHandler   Handler function specified in child component\n * @return {Function}                The combined handler\n */\n\nexport var combineEventHandlers = function combineEventHandlers(defaultHandler, parentHandler, childHandler) {\n  var customizedHandler;\n  if (_isFunction(childHandler)) {\n    customizedHandler = childHandler;\n  } else if (_isFunction(parentHandler)) {\n    customizedHandler = parentHandler;\n  }\n  if (_isFunction(defaultHandler) || customizedHandler) {\n    return function (arg1, arg2, arg3, arg4) {\n      if (_isFunction(defaultHandler)) {\n        defaultHandler(arg1, arg2, arg3, arg4);\n      }\n      if (_isFunction(customizedHandler)) {\n        customizedHandler(arg1, arg2, arg3, arg4);\n      }\n    };\n  }\n  return null;\n};\n/**\n * Parse the scale function of axis\n * @param  {Object}   axis          The option of axis\n * @param  {String}   chartType     The displayName of chart\n * @return {Function}               The scale funcion\n */\n\nexport var parseScale = function parseScale(axis, chartType) {\n  var scale = axis.scale,\n    type = axis.type,\n    layout = axis.layout,\n    axisType = axis.axisType;\n  if (scale === 'auto') {\n    if (layout === 'radial' && axisType === 'radiusAxis') {\n      return {\n        scale: d3Scales.scaleBand(),\n        realScaleType: 'band'\n      };\n    }\n    if (layout === 'radial' && axisType === 'angleAxis') {\n      return {\n        scale: d3Scales.scaleLinear(),\n        realScaleType: 'linear'\n      };\n    }\n    if (type === 'category' && chartType && (chartType.indexOf('LineChart') >= 0 || chartType.indexOf('AreaChart') >= 0 || chartType.indexOf('ComposedChart') >= 0)) {\n      return {\n        scale: d3Scales.scalePoint(),\n        realScaleType: 'point'\n      };\n    }\n    if (type === 'category') {\n      return {\n        scale: d3Scales.scaleBand(),\n        realScaleType: 'band'\n      };\n    }\n    return {\n      scale: d3Scales.scaleLinear(),\n      realScaleType: 'linear'\n    };\n  }\n  if (_isString(scale)) {\n    var name = \"scale\".concat(_upperFirst(scale));\n    return {\n      scale: (d3Scales[name] || d3Scales.scalePoint)(),\n      realScaleType: d3Scales[name] ? name : 'point'\n    };\n  }\n  return _isFunction(scale) ? {\n    scale: scale\n  } : {\n    scale: d3Scales.scalePoint(),\n    realScaleType: 'point'\n  };\n};\nvar EPS = 1e-4;\nexport var checkDomainOfScale = function checkDomainOfScale(scale) {\n  var domain = scale.domain();\n  if (!domain || domain.length <= 2) {\n    return;\n  }\n  var len = domain.length;\n  var range = scale.range();\n  var min = Math.min(range[0], range[1]) - EPS;\n  var max = Math.max(range[0], range[1]) + EPS;\n  var first = scale(domain[0]);\n  var last = scale(domain[len - 1]);\n  if (first < min || first > max || last < min || last > max) {\n    scale.domain([domain[0], domain[len - 1]]);\n  }\n};\nexport var findPositionOfBar = function findPositionOfBar(barPosition, child) {\n  if (!barPosition) {\n    return null;\n  }\n  for (var i = 0, len = barPosition.length; i < len; i++) {\n    if (barPosition[i].item === child) {\n      return barPosition[i].position;\n    }\n  }\n  return null;\n};\nexport var truncateByDomain = function truncateByDomain(value, domain) {\n  if (!domain || domain.length !== 2 || !isNumber(domain[0]) || !isNumber(domain[1])) {\n    return value;\n  }\n  var min = Math.min(domain[0], domain[1]);\n  var max = Math.max(domain[0], domain[1]);\n  var result = [value[0], value[1]];\n  if (!isNumber(value[0]) || value[0] < min) {\n    result[0] = min;\n  }\n  if (!isNumber(value[1]) || value[1] > max) {\n    result[1] = max;\n  }\n  if (result[0] > max) {\n    result[0] = max;\n  }\n  if (result[1] < min) {\n    result[1] = min;\n  }\n  return result;\n};\n/* eslint no-param-reassign: 0 */\n\nexport var offsetSign = function offsetSign(series) {\n  var n = series.length;\n  if (n <= 0) {\n    return;\n  }\n  for (var j = 0, m = series[0].length; j < m; ++j) {\n    var positive = 0;\n    var negative = 0;\n    for (var i = 0; i < n; ++i) {\n      var value = _isNaN(series[i][j][1]) ? series[i][j][0] : series[i][j][1];\n      /* eslint-disable prefer-destructuring */\n\n      if (value >= 0) {\n        series[i][j][0] = positive;\n        series[i][j][1] = positive + value;\n        positive = series[i][j][1];\n      } else {\n        series[i][j][0] = negative;\n        series[i][j][1] = negative + value;\n        negative = series[i][j][1];\n      }\n      /* eslint-enable prefer-destructuring */\n    }\n  }\n};\n/* eslint no-param-reassign: 0 */\n\nexport var offsetPositive = function offsetPositive(series) {\n  var n = series.length;\n  if (n <= 0) {\n    return;\n  }\n  for (var j = 0, m = series[0].length; j < m; ++j) {\n    var positive = 0;\n    for (var i = 0; i < n; ++i) {\n      var value = _isNaN(series[i][j][1]) ? series[i][j][0] : series[i][j][1];\n      /* eslint-disable prefer-destructuring */\n\n      if (value >= 0) {\n        series[i][j][0] = positive;\n        series[i][j][1] = positive + value;\n        positive = series[i][j][1];\n      } else {\n        series[i][j][0] = 0;\n        series[i][j][1] = 0;\n      }\n      /* eslint-enable prefer-destructuring */\n    }\n  }\n};\n\nvar STACK_OFFSET_MAP = {\n  sign: offsetSign,\n  expand: stackOffsetExpand,\n  none: stackOffsetNone,\n  silhouette: stackOffsetSilhouette,\n  wiggle: stackOffsetWiggle,\n  positive: offsetPositive\n};\nexport var getStackedData = function getStackedData(data, stackItems, offsetType) {\n  var dataKeys = stackItems.map(function (item) {\n    return item.props.dataKey;\n  });\n  var stack = shapeStack().keys(dataKeys).value(function (d, key) {\n    return +getValueByDataKey(d, key, 0);\n  }).order(stackOrderNone).offset(STACK_OFFSET_MAP[offsetType]);\n  return stack(data);\n};\nexport var getStackGroupsByAxisId = function getStackGroupsByAxisId(data, _items, numericAxisId, cateAxisId, offsetType, reverseStackOrder) {\n  if (!data) {\n    return null;\n  } // reversing items to affect render order (for layering)\n\n  var items = reverseStackOrder ? _items.reverse() : _items;\n  var stackGroups = items.reduce(function (result, item) {\n    var _item$props3 = item.props,\n      stackId = _item$props3.stackId,\n      hide = _item$props3.hide;\n    if (hide) {\n      return result;\n    }\n    var axisId = item.props[numericAxisId];\n    var parentGroup = result[axisId] || {\n      hasStack: false,\n      stackGroups: {}\n    };\n    if (isNumOrStr(stackId)) {\n      var childGroup = parentGroup.stackGroups[stackId] || {\n        numericAxisId: numericAxisId,\n        cateAxisId: cateAxisId,\n        items: []\n      };\n      childGroup.items.push(item);\n      parentGroup.hasStack = true;\n      parentGroup.stackGroups[stackId] = childGroup;\n    } else {\n      parentGroup.stackGroups[uniqueId('_stackId_')] = {\n        numericAxisId: numericAxisId,\n        cateAxisId: cateAxisId,\n        items: [item]\n      };\n    }\n    return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, axisId, parentGroup));\n  }, {});\n  return Object.keys(stackGroups).reduce(function (result, axisId) {\n    var group = stackGroups[axisId];\n    if (group.hasStack) {\n      group.stackGroups = Object.keys(group.stackGroups).reduce(function (res, stackId) {\n        var g = group.stackGroups[stackId];\n        return _objectSpread(_objectSpread({}, res), {}, _defineProperty({}, stackId, {\n          numericAxisId: numericAxisId,\n          cateAxisId: cateAxisId,\n          items: g.items,\n          stackedData: getStackedData(data, g.items, offsetType)\n        }));\n      }, {});\n    }\n    return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, axisId, group));\n  }, {});\n};\n/**\n * get domain of ticks\n * @param  {Array} ticks Ticks of axis\n * @param  {String} type  The type of axis\n * @return {Array} domain\n */\n\nexport var calculateDomainOfTicks = function calculateDomainOfTicks(ticks, type) {\n  if (type === 'number') {\n    return [_min(ticks), _max(ticks)];\n  }\n  return ticks;\n};\n/**\n * Configure the scale function of axis\n * @param {Object} scale The scale function\n * @param {Object} opts  The configuration of axis\n * @return {Object}      null\n */\n\nexport var getTicksOfScale = function getTicksOfScale(scale, opts) {\n  var realScaleType = opts.realScaleType,\n    type = opts.type,\n    tickCount = opts.tickCount,\n    originalDomain = opts.originalDomain,\n    allowDecimals = opts.allowDecimals;\n  var scaleType = realScaleType || opts.scale;\n  if (scaleType !== 'auto' && scaleType !== 'linear') {\n    return null;\n  }\n  if (tickCount && type === 'number' && originalDomain && (originalDomain[0] === 'auto' || originalDomain[1] === 'auto')) {\n    // Calculate the ticks by the number of grid when the axis is a number axis\n    var domain = scale.domain();\n    if (!domain.length) {\n      return null;\n    }\n    var tickValues = getNiceTickValues(domain, tickCount, allowDecimals);\n    scale.domain(calculateDomainOfTicks(tickValues, type));\n    return {\n      niceTicks: tickValues\n    };\n  }\n  if (tickCount && type === 'number') {\n    var _domain = scale.domain();\n    var _tickValues = getTickValuesFixedDomain(_domain, tickCount, allowDecimals);\n    return {\n      niceTicks: _tickValues\n    };\n  }\n  return null;\n};\nexport var getCateCoordinateOfLine = function getCateCoordinateOfLine(_ref7) {\n  var axis = _ref7.axis,\n    ticks = _ref7.ticks,\n    bandSize = _ref7.bandSize,\n    entry = _ref7.entry,\n    index = _ref7.index,\n    dataKey = _ref7.dataKey;\n  if (axis.type === 'category') {\n    // find coordinate of category axis by the value of category\n    if (!axis.allowDuplicatedCategory && axis.dataKey && !_isNil(entry[axis.dataKey])) {\n      var matchedTick = findEntryInArray(ticks, 'value', entry[axis.dataKey]);\n      if (matchedTick) {\n        return matchedTick.coordinate + bandSize / 2;\n      }\n    }\n    return ticks[index] ? ticks[index].coordinate + bandSize / 2 : null;\n  }\n  var value = getValueByDataKey(entry, !_isNil(dataKey) ? dataKey : axis.dataKey);\n  return !_isNil(value) ? axis.scale(value) : null;\n};\nexport var getCateCoordinateOfBar = function getCateCoordinateOfBar(_ref8) {\n  var axis = _ref8.axis,\n    ticks = _ref8.ticks,\n    offset = _ref8.offset,\n    bandSize = _ref8.bandSize,\n    entry = _ref8.entry,\n    index = _ref8.index;\n  if (axis.type === 'category') {\n    return ticks[index] ? ticks[index].coordinate + offset : null;\n  }\n  var value = getValueByDataKey(entry, axis.dataKey, axis.domain[index]);\n  return !_isNil(value) ? axis.scale(value) - bandSize / 2 + offset : null;\n};\nexport var getBaseValueOfBar = function getBaseValueOfBar(_ref9) {\n  var numericAxis = _ref9.numericAxis;\n  var domain = numericAxis.scale.domain();\n  if (numericAxis.type === 'number') {\n    var min = Math.min(domain[0], domain[1]);\n    var max = Math.max(domain[0], domain[1]);\n    if (min <= 0 && max >= 0) {\n      return 0;\n    }\n    if (max < 0) {\n      return max;\n    }\n    return min;\n  }\n  return domain[0];\n};\nexport var getStackedDataOfItem = function getStackedDataOfItem(item, stackGroups) {\n  var stackId = item.props.stackId;\n  if (isNumOrStr(stackId)) {\n    var group = stackGroups[stackId];\n    if (group && group.items.length) {\n      var itemIndex = -1;\n      for (var i = 0, len = group.items.length; i < len; i++) {\n        if (group.items[i] === item) {\n          itemIndex = i;\n          break;\n        }\n      }\n      return itemIndex >= 0 ? group.stackedData[itemIndex] : null;\n    }\n  }\n  return null;\n};\nvar getDomainOfSingle = function getDomainOfSingle(data) {\n  return data.reduce(function (result, entry) {\n    return [_min(entry.concat([result[0]]).filter(isNumber)), _max(entry.concat([result[1]]).filter(isNumber))];\n  }, [Infinity, -Infinity]);\n};\nexport var getDomainOfStackGroups = function getDomainOfStackGroups(stackGroups, startIndex, endIndex) {\n  return Object.keys(stackGroups).reduce(function (result, stackId) {\n    var group = stackGroups[stackId];\n    var stackedData = group.stackedData;\n    var domain = stackedData.reduce(function (res, entry) {\n      var s = getDomainOfSingle(entry.slice(startIndex, endIndex + 1));\n      return [Math.min(res[0], s[0]), Math.max(res[1], s[1])];\n    }, [Infinity, -Infinity]);\n    return [Math.min(domain[0], result[0]), Math.max(domain[1], result[1])];\n  }, [Infinity, -Infinity]).map(function (result) {\n    return result === Infinity || result === -Infinity ? 0 : result;\n  });\n};\nexport var MIN_VALUE_REG = /^dataMin[\\s]*-[\\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;\nexport var MAX_VALUE_REG = /^dataMax[\\s]*\\+[\\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;\nexport var parseSpecifiedDomain = function parseSpecifiedDomain(specifiedDomain, dataDomain, allowDataOverflow) {\n  if (!_isArray(specifiedDomain)) {\n    return dataDomain;\n  }\n  var domain = [];\n  /* eslint-disable prefer-destructuring */\n\n  if (isNumber(specifiedDomain[0])) {\n    domain[0] = allowDataOverflow ? specifiedDomain[0] : Math.min(specifiedDomain[0], dataDomain[0]);\n  } else if (MIN_VALUE_REG.test(specifiedDomain[0])) {\n    var value = +MIN_VALUE_REG.exec(specifiedDomain[0])[1];\n    domain[0] = dataDomain[0] - value;\n  } else if (_isFunction(specifiedDomain[0])) {\n    domain[0] = specifiedDomain[0](dataDomain[0]);\n  } else {\n    domain[0] = dataDomain[0];\n  }\n  if (isNumber(specifiedDomain[1])) {\n    domain[1] = allowDataOverflow ? specifiedDomain[1] : Math.max(specifiedDomain[1], dataDomain[1]);\n  } else if (MAX_VALUE_REG.test(specifiedDomain[1])) {\n    var _value = +MAX_VALUE_REG.exec(specifiedDomain[1])[1];\n    domain[1] = dataDomain[1] + _value;\n  } else if (_isFunction(specifiedDomain[1])) {\n    domain[1] = specifiedDomain[1](dataDomain[1]);\n  } else {\n    domain[1] = dataDomain[1];\n  }\n  /* eslint-enable prefer-destructuring */\n\n  return domain;\n};\n/**\n * Calculate the size between two category\n * @param  {Object} axis  The options of axis\n * @param  {Array}  ticks The ticks of axis\n * @param  {Boolean} isBar if items in axis are bars\n * @return {Number} Size\n */\n\nexport var getBandSizeOfAxis = function getBandSizeOfAxis(axis, ticks, isBar) {\n  if (axis && axis.scale && axis.scale.bandwidth) {\n    var bandWidth = axis.scale.bandwidth();\n    if (!isBar || bandWidth > 0) {\n      return bandWidth;\n    }\n  }\n  if (axis && ticks && ticks.length >= 2) {\n    var orderedTicks = _sortBy(ticks, function (o) {\n      return o.coordinate;\n    });\n    var bandSize = Infinity;\n    for (var i = 1, len = orderedTicks.length; i < len; i++) {\n      var cur = orderedTicks[i];\n      var prev = orderedTicks[i - 1];\n      bandSize = Math.min((cur.coordinate || 0) - (prev.coordinate || 0), bandSize);\n    }\n    return bandSize === Infinity ? 0 : bandSize;\n  }\n  return 0;\n};\n/**\n * parse the domain of a category axis when a domain is specified\n * @param   {Array}        specifiedDomain  The domain specified by users\n * @param   {Array}        calculatedDomain The domain calculated by dateKey\n * @param   {ReactElement} axisChild        The axis element\n * @returns {Array}        domains\n */\n\nexport var parseDomainOfCategoryAxis = function parseDomainOfCategoryAxis(specifiedDomain, calculatedDomain, axisChild) {\n  if (!specifiedDomain || !specifiedDomain.length) {\n    return calculatedDomain;\n  }\n  if (_isEqual(specifiedDomain, _get(axisChild, 'type.defaultProps.domain'))) {\n    return calculatedDomain;\n  }\n  return specifiedDomain;\n};","map":{"version":3,"names":["_isEqual","_sortBy","_isNaN","_upperFirst","_isString","_isArray","_max","_min","_flatMap","_isFunction","_get","_isNil","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","TypeError","o","minLen","_arrayLikeToArray","n","Object","prototype","toString","call","slice","constructor","name","Array","from","test","iter","Symbol","iterator","isArray","len","length","i","arr2","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","arguments","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","obj","value","configurable","writable","getNiceTickValues","getTickValuesFixedDomain","d3Scales","stack","shapeStack","stackOrderNone","stackOffsetExpand","stackOffsetNone","stackOffsetSilhouette","stackOffsetWiggle","isNumOrStr","uniqueId","isNumber","getPercentValue","mathSign","findEntryInArray","Legend","findAllByType","findChildByType","getDisplayName","getValueByDataKey","dataKey","defaultValue","getDomainOfDataByKey","data","type","filterNil","flattenData","entry","domain","parseFloat","Infinity","validateData","map","Date","calculateActiveTickIndex","coordinate","_ticks$length","ticks","undefined","unsortedTicks","axis","index","axisType","Math","abs","range","before","cur","after","sameDirectionCoord","diffInterval","curInRange","min","max","afterInRange","sameInterval","_i","getMainColorOfGraphicItem","item","_ref","displayName","_item$props","props","stroke","fill","result","getLegendProps","_ref2","children","formatedGraphicalItems","legendWidth","legendContent","legendItem","legendData","payload","reduce","_ref3","sectors","concat","iconType","legendType","color","_ref4","_item$props2","hide","inactive","getWithHeight","getBarSizeList","_ref5","globalSize","barSize","_ref5$stackGroups","stackGroups","numericAxisIds","sgs","stackIds","j","sLen","_sgs$stackIds$j","items","cateAxisId","barItems","indexOf","selfSize","cateId","stackList","getBarPosition","_ref6","barGap","barCategoryGap","bandSize","_ref6$sizeList","sizeList","maxBarSize","realBarGap","useFull","fullBarSize","sum","res","offset","prev","size","newRes","position","_offset","originalSize","appendOffsetOfLegend","legendBox","width","margin","left","right","legendProps","newOffset","box","align","verticalAlign","layout","height","getDomainOfErrorBars","errorBars","errorBarChild","direction","entryValue","mainValue","errorDomain","prevErrorArr","k","errorValue","lowerValue","upperValue","parseErrorBarsOfAxis","domains","getDomainOfItemsWithSameAxis","tag","isCategoricalAxis","getCoordinatesOfGrid","hasMin","hasMax","values","getTicksOfAxis","isGrid","isAll","scale","duplicateDomain","bandwidth","niceTicks","scaleContent","isCategorical","categoricalDomain","tickCount","combineEventHandlers","defaultHandler","parentHandler","childHandler","customizedHandler","arg1","arg2","arg3","arg4","parseScale","chartType","scaleBand","realScaleType","scaleLinear","scalePoint","EPS","checkDomainOfScale","first","last","findPositionOfBar","barPosition","child","truncateByDomain","offsetSign","series","m","positive","negative","offsetPositive","STACK_OFFSET_MAP","sign","expand","none","silhouette","wiggle","getStackedData","stackItems","offsetType","dataKeys","d","order","getStackGroupsByAxisId","_items","numericAxisId","reverseStackOrder","reverse","_item$props3","stackId","axisId","parentGroup","hasStack","childGroup","group","g","stackedData","calculateDomainOfTicks","getTicksOfScale","opts","originalDomain","allowDecimals","scaleType","tickValues","_domain","_tickValues","getCateCoordinateOfLine","_ref7","allowDuplicatedCategory","matchedTick","getCateCoordinateOfBar","_ref8","getBaseValueOfBar","_ref9","numericAxis","getStackedDataOfItem","itemIndex","getDomainOfSingle","getDomainOfStackGroups","startIndex","endIndex","s","MIN_VALUE_REG","MAX_VALUE_REG","parseSpecifiedDomain","specifiedDomain","dataDomain","allowDataOverflow","exec","_value","getBandSizeOfAxis","isBar","bandWidth","orderedTicks","parseDomainOfCategoryAxis","calculatedDomain","axisChild"],"sources":["/Users/abc/Downloads/Workspace/projectFPT/cms-websitebangiay/node_modules/recharts/es6/util/ChartUtils.js"],"sourcesContent":["import _isEqual from \"lodash/isEqual\";\nimport _sortBy from \"lodash/sortBy\";\nimport _isNaN from \"lodash/isNaN\";\nimport _upperFirst from \"lodash/upperFirst\";\nimport _isString from \"lodash/isString\";\nimport _isArray from \"lodash/isArray\";\nimport _max from \"lodash/max\";\nimport _min from \"lodash/min\";\nimport _flatMap from \"lodash/flatMap\";\nimport _isFunction from \"lodash/isFunction\";\nimport _get from \"lodash/get\";\nimport _isNil from \"lodash/isNil\";\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { getNiceTickValues, getTickValuesFixedDomain } from 'recharts-scale';\nimport * as d3Scales from 'd3-scale';\nimport { stack as shapeStack, stackOrderNone, stackOffsetExpand, stackOffsetNone, stackOffsetSilhouette, stackOffsetWiggle } from 'd3-shape';\nimport { isNumOrStr, uniqueId, isNumber, getPercentValue, mathSign, findEntryInArray } from './DataUtils';\nimport { Legend } from '../component/Legend';\nimport { findAllByType, findChildByType, getDisplayName } from './ReactUtils'; // TODO: Cause of circular dependency. Needs refactor.\n// import { RadiusAxisProps, AngleAxisProps } from '../polar/types';\n\nexport function getValueByDataKey(obj, dataKey, defaultValue) {\n  if (_isNil(obj) || _isNil(dataKey)) {\n    return defaultValue;\n  }\n\n  if (isNumOrStr(dataKey)) {\n    return _get(obj, dataKey, defaultValue);\n  }\n\n  if (_isFunction(dataKey)) {\n    return dataKey(obj);\n  }\n\n  return defaultValue;\n}\n/**\n * Get domain of data by key\n * @param  {Array}   data      The data displayed in the chart\n * @param  {String}  key       The unique key of a group of data\n * @param  {String}  type      The type of axis\n * @param  {Boolean} filterNil Whether or not filter nil values\n * @return {Array} Domain of data\n */\n\nexport function getDomainOfDataByKey(data, key, type, filterNil) {\n  var flattenData = _flatMap(data, function (entry) {\n    return getValueByDataKey(entry, key);\n  });\n\n  if (type === 'number') {\n    var domain = flattenData.filter(function (entry) {\n      return isNumber(entry) || parseFloat(entry);\n    });\n    return domain.length ? [_min(domain), _max(domain)] : [Infinity, -Infinity];\n  }\n\n  var validateData = filterNil ? flattenData.filter(function (entry) {\n    return !_isNil(entry);\n  }) : flattenData; // 支持Date类型的x轴\n\n  return validateData.map(function (entry) {\n    return isNumOrStr(entry) || entry instanceof Date ? entry : '';\n  });\n}\nexport var calculateActiveTickIndex = function calculateActiveTickIndex(coordinate) {\n  var _ticks$length;\n\n  var ticks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var unsortedTicks = arguments.length > 2 ? arguments[2] : undefined;\n  var axis = arguments.length > 3 ? arguments[3] : undefined;\n  var index = -1;\n  var len = (_ticks$length = ticks === null || ticks === void 0 ? void 0 : ticks.length) !== null && _ticks$length !== void 0 ? _ticks$length : 0;\n\n  if (len > 1) {\n    if (axis && axis.axisType === 'angleAxis' && Math.abs(Math.abs(axis.range[1] - axis.range[0]) - 360) <= 1e-6) {\n      var range = axis.range; // ticks are distributed in a circle\n\n      for (var i = 0; i < len; i++) {\n        var before = i > 0 ? unsortedTicks[i - 1].coordinate : unsortedTicks[len - 1].coordinate;\n        var cur = unsortedTicks[i].coordinate;\n        var after = i >= len - 1 ? unsortedTicks[0].coordinate : unsortedTicks[i + 1].coordinate;\n        var sameDirectionCoord = void 0;\n\n        if (mathSign(cur - before) !== mathSign(after - cur)) {\n          var diffInterval = [];\n\n          if (mathSign(after - cur) === mathSign(range[1] - range[0])) {\n            sameDirectionCoord = after;\n            var curInRange = cur + range[1] - range[0];\n            diffInterval[0] = Math.min(curInRange, (curInRange + before) / 2);\n            diffInterval[1] = Math.max(curInRange, (curInRange + before) / 2);\n          } else {\n            sameDirectionCoord = before;\n            var afterInRange = after + range[1] - range[0];\n            diffInterval[0] = Math.min(cur, (afterInRange + cur) / 2);\n            diffInterval[1] = Math.max(cur, (afterInRange + cur) / 2);\n          }\n\n          var sameInterval = [Math.min(cur, (sameDirectionCoord + cur) / 2), Math.max(cur, (sameDirectionCoord + cur) / 2)];\n\n          if (coordinate > sameInterval[0] && coordinate <= sameInterval[1] || coordinate >= diffInterval[0] && coordinate <= diffInterval[1]) {\n            index = unsortedTicks[i].index;\n            break;\n          }\n        } else {\n          var min = Math.min(before, after);\n          var max = Math.max(before, after);\n\n          if (coordinate > (min + cur) / 2 && coordinate <= (max + cur) / 2) {\n            index = unsortedTicks[i].index;\n            break;\n          }\n        }\n      }\n    } else {\n      // ticks are distributed in a single direction\n      for (var _i = 0; _i < len; _i++) {\n        if (_i === 0 && coordinate <= (ticks[_i].coordinate + ticks[_i + 1].coordinate) / 2 || _i > 0 && _i < len - 1 && coordinate > (ticks[_i].coordinate + ticks[_i - 1].coordinate) / 2 && coordinate <= (ticks[_i].coordinate + ticks[_i + 1].coordinate) / 2 || _i === len - 1 && coordinate > (ticks[_i].coordinate + ticks[_i - 1].coordinate) / 2) {\n          index = ticks[_i].index;\n          break;\n        }\n      }\n    }\n  } else {\n    index = 0;\n  }\n\n  return index;\n};\n/**\n * Get the main color of each graphic item\n * @param  {ReactElement} item A graphic item\n * @return {String}            Color\n */\n\nexport var getMainColorOfGraphicItem = function getMainColorOfGraphicItem(item) {\n  var _ref = item,\n      displayName = _ref.type.displayName; // TODO: check if displayName is valid.\n\n  var _item$props = item.props,\n      stroke = _item$props.stroke,\n      fill = _item$props.fill;\n  var result;\n\n  switch (displayName) {\n    case 'Line':\n      result = stroke;\n      break;\n\n    case 'Area':\n    case 'Radar':\n      result = stroke && stroke !== 'none' ? stroke : fill;\n      break;\n\n    default:\n      result = fill;\n      break;\n  }\n\n  return result;\n}; // TODO: Formated -> Formatted.\n\nexport var getLegendProps = function getLegendProps(_ref2) {\n  var children = _ref2.children,\n      formatedGraphicalItems = _ref2.formatedGraphicalItems,\n      legendWidth = _ref2.legendWidth,\n      legendContent = _ref2.legendContent;\n  var legendItem = findChildByType(children, Legend.displayName);\n\n  if (!legendItem) {\n    return null;\n  }\n\n  var legendData;\n\n  if (legendItem.props && legendItem.props.payload) {\n    legendData = legendItem.props && legendItem.props.payload;\n  } else if (legendContent === 'children') {\n    legendData = (formatedGraphicalItems || []).reduce(function (result, _ref3) {\n      var item = _ref3.item,\n          props = _ref3.props;\n      var data = props.sectors || props.data || [];\n      return result.concat(data.map(function (entry) {\n        return {\n          type: legendItem.props.iconType || item.props.legendType,\n          value: entry.name,\n          color: entry.fill,\n          payload: entry\n        };\n      }));\n    }, []);\n  } else {\n    legendData = (formatedGraphicalItems || []).map(function (_ref4) {\n      var item = _ref4.item;\n      var _item$props2 = item.props,\n          dataKey = _item$props2.dataKey,\n          name = _item$props2.name,\n          legendType = _item$props2.legendType,\n          hide = _item$props2.hide;\n      return {\n        inactive: hide,\n        dataKey: dataKey,\n        type: legendItem.props.iconType || legendType || 'square',\n        color: getMainColorOfGraphicItem(item),\n        value: name || dataKey,\n        payload: item.props\n      };\n    });\n  }\n\n  return _objectSpread(_objectSpread(_objectSpread({}, legendItem.props), Legend.getWithHeight(legendItem, legendWidth)), {}, {\n    payload: legendData,\n    item: legendItem\n  });\n};\n/**\n * Calculate the size of all groups for stacked bar graph\n * @param  {Object} stackGroups The items grouped by axisId and stackId\n * @return {Object} The size of all groups\n */\n\nexport var getBarSizeList = function getBarSizeList(_ref5) {\n  var globalSize = _ref5.barSize,\n      _ref5$stackGroups = _ref5.stackGroups,\n      stackGroups = _ref5$stackGroups === void 0 ? {} : _ref5$stackGroups;\n\n  if (!stackGroups) {\n    return {};\n  }\n\n  var result = {};\n  var numericAxisIds = Object.keys(stackGroups);\n\n  for (var i = 0, len = numericAxisIds.length; i < len; i++) {\n    var sgs = stackGroups[numericAxisIds[i]].stackGroups;\n    var stackIds = Object.keys(sgs);\n\n    for (var j = 0, sLen = stackIds.length; j < sLen; j++) {\n      var _sgs$stackIds$j = sgs[stackIds[j]],\n          items = _sgs$stackIds$j.items,\n          cateAxisId = _sgs$stackIds$j.cateAxisId;\n      var barItems = items.filter(function (item) {\n        return getDisplayName(item.type).indexOf('Bar') >= 0;\n      });\n\n      if (barItems && barItems.length) {\n        var selfSize = barItems[0].props.barSize;\n        var cateId = barItems[0].props[cateAxisId];\n\n        if (!result[cateId]) {\n          result[cateId] = [];\n        }\n\n        result[cateId].push({\n          item: barItems[0],\n          stackList: barItems.slice(1),\n          barSize: _isNil(selfSize) ? globalSize : selfSize\n        });\n      }\n    }\n  }\n\n  return result;\n};\n/**\n * Calculate the size of each bar and the gap between two bars\n * @param  {Number} bandSize  The size of each category\n * @param  {sizeList} sizeList  The size of all groups\n * @param  {maxBarSize} maxBarSize The maximum size of bar\n * @return {Number} The size of each bar and the gap between two bars\n */\n\nexport var getBarPosition = function getBarPosition(_ref6) {\n  var barGap = _ref6.barGap,\n      barCategoryGap = _ref6.barCategoryGap,\n      bandSize = _ref6.bandSize,\n      _ref6$sizeList = _ref6.sizeList,\n      sizeList = _ref6$sizeList === void 0 ? [] : _ref6$sizeList,\n      maxBarSize = _ref6.maxBarSize;\n  var len = sizeList.length;\n  if (len < 1) return null;\n  var realBarGap = getPercentValue(barGap, bandSize, 0, true);\n  var result; // whether or not is barSize setted by user\n\n  if (sizeList[0].barSize === +sizeList[0].barSize) {\n    var useFull = false;\n    var fullBarSize = bandSize / len;\n    var sum = sizeList.reduce(function (res, entry) {\n      return res + entry.barSize || 0;\n    }, 0);\n    sum += (len - 1) * realBarGap;\n\n    if (sum >= bandSize) {\n      sum -= (len - 1) * realBarGap;\n      realBarGap = 0;\n    }\n\n    if (sum >= bandSize && fullBarSize > 0) {\n      useFull = true;\n      fullBarSize *= 0.9;\n      sum = len * fullBarSize;\n    }\n\n    var offset = (bandSize - sum) / 2 >> 0;\n    var prev = {\n      offset: offset - realBarGap,\n      size: 0\n    };\n    result = sizeList.reduce(function (res, entry) {\n      var newRes = [].concat(_toConsumableArray(res), [{\n        item: entry.item,\n        position: {\n          offset: prev.offset + prev.size + realBarGap,\n          size: useFull ? fullBarSize : entry.barSize\n        }\n      }]);\n      prev = newRes[newRes.length - 1].position;\n\n      if (entry.stackList && entry.stackList.length) {\n        entry.stackList.forEach(function (item) {\n          newRes.push({\n            item: item,\n            position: prev\n          });\n        });\n      }\n\n      return newRes;\n    }, []);\n  } else {\n    var _offset = getPercentValue(barCategoryGap, bandSize, 0, true);\n\n    if (bandSize - 2 * _offset - (len - 1) * realBarGap <= 0) {\n      realBarGap = 0;\n    }\n\n    var originalSize = (bandSize - 2 * _offset - (len - 1) * realBarGap) / len;\n\n    if (originalSize > 1) {\n      originalSize >>= 0;\n    }\n\n    var size = maxBarSize === +maxBarSize ? Math.min(originalSize, maxBarSize) : originalSize;\n    result = sizeList.reduce(function (res, entry, i) {\n      var newRes = [].concat(_toConsumableArray(res), [{\n        item: entry.item,\n        position: {\n          offset: _offset + (originalSize + realBarGap) * i + (originalSize - size) / 2,\n          size: size\n        }\n      }]);\n\n      if (entry.stackList && entry.stackList.length) {\n        entry.stackList.forEach(function (item) {\n          newRes.push({\n            item: item,\n            position: newRes[newRes.length - 1].position\n          });\n        });\n      }\n\n      return newRes;\n    }, []);\n  }\n\n  return result;\n};\nexport var appendOffsetOfLegend = function appendOffsetOfLegend(offset, items, props, legendBox) {\n  var children = props.children,\n      width = props.width,\n      margin = props.margin;\n  var legendWidth = width - (margin.left || 0) - (margin.right || 0); // const legendHeight = height - (margin.top || 0) - (margin.bottom || 0);\n\n  var legendProps = getLegendProps({\n    children: children,\n    legendWidth: legendWidth\n  });\n  var newOffset = offset;\n\n  if (legendProps) {\n    var box = legendBox || {};\n    var align = legendProps.align,\n        verticalAlign = legendProps.verticalAlign,\n        layout = legendProps.layout;\n\n    if ((layout === 'vertical' || layout === 'horizontal' && verticalAlign === 'center') && isNumber(offset[align])) {\n      newOffset = _objectSpread(_objectSpread({}, offset), {}, _defineProperty({}, align, newOffset[align] + (box.width || 0)));\n    }\n\n    if ((layout === 'horizontal' || layout === 'vertical' && align === 'center') && isNumber(offset[verticalAlign])) {\n      newOffset = _objectSpread(_objectSpread({}, offset), {}, _defineProperty({}, verticalAlign, newOffset[verticalAlign] + (box.height || 0)));\n    }\n  }\n\n  return newOffset;\n};\nexport var getDomainOfErrorBars = function getDomainOfErrorBars(data, item, dataKey, axisType) {\n  var children = item.props.children;\n  var errorBars = findAllByType(children, 'ErrorBar').filter(function (errorBarChild) {\n    var direction = errorBarChild.props.direction;\n    return _isNil(direction) || _isNil(axisType) ? true : axisType.indexOf(direction) >= 0;\n  });\n\n  if (errorBars && errorBars.length) {\n    var keys = errorBars.map(function (errorBarChild) {\n      return errorBarChild.props.dataKey;\n    });\n    return data.reduce(function (result, entry) {\n      var entryValue = getValueByDataKey(entry, dataKey, 0);\n      var mainValue = _isArray(entryValue) ? [_min(entryValue), _max(entryValue)] : [entryValue, entryValue];\n      var errorDomain = keys.reduce(function (prevErrorArr, k) {\n        var errorValue = getValueByDataKey(entry, k, 0);\n        var lowerValue = mainValue[0] - Math.abs(_isArray(errorValue) ? errorValue[0] : errorValue);\n        var upperValue = mainValue[1] + Math.abs(_isArray(errorValue) ? errorValue[1] : errorValue);\n        return [Math.min(lowerValue, prevErrorArr[0]), Math.max(upperValue, prevErrorArr[1])];\n      }, [Infinity, -Infinity]);\n      return [Math.min(errorDomain[0], result[0]), Math.max(errorDomain[1], result[1])];\n    }, [Infinity, -Infinity]);\n  }\n\n  return null;\n};\nexport var parseErrorBarsOfAxis = function parseErrorBarsOfAxis(data, items, dataKey, axisType) {\n  var domains = items.map(function (item) {\n    return getDomainOfErrorBars(data, item, dataKey, axisType);\n  }).filter(function (entry) {\n    return !_isNil(entry);\n  });\n\n  if (domains && domains.length) {\n    return domains.reduce(function (result, entry) {\n      return [Math.min(result[0], entry[0]), Math.max(result[1], entry[1])];\n    }, [Infinity, -Infinity]);\n  }\n\n  return null;\n};\n/**\n * Get domain of data by the configuration of item element\n * @param  {Array}   data      The data displayed in the chart\n * @param  {Array}   items     The instances of item\n * @param  {String}  type      The type of axis, number - Number Axis, category - Category Axis\n * @param  {Boolean} filterNil Whether or not filter nil values\n * @return {Array}        Domain\n */\n\nexport var getDomainOfItemsWithSameAxis = function getDomainOfItemsWithSameAxis(data, items, type, filterNil) {\n  var domains = items.map(function (item) {\n    var dataKey = item.props.dataKey;\n\n    if (type === 'number' && dataKey) {\n      return getDomainOfErrorBars(data, item, dataKey) || getDomainOfDataByKey(data, dataKey, type, filterNil);\n    }\n\n    return getDomainOfDataByKey(data, dataKey, type, filterNil);\n  });\n\n  if (type === 'number') {\n    // Calculate the domain of number axis\n    return domains.reduce(function (result, entry) {\n      return [Math.min(result[0], entry[0]), Math.max(result[1], entry[1])];\n    }, [Infinity, -Infinity]);\n  }\n\n  var tag = {}; // Get the union set of category axis\n\n  return domains.reduce(function (result, entry) {\n    for (var i = 0, len = entry.length; i < len; i++) {\n      if (!tag[entry[i]]) {\n        tag[entry[i]] = true;\n        result.push(entry[i]);\n      }\n    }\n\n    return result;\n  }, []);\n};\nexport var isCategoricalAxis = function isCategoricalAxis(layout, axisType) {\n  return layout === 'horizontal' && axisType === 'xAxis' || layout === 'vertical' && axisType === 'yAxis' || layout === 'centric' && axisType === 'angleAxis' || layout === 'radial' && axisType === 'radiusAxis';\n};\n/**\n * Calculate the Coordinates of grid\n * @param  {Array} ticks The ticks in axis\n * @param {Number} min   The minimun value of axis\n * @param {Number} max   The maximun value of axis\n * @return {Array}       Coordinates\n */\n\nexport var getCoordinatesOfGrid = function getCoordinatesOfGrid(ticks, min, max) {\n  var hasMin, hasMax;\n  var values = ticks.map(function (entry) {\n    if (entry.coordinate === min) {\n      hasMin = true;\n    }\n\n    if (entry.coordinate === max) {\n      hasMax = true;\n    }\n\n    return entry.coordinate;\n  });\n\n  if (!hasMin) {\n    values.push(min);\n  }\n\n  if (!hasMax) {\n    values.push(max);\n  }\n\n  return values;\n};\n/**\n * Get the ticks of an axis\n * @param  {Object}  axis The configuration of an axis\n * @param {Boolean} isGrid Whether or not are the ticks in grid\n * @param {Boolean} isAll Return the ticks of all the points or not\n * @return {Array}  Ticks\n */\n\nexport var getTicksOfAxis = function getTicksOfAxis(axis, isGrid, isAll) {\n  if (!axis) return null;\n  var scale = axis.scale;\n  var duplicateDomain = axis.duplicateDomain,\n      type = axis.type,\n      range = axis.range;\n  var offset = (isGrid || isAll) && type === 'category' && scale.bandwidth ? scale.bandwidth() / 2 : 0;\n  offset = axis.axisType === 'angleAxis' ? mathSign(range[0] - range[1]) * 2 * offset : offset; // The ticks setted by user should only affect the ticks adjacent to axis line\n\n  if (isGrid && (axis.ticks || axis.niceTicks)) {\n    return (axis.ticks || axis.niceTicks).map(function (entry) {\n      var scaleContent = duplicateDomain ? duplicateDomain.indexOf(entry) : entry;\n      return {\n        coordinate: scale(scaleContent) + offset,\n        value: entry,\n        offset: offset\n      };\n    });\n  } // When axis is a categorial axis, but the type of axis is number or the scale of axis is not \"auto\"\n\n\n  if (axis.isCategorical && axis.categoricalDomain) {\n    return axis.categoricalDomain.map(function (entry, index) {\n      return {\n        coordinate: scale(entry) + offset,\n        value: entry,\n        index: index,\n        offset: offset\n      };\n    });\n  }\n\n  if (scale.ticks && !isAll) {\n    return scale.ticks(axis.tickCount).map(function (entry) {\n      return {\n        coordinate: scale(entry) + offset,\n        value: entry,\n        offset: offset\n      };\n    });\n  } // When axis has duplicated text, serial numbers are used to generate scale\n\n\n  return scale.domain().map(function (entry, index) {\n    return {\n      coordinate: scale(entry) + offset,\n      value: duplicateDomain ? duplicateDomain[entry] : entry,\n      index: index,\n      offset: offset\n    };\n  });\n};\n/**\n * combine the handlers\n * @param  {Function} defaultHandler Internal private handler\n * @param  {Function} parentHandler  Handler function specified in parent component\n * @param  {Function} childHandler   Handler function specified in child component\n * @return {Function}                The combined handler\n */\n\nexport var combineEventHandlers = function combineEventHandlers(defaultHandler, parentHandler, childHandler) {\n  var customizedHandler;\n\n  if (_isFunction(childHandler)) {\n    customizedHandler = childHandler;\n  } else if (_isFunction(parentHandler)) {\n    customizedHandler = parentHandler;\n  }\n\n  if (_isFunction(defaultHandler) || customizedHandler) {\n    return function (arg1, arg2, arg3, arg4) {\n      if (_isFunction(defaultHandler)) {\n        defaultHandler(arg1, arg2, arg3, arg4);\n      }\n\n      if (_isFunction(customizedHandler)) {\n        customizedHandler(arg1, arg2, arg3, arg4);\n      }\n    };\n  }\n\n  return null;\n};\n/**\n * Parse the scale function of axis\n * @param  {Object}   axis          The option of axis\n * @param  {String}   chartType     The displayName of chart\n * @return {Function}               The scale funcion\n */\n\nexport var parseScale = function parseScale(axis, chartType) {\n  var scale = axis.scale,\n      type = axis.type,\n      layout = axis.layout,\n      axisType = axis.axisType;\n\n  if (scale === 'auto') {\n    if (layout === 'radial' && axisType === 'radiusAxis') {\n      return {\n        scale: d3Scales.scaleBand(),\n        realScaleType: 'band'\n      };\n    }\n\n    if (layout === 'radial' && axisType === 'angleAxis') {\n      return {\n        scale: d3Scales.scaleLinear(),\n        realScaleType: 'linear'\n      };\n    }\n\n    if (type === 'category' && chartType && (chartType.indexOf('LineChart') >= 0 || chartType.indexOf('AreaChart') >= 0 || chartType.indexOf('ComposedChart') >= 0)) {\n      return {\n        scale: d3Scales.scalePoint(),\n        realScaleType: 'point'\n      };\n    }\n\n    if (type === 'category') {\n      return {\n        scale: d3Scales.scaleBand(),\n        realScaleType: 'band'\n      };\n    }\n\n    return {\n      scale: d3Scales.scaleLinear(),\n      realScaleType: 'linear'\n    };\n  }\n\n  if (_isString(scale)) {\n    var name = \"scale\".concat(_upperFirst(scale));\n    return {\n      scale: (d3Scales[name] || d3Scales.scalePoint)(),\n      realScaleType: d3Scales[name] ? name : 'point'\n    };\n  }\n\n  return _isFunction(scale) ? {\n    scale: scale\n  } : {\n    scale: d3Scales.scalePoint(),\n    realScaleType: 'point'\n  };\n};\nvar EPS = 1e-4;\nexport var checkDomainOfScale = function checkDomainOfScale(scale) {\n  var domain = scale.domain();\n\n  if (!domain || domain.length <= 2) {\n    return;\n  }\n\n  var len = domain.length;\n  var range = scale.range();\n  var min = Math.min(range[0], range[1]) - EPS;\n  var max = Math.max(range[0], range[1]) + EPS;\n  var first = scale(domain[0]);\n  var last = scale(domain[len - 1]);\n\n  if (first < min || first > max || last < min || last > max) {\n    scale.domain([domain[0], domain[len - 1]]);\n  }\n};\nexport var findPositionOfBar = function findPositionOfBar(barPosition, child) {\n  if (!barPosition) {\n    return null;\n  }\n\n  for (var i = 0, len = barPosition.length; i < len; i++) {\n    if (barPosition[i].item === child) {\n      return barPosition[i].position;\n    }\n  }\n\n  return null;\n};\nexport var truncateByDomain = function truncateByDomain(value, domain) {\n  if (!domain || domain.length !== 2 || !isNumber(domain[0]) || !isNumber(domain[1])) {\n    return value;\n  }\n\n  var min = Math.min(domain[0], domain[1]);\n  var max = Math.max(domain[0], domain[1]);\n  var result = [value[0], value[1]];\n\n  if (!isNumber(value[0]) || value[0] < min) {\n    result[0] = min;\n  }\n\n  if (!isNumber(value[1]) || value[1] > max) {\n    result[1] = max;\n  }\n\n  if (result[0] > max) {\n    result[0] = max;\n  }\n\n  if (result[1] < min) {\n    result[1] = min;\n  }\n\n  return result;\n};\n/* eslint no-param-reassign: 0 */\n\nexport var offsetSign = function offsetSign(series) {\n  var n = series.length;\n\n  if (n <= 0) {\n    return;\n  }\n\n  for (var j = 0, m = series[0].length; j < m; ++j) {\n    var positive = 0;\n    var negative = 0;\n\n    for (var i = 0; i < n; ++i) {\n      var value = _isNaN(series[i][j][1]) ? series[i][j][0] : series[i][j][1];\n      /* eslint-disable prefer-destructuring */\n\n      if (value >= 0) {\n        series[i][j][0] = positive;\n        series[i][j][1] = positive + value;\n        positive = series[i][j][1];\n      } else {\n        series[i][j][0] = negative;\n        series[i][j][1] = negative + value;\n        negative = series[i][j][1];\n      }\n      /* eslint-enable prefer-destructuring */\n\n    }\n  }\n};\n/* eslint no-param-reassign: 0 */\n\nexport var offsetPositive = function offsetPositive(series) {\n  var n = series.length;\n\n  if (n <= 0) {\n    return;\n  }\n\n  for (var j = 0, m = series[0].length; j < m; ++j) {\n    var positive = 0;\n\n    for (var i = 0; i < n; ++i) {\n      var value = _isNaN(series[i][j][1]) ? series[i][j][0] : series[i][j][1];\n      /* eslint-disable prefer-destructuring */\n\n      if (value >= 0) {\n        series[i][j][0] = positive;\n        series[i][j][1] = positive + value;\n        positive = series[i][j][1];\n      } else {\n        series[i][j][0] = 0;\n        series[i][j][1] = 0;\n      }\n      /* eslint-enable prefer-destructuring */\n\n    }\n  }\n};\nvar STACK_OFFSET_MAP = {\n  sign: offsetSign,\n  expand: stackOffsetExpand,\n  none: stackOffsetNone,\n  silhouette: stackOffsetSilhouette,\n  wiggle: stackOffsetWiggle,\n  positive: offsetPositive\n};\nexport var getStackedData = function getStackedData(data, stackItems, offsetType) {\n  var dataKeys = stackItems.map(function (item) {\n    return item.props.dataKey;\n  });\n  var stack = shapeStack().keys(dataKeys).value(function (d, key) {\n    return +getValueByDataKey(d, key, 0);\n  }).order(stackOrderNone).offset(STACK_OFFSET_MAP[offsetType]);\n  return stack(data);\n};\nexport var getStackGroupsByAxisId = function getStackGroupsByAxisId(data, _items, numericAxisId, cateAxisId, offsetType, reverseStackOrder) {\n  if (!data) {\n    return null;\n  } // reversing items to affect render order (for layering)\n\n\n  var items = reverseStackOrder ? _items.reverse() : _items;\n  var stackGroups = items.reduce(function (result, item) {\n    var _item$props3 = item.props,\n        stackId = _item$props3.stackId,\n        hide = _item$props3.hide;\n\n    if (hide) {\n      return result;\n    }\n\n    var axisId = item.props[numericAxisId];\n    var parentGroup = result[axisId] || {\n      hasStack: false,\n      stackGroups: {}\n    };\n\n    if (isNumOrStr(stackId)) {\n      var childGroup = parentGroup.stackGroups[stackId] || {\n        numericAxisId: numericAxisId,\n        cateAxisId: cateAxisId,\n        items: []\n      };\n      childGroup.items.push(item);\n      parentGroup.hasStack = true;\n      parentGroup.stackGroups[stackId] = childGroup;\n    } else {\n      parentGroup.stackGroups[uniqueId('_stackId_')] = {\n        numericAxisId: numericAxisId,\n        cateAxisId: cateAxisId,\n        items: [item]\n      };\n    }\n\n    return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, axisId, parentGroup));\n  }, {});\n  return Object.keys(stackGroups).reduce(function (result, axisId) {\n    var group = stackGroups[axisId];\n\n    if (group.hasStack) {\n      group.stackGroups = Object.keys(group.stackGroups).reduce(function (res, stackId) {\n        var g = group.stackGroups[stackId];\n        return _objectSpread(_objectSpread({}, res), {}, _defineProperty({}, stackId, {\n          numericAxisId: numericAxisId,\n          cateAxisId: cateAxisId,\n          items: g.items,\n          stackedData: getStackedData(data, g.items, offsetType)\n        }));\n      }, {});\n    }\n\n    return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, axisId, group));\n  }, {});\n};\n/**\n * get domain of ticks\n * @param  {Array} ticks Ticks of axis\n * @param  {String} type  The type of axis\n * @return {Array} domain\n */\n\nexport var calculateDomainOfTicks = function calculateDomainOfTicks(ticks, type) {\n  if (type === 'number') {\n    return [_min(ticks), _max(ticks)];\n  }\n\n  return ticks;\n};\n/**\n * Configure the scale function of axis\n * @param {Object} scale The scale function\n * @param {Object} opts  The configuration of axis\n * @return {Object}      null\n */\n\nexport var getTicksOfScale = function getTicksOfScale(scale, opts) {\n  var realScaleType = opts.realScaleType,\n      type = opts.type,\n      tickCount = opts.tickCount,\n      originalDomain = opts.originalDomain,\n      allowDecimals = opts.allowDecimals;\n  var scaleType = realScaleType || opts.scale;\n\n  if (scaleType !== 'auto' && scaleType !== 'linear') {\n    return null;\n  }\n\n  if (tickCount && type === 'number' && originalDomain && (originalDomain[0] === 'auto' || originalDomain[1] === 'auto')) {\n    // Calculate the ticks by the number of grid when the axis is a number axis\n    var domain = scale.domain();\n\n    if (!domain.length) {\n      return null;\n    }\n\n    var tickValues = getNiceTickValues(domain, tickCount, allowDecimals);\n    scale.domain(calculateDomainOfTicks(tickValues, type));\n    return {\n      niceTicks: tickValues\n    };\n  }\n\n  if (tickCount && type === 'number') {\n    var _domain = scale.domain();\n\n    var _tickValues = getTickValuesFixedDomain(_domain, tickCount, allowDecimals);\n\n    return {\n      niceTicks: _tickValues\n    };\n  }\n\n  return null;\n};\nexport var getCateCoordinateOfLine = function getCateCoordinateOfLine(_ref7) {\n  var axis = _ref7.axis,\n      ticks = _ref7.ticks,\n      bandSize = _ref7.bandSize,\n      entry = _ref7.entry,\n      index = _ref7.index,\n      dataKey = _ref7.dataKey;\n\n  if (axis.type === 'category') {\n    // find coordinate of category axis by the value of category\n    if (!axis.allowDuplicatedCategory && axis.dataKey && !_isNil(entry[axis.dataKey])) {\n      var matchedTick = findEntryInArray(ticks, 'value', entry[axis.dataKey]);\n\n      if (matchedTick) {\n        return matchedTick.coordinate + bandSize / 2;\n      }\n    }\n\n    return ticks[index] ? ticks[index].coordinate + bandSize / 2 : null;\n  }\n\n  var value = getValueByDataKey(entry, !_isNil(dataKey) ? dataKey : axis.dataKey);\n  return !_isNil(value) ? axis.scale(value) : null;\n};\nexport var getCateCoordinateOfBar = function getCateCoordinateOfBar(_ref8) {\n  var axis = _ref8.axis,\n      ticks = _ref8.ticks,\n      offset = _ref8.offset,\n      bandSize = _ref8.bandSize,\n      entry = _ref8.entry,\n      index = _ref8.index;\n\n  if (axis.type === 'category') {\n    return ticks[index] ? ticks[index].coordinate + offset : null;\n  }\n\n  var value = getValueByDataKey(entry, axis.dataKey, axis.domain[index]);\n  return !_isNil(value) ? axis.scale(value) - bandSize / 2 + offset : null;\n};\nexport var getBaseValueOfBar = function getBaseValueOfBar(_ref9) {\n  var numericAxis = _ref9.numericAxis;\n  var domain = numericAxis.scale.domain();\n\n  if (numericAxis.type === 'number') {\n    var min = Math.min(domain[0], domain[1]);\n    var max = Math.max(domain[0], domain[1]);\n\n    if (min <= 0 && max >= 0) {\n      return 0;\n    }\n\n    if (max < 0) {\n      return max;\n    }\n\n    return min;\n  }\n\n  return domain[0];\n};\nexport var getStackedDataOfItem = function getStackedDataOfItem(item, stackGroups) {\n  var stackId = item.props.stackId;\n\n  if (isNumOrStr(stackId)) {\n    var group = stackGroups[stackId];\n\n    if (group && group.items.length) {\n      var itemIndex = -1;\n\n      for (var i = 0, len = group.items.length; i < len; i++) {\n        if (group.items[i] === item) {\n          itemIndex = i;\n          break;\n        }\n      }\n\n      return itemIndex >= 0 ? group.stackedData[itemIndex] : null;\n    }\n  }\n\n  return null;\n};\n\nvar getDomainOfSingle = function getDomainOfSingle(data) {\n  return data.reduce(function (result, entry) {\n    return [_min(entry.concat([result[0]]).filter(isNumber)), _max(entry.concat([result[1]]).filter(isNumber))];\n  }, [Infinity, -Infinity]);\n};\n\nexport var getDomainOfStackGroups = function getDomainOfStackGroups(stackGroups, startIndex, endIndex) {\n  return Object.keys(stackGroups).reduce(function (result, stackId) {\n    var group = stackGroups[stackId];\n    var stackedData = group.stackedData;\n    var domain = stackedData.reduce(function (res, entry) {\n      var s = getDomainOfSingle(entry.slice(startIndex, endIndex + 1));\n      return [Math.min(res[0], s[0]), Math.max(res[1], s[1])];\n    }, [Infinity, -Infinity]);\n    return [Math.min(domain[0], result[0]), Math.max(domain[1], result[1])];\n  }, [Infinity, -Infinity]).map(function (result) {\n    return result === Infinity || result === -Infinity ? 0 : result;\n  });\n};\nexport var MIN_VALUE_REG = /^dataMin[\\s]*-[\\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;\nexport var MAX_VALUE_REG = /^dataMax[\\s]*\\+[\\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;\nexport var parseSpecifiedDomain = function parseSpecifiedDomain(specifiedDomain, dataDomain, allowDataOverflow) {\n  if (!_isArray(specifiedDomain)) {\n    return dataDomain;\n  }\n\n  var domain = [];\n  /* eslint-disable prefer-destructuring */\n\n  if (isNumber(specifiedDomain[0])) {\n    domain[0] = allowDataOverflow ? specifiedDomain[0] : Math.min(specifiedDomain[0], dataDomain[0]);\n  } else if (MIN_VALUE_REG.test(specifiedDomain[0])) {\n    var value = +MIN_VALUE_REG.exec(specifiedDomain[0])[1];\n    domain[0] = dataDomain[0] - value;\n  } else if (_isFunction(specifiedDomain[0])) {\n    domain[0] = specifiedDomain[0](dataDomain[0]);\n  } else {\n    domain[0] = dataDomain[0];\n  }\n\n  if (isNumber(specifiedDomain[1])) {\n    domain[1] = allowDataOverflow ? specifiedDomain[1] : Math.max(specifiedDomain[1], dataDomain[1]);\n  } else if (MAX_VALUE_REG.test(specifiedDomain[1])) {\n    var _value = +MAX_VALUE_REG.exec(specifiedDomain[1])[1];\n\n    domain[1] = dataDomain[1] + _value;\n  } else if (_isFunction(specifiedDomain[1])) {\n    domain[1] = specifiedDomain[1](dataDomain[1]);\n  } else {\n    domain[1] = dataDomain[1];\n  }\n  /* eslint-enable prefer-destructuring */\n\n\n  return domain;\n};\n/**\n * Calculate the size between two category\n * @param  {Object} axis  The options of axis\n * @param  {Array}  ticks The ticks of axis\n * @param  {Boolean} isBar if items in axis are bars\n * @return {Number} Size\n */\n\nexport var getBandSizeOfAxis = function getBandSizeOfAxis(axis, ticks, isBar) {\n  if (axis && axis.scale && axis.scale.bandwidth) {\n    var bandWidth = axis.scale.bandwidth();\n\n    if (!isBar || bandWidth > 0) {\n      return bandWidth;\n    }\n  }\n\n  if (axis && ticks && ticks.length >= 2) {\n    var orderedTicks = _sortBy(ticks, function (o) {\n      return o.coordinate;\n    });\n\n    var bandSize = Infinity;\n\n    for (var i = 1, len = orderedTicks.length; i < len; i++) {\n      var cur = orderedTicks[i];\n      var prev = orderedTicks[i - 1];\n      bandSize = Math.min((cur.coordinate || 0) - (prev.coordinate || 0), bandSize);\n    }\n\n    return bandSize === Infinity ? 0 : bandSize;\n  }\n\n  return 0;\n};\n/**\n * parse the domain of a category axis when a domain is specified\n * @param   {Array}        specifiedDomain  The domain specified by users\n * @param   {Array}        calculatedDomain The domain calculated by dateKey\n * @param   {ReactElement} axisChild        The axis element\n * @returns {Array}        domains\n */\n\nexport var parseDomainOfCategoryAxis = function parseDomainOfCategoryAxis(specifiedDomain, calculatedDomain, axisChild) {\n  if (!specifiedDomain || !specifiedDomain.length) {\n    return calculatedDomain;\n  }\n\n  if (_isEqual(specifiedDomain, _get(axisChild, 'type.defaultProps.domain'))) {\n    return calculatedDomain;\n  }\n\n  return specifiedDomain;\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}