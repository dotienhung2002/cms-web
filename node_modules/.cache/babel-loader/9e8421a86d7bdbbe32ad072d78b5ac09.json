{"ast":null,"code":"import { ITSELF as r, createInterpreter as n } from \"@ucast/core\";\nfunction t(r, n, t) {\n  for (var u = 0, e = r.length; u < e; u++) {\n    if (0 === t(r[u], n)) return !0;\n  }\n  return !1;\n}\nfunction u(r, n) {\n  return Array.isArray(r) && Number.isNaN(Number(n));\n}\nfunction e(r, n, t) {\n  if (!u(r, n)) return t(r, n);\n  for (var e = [], o = 0; o < r.length; o++) {\n    var i = t(r[o], n);\n    void 0 !== i && (e = e.concat(i));\n  }\n  return e;\n}\nfunction o(r) {\n  return function (n, t, u) {\n    var e = u.get(t, n.field);\n    return Array.isArray(e) ? e.some(function (t) {\n      return r(n, t, u);\n    }) : r(n, e, u);\n  };\n}\nfunction i() {\n  return (i = Object.assign || function (r) {\n    for (var n = 1; n < arguments.length; n++) {\n      var t = arguments[n];\n      for (var u in t) {\n        Object.prototype.hasOwnProperty.call(t, u) && (r[u] = t[u]);\n      }\n    }\n    return r;\n  }).apply(this, arguments);\n}\nvar f = function f(r, n) {\n  return r[n];\n};\nfunction c(r, n, t) {\n  var u = n.lastIndexOf(\".\");\n  return -1 === u ? [r, n] : [t(r, n.slice(0, u)), n.slice(u + 1)];\n}\nfunction a(n, t, u) {\n  if (void 0 === u && (u = f), t === r) return n;\n  if (!n) throw new Error('Unable to get field \"' + t + '\" out of ' + String(n) + \".\");\n  return function (r, n, t) {\n    if (-1 === n.indexOf(\".\")) return e(r, n, t);\n    for (var u = n.split(\".\"), o = r, i = 0, f = u.length; i < f; i++) {\n      if (!(o = e(o, u[i], t)) || \"object\" != typeof o) return o;\n    }\n    return o;\n  }(n, t, u);\n}\nfunction v(r) {\n  return function (n, t) {\n    return a(n, t, r);\n  };\n}\nfunction y(r, n) {\n  return r === n ? 0 : r > n ? 1 : -1;\n}\nfunction l(r, t) {\n  return void 0 === t && (t = {}), n(r, i({\n    get: a,\n    compare: y\n  }, t));\n}\nvar b = function b(r, n, t) {\n    var u = t.interpret;\n    return r.value.some(function (r) {\n      return u(r, n);\n    });\n  },\n  m = function m(r, n, t) {\n    return !b(r, n, t);\n  },\n  d = function d(r, n, t) {\n    var u = t.interpret;\n    return r.value.every(function (r) {\n      return u(r, n);\n    });\n  },\n  g = function g(r, n, t) {\n    return !(0, t.interpret)(r.value[0], n);\n  },\n  p = function p(r, n, u) {\n    var e = u.compare,\n      o = (0, u.get)(n, r.field);\n    return Array.isArray(o) && !Array.isArray(r.value) ? t(o, r.value, e) : 0 === e(o, r.value);\n  },\n  A = function A(r, n, t) {\n    return !p(r, n, t);\n  },\n  s = o(function (r, n, t) {\n    var u = t.compare(n, r.value);\n    return 0 === u || -1 === u;\n  }),\n  h = o(function (r, n, t) {\n    return -1 === t.compare(n, r.value);\n  }),\n  j = o(function (r, n, t) {\n    return 1 === t.compare(n, r.value);\n  }),\n  w = o(function (r, n, t) {\n    var u = t.compare(n, r.value);\n    return 0 === u || 1 === u;\n  }),\n  _ = function _(n, t, e) {\n    var o = e.get;\n    if (n.field === r) return void 0 !== t;\n    var i = c(t, n.field, o),\n      f = i[0],\n      a = i[1],\n      v = function v(r) {\n        return !!r && r.hasOwnProperty(a) === n.value;\n      };\n    return u(f, a) ? f.some(v) : v(f);\n  },\n  x = o(function (r, n) {\n    return \"number\" == typeof n && n % r.value[0] === r.value[1];\n  }),\n  O = function O(n, t, e) {\n    var o = e.get,\n      i = c(t, n.field, o),\n      f = i[0],\n      a = i[1],\n      v = function v(r) {\n        var t = o(r, a);\n        return Array.isArray(t) && t.length === n.value;\n      };\n    return n.field !== r && u(f, a) ? f.some(v) : v(f);\n  },\n  N = o(function (r, n) {\n    return \"string\" == typeof n && r.value.test(n);\n  }),\n  q = o(function (r, n, u) {\n    var e = u.compare;\n    return t(r.value, n, e);\n  }),\n  z = function z(r, n, t) {\n    return !q(r, n, t);\n  },\n  E = function E(r, n, u) {\n    var e = u.compare,\n      o = (0, u.get)(n, r.field);\n    return Array.isArray(o) && r.value.every(function (r) {\n      return t(o, r, e);\n    });\n  },\n  M = function M(r, n, t) {\n    var u = t.interpret,\n      e = (0, t.get)(n, r.field);\n    return Array.isArray(e) && e.some(function (n) {\n      return u(r.value, n);\n    });\n  },\n  S = function S(r, n) {\n    return r.value.call(n);\n  },\n  U = i({}, Object.freeze({\n    __proto__: null,\n    or: b,\n    nor: m,\n    and: d,\n    not: g,\n    eq: p,\n    ne: A,\n    lte: s,\n    lt: h,\n    gt: j,\n    gte: w,\n    exists: _,\n    mod: x,\n    size: O,\n    regex: N,\n    within: q,\n    nin: z,\n    all: E,\n    elemMatch: M,\n    where: S\n  }), {\n    in: q\n  }),\n  k = l(U);\nexport { E as all, U as allInterpreters, d as and, y as compare, v as createGetter, l as createJsInterpreter, M as elemMatch, p as eq, _ as exists, a as getObjectField, c as getObjectFieldCursor, j as gt, w as gte, k as interpret, h as lt, s as lte, x as mod, A as ne, z as nin, m as nor, g as not, b as or, N as regex, O as size, S as where, q as within };","map":{"version":3,"sources":["../../src/utils.ts","../../src/interpreter.ts","../../src/interpreters.ts","../../src/defaults.ts"],"names":["includes","items","value","compare","i","length","isArrayAndNotNumericField","object","field","Array","isArray","Number","isNaN","getField","get","result","concat","indexOf","paths","split","testValueOrArray","test","node","context","some","v","defaultGet","getObjectFieldCursor","path","dotIndex","lastIndexOf","slice","getObjectField","ITSELF","Error","String","getValueByPath","createGetter","a","b","createJsInterpreter","operators","options","createInterpreter","or","interpret","condition","nor","and","every","not","eq","ne","lte","lt","gt","gte","exists","item","hasOwnProperty","mod","size","regex","within","nin","all","elemMatch","where","call","allInterpreters","in","interpreters"],"mappings":"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","sourcesContent":["import { FieldCondition } from '@ucast/core';\nimport { JsInterpretationOptions, JsInterpreter } from './types';\n\nexport type AnyObject = Record<PropertyKey, unknown>;\nexport type GetField = (object: any, field: string) => any;\n\nexport function includes<T>(\n  items: T[],\n  value: T,\n  compare: JsInterpretationOptions['compare']\n): boolean {\n  for (let i = 0, length = items.length; i < length; i++) {\n    if (compare(items[i], value) === 0) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport function isArrayAndNotNumericField<T>(object: T | T[], field: string): object is T[] {\n  return Array.isArray(object) && Number.isNaN(Number(field));\n}\n\nfunction getField<T extends AnyObject>(object: T | T[], field: string, get: GetField) {\n  if (!isArrayAndNotNumericField(object, field)) {\n    return get(object, field);\n  }\n\n  let result: unknown[] = [];\n\n  for (let i = 0; i < object.length; i++) {\n    const value = get(object[i], field);\n    if (typeof value !== 'undefined') {\n      result = result.concat(value);\n    }\n  }\n\n  return result;\n}\n\nexport function getValueByPath(object: AnyObject, field: string, get: GetField) {\n  if (field.indexOf('.') === -1) {\n    return getField(object, field, get);\n  }\n\n  const paths = field.split('.');\n  let value = object;\n\n  for (let i = 0, length = paths.length; i < length; i++) {\n    value = getField(value, paths[i], get);\n\n    if (!value || typeof value !== 'object') {\n      return value;\n    }\n  }\n\n  return value;\n}\n\nexport function testValueOrArray<T, U = T>(test: JsInterpreter<FieldCondition<T>, U>) {\n  return ((node, object, context) => {\n    const value = context.get(object, node.field);\n\n    if (!Array.isArray(value)) {\n      return test(node, value, context);\n    }\n\n    return value.some(v => test(node, v, context));\n  }) as JsInterpreter<FieldCondition<T>, AnyObject | U>;\n}\n","import { createInterpreter, ITSELF } from '@ucast/core';\nimport { getValueByPath, AnyObject, GetField } from './utils';\nimport { JsInterpretationOptions, JsInterpreter } from './types';\n\nconst defaultGet = (object: AnyObject, field: string) => object[field];\ntype Field = string | typeof ITSELF;\n\nexport function getObjectFieldCursor<T extends {}>(object: T, path: string, get: GetField) {\n  const dotIndex = path.lastIndexOf('.');\n\n  if (dotIndex === -1) {\n    return [object, path] as const;\n  }\n\n  return [\n    get(object, path.slice(0, dotIndex)) as T,\n    path.slice(dotIndex + 1)\n  ] as const;\n}\n\nexport function getObjectField(object: unknown, field: Field, get: GetField = defaultGet) {\n  if (field === ITSELF) {\n    return object;\n  }\n\n  if (!object) {\n    throw new Error(`Unable to get field \"${field}\" out of ${String(object)}.`);\n  }\n\n  return getValueByPath(object as Record<string, unknown>, field, get);\n}\n\nexport function createGetter<T extends GetField>(get: T) {\n  return (object: Parameters<T>[0], field: Parameters<T>[1]) => getObjectField(object, field, get);\n}\n\nexport function compare<T>(a: T, b: T): 0 | 1 | -1 {\n  if (a === b) {\n    return 0;\n  }\n\n  return a > b ? 1 : -1;\n}\n\nexport function createJsInterpreter<\n  T extends JsInterpreter<any>,\n  O extends Partial<JsInterpretationOptions>\n>(\n  operators: Record<string, T>,\n  options: O = {} as O\n) {\n  return createInterpreter(operators, {\n    get: getObjectField,\n    compare,\n    ...options,\n  });\n}\n","import {\n  CompoundCondition as Compound,\n  FieldCondition as Field,\n  DocumentCondition as Document,\n  Condition,\n  Comparable,\n  ITSELF,\n} from '@ucast/core';\nimport { JsInterpreter as Interpret } from './types';\nimport {\n  includes,\n  testValueOrArray,\n  isArrayAndNotNumericField,\n  AnyObject,\n} from './utils';\nimport { getObjectFieldCursor } from './interpreter';\n\nexport const or: Interpret<Compound> = (node, object, { interpret }) => {\n  return node.value.some(condition => interpret(condition, object));\n};\n\nexport const nor: typeof or = (node, object, context) => {\n  return !or(node, object, context);\n};\n\nexport const and: Interpret<Compound> = (node, object, { interpret }) => {\n  return node.value.every(condition => interpret(condition, object));\n};\n\nexport const not: Interpret<Compound> = (node, object, { interpret }) => {\n  return !interpret(node.value[0], object);\n};\n\nexport const eq: Interpret<Field> = (node, object, { compare, get }) => {\n  const value = get(object, node.field);\n\n  if (Array.isArray(value) && !Array.isArray(node.value)) {\n    return includes(value, node.value, compare);\n  }\n\n  return compare(value, node.value) === 0;\n};\n\nexport const ne: typeof eq = (node, object, context) => {\n  return !eq(node, object, context);\n};\n\nexport const lte = testValueOrArray<Comparable>((node, value, context) => {\n  const result = context.compare(value, node.value);\n  return result === 0 || result === -1;\n});\n\nexport const lt = testValueOrArray<Comparable>((node, value, context) => {\n  return context.compare(value, node.value) === -1;\n});\nexport const gt = testValueOrArray<Comparable>((node, value, context) => {\n  return context.compare(value, node.value) === 1;\n});\nexport const gte = testValueOrArray<Comparable>((node, value, context) => {\n  const result = context.compare(value, node.value);\n  return result === 0 || result === 1;\n});\n\nexport const exists: Interpret<Field<boolean>> = (node, object, { get }) => {\n  if (node.field === ITSELF) {\n    return typeof object !== 'undefined';\n  }\n\n  const [item, field] = getObjectFieldCursor<{}>(object, node.field, get);\n  const test = (value: {}) => !!value && value.hasOwnProperty(field) === node.value;\n\n  return isArrayAndNotNumericField(item, field) ? item.some(test) : test(item);\n};\n\nexport const mod = testValueOrArray<[number, number], number>((node, value) => {\n  return typeof value === 'number' && value % node.value[0] === node.value[1];\n});\n\nexport const size: Interpret<Field<number>, AnyObject | unknown[]> = (node, object, { get }) => {\n  const [items, field] = getObjectFieldCursor(object as AnyObject, node.field, get);\n  const test = (item: unknown) => {\n    const value = get(item, field);\n    return Array.isArray(value) && value.length === node.value;\n  };\n\n  return node.field !== ITSELF && isArrayAndNotNumericField(items, field)\n    ? items.some(test)\n    : test(items);\n};\n\nexport const regex = testValueOrArray<RegExp, string>((node, value) => {\n  return typeof value === 'string' && node.value.test(value);\n});\n\nexport const within = testValueOrArray<unknown[], unknown>((node, object, { compare }) => {\n  return includes(node.value, object, compare);\n});\n\nexport const nin: typeof within = (node, object, context) => !within(node, object, context);\n\nexport const all: Interpret<Field<unknown[]>> = (node, object, { compare, get }) => {\n  const value = get(object, node.field);\n  return Array.isArray(value) && node.value.every(v => includes(value, v, compare));\n};\n\nexport const elemMatch: Interpret<Field<Condition>> = (node, object, { interpret, get }) => {\n  const value = get(object, node.field);\n  return Array.isArray(value) && value.some(v => interpret(node.value, v));\n};\n\ntype WhereFunction = (this: AnyObject) => boolean;\nexport const where: Interpret<Document<WhereFunction>, AnyObject> = (node, object) => {\n  return node.value.call(object);\n};\n","import { createJsInterpreter } from './interpreter';\nimport * as interpreters from './interpreters';\n\nexport const allInterpreters = {\n  ...interpreters,\n  in: interpreters.within,\n};\nexport const interpret = createJsInterpreter(allInterpreters);\n"]},"metadata":{},"sourceType":"module"}