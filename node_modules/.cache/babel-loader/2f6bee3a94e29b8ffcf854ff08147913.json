{"ast":null,"code":"import { optimizedCompoundCondition as e, FieldCondition as t, CompoundCondition as r, ITSELF as n, NULL_CONDITION as o, buildAnd as a, ObjectQueryParser as i } from \"@ucast/core\";\nexport { defaultInstructionParsers as defaultParsers } from \"@ucast/core\";\nfunction f(e, t) {\n  if (!Array.isArray(t)) throw new Error('\"' + e.name + '\" expects value to be an array');\n}\nfunction u(e, t) {\n  if (f(e, t), !t.length) throw new Error('\"' + e.name + '\" expects to have at least one element in array');\n}\nvar c = function c(e) {\n    return function (t, r) {\n      if (typeof r !== e) throw new Error('\"' + t.name + '\" expects value to be a \"' + e + '\"');\n    };\n  },\n  p = {\n    type: \"compound\",\n    validate: u,\n    parse: function parse(t, r, n) {\n      var o = n.parse,\n        a = r.map(function (e) {\n          return o(e);\n        });\n      return e(t.name, a);\n    }\n  },\n  s = p,\n  l = {\n    type: \"compound\",\n    validate: u\n  },\n  d = {\n    type: \"field\",\n    validate: function validate(e, t) {\n      if (!(t && (t instanceof RegExp || t.constructor === Object))) throw new Error('\"' + e.name + '\" expects to receive either regular expression or object of field operators');\n    },\n    parse: function parse(e, n, o) {\n      var a = n instanceof RegExp ? new t(\"regex\", o.field, n) : o.parse(n, o);\n      return new r(e.name, [a]);\n    }\n  },\n  v = {\n    type: \"field\",\n    validate: function validate(e, t) {\n      if (!t || t.constructor !== Object) throw new Error('\"' + e.name + '\" expects to receive an object with nested query or field level operators');\n    },\n    parse: function parse(e, r, o) {\n      var a = o.parse,\n        i = o.field,\n        f = (0, o.hasOperators)(r) ? a(r, {\n          field: n\n        }) : a(r);\n      return new t(e.name, i, f);\n    }\n  },\n  w = {\n    type: \"field\",\n    validate: c(\"number\")\n  },\n  y = {\n    type: \"field\",\n    validate: f\n  },\n  $ = y,\n  x = y,\n  h = {\n    type: \"field\",\n    validate: function validate(e, t) {\n      if (!Array.isArray(t) || 2 !== t.length) throw new Error('\"' + e.name + '\" expects an array with 2 numeric elements');\n    }\n  },\n  m = {\n    type: \"field\",\n    validate: c(\"boolean\")\n  },\n  g = {\n    type: \"field\",\n    validate: function validate(e, t) {\n      if (!(\"string\" == typeof t || \"number\" == typeof t || t instanceof Date)) throw new Error('\"' + e.name + '\" expects value to be comparable (i.e., string, number or date)');\n    }\n  },\n  b = g,\n  E = b,\n  j = b,\n  O = {\n    type: \"field\"\n  },\n  R = O,\n  _ = {\n    type: \"field\",\n    validate: function validate(e, t) {\n      if (!(t instanceof RegExp) && \"string\" != typeof t) throw new Error('\"' + e.name + '\" expects value to be a regular expression or a string that represents regular expression');\n    },\n    parse: function parse(e, r, n) {\n      var o = \"string\" == typeof r ? new RegExp(r, n.query.$options || \"\") : r;\n      return new t(e.name, n.field, o);\n    }\n  },\n  q = {\n    type: \"field\",\n    parse: function parse() {\n      return o;\n    }\n  },\n  A = {\n    type: \"document\",\n    validate: c(\"function\")\n  },\n  N = Object.freeze({\n    __proto__: null,\n    $and: p,\n    $or: s,\n    $nor: l,\n    $not: d,\n    $elemMatch: v,\n    $size: w,\n    $in: y,\n    $nin: $,\n    $all: x,\n    $mod: h,\n    $exists: m,\n    $gte: g,\n    $gt: b,\n    $lt: E,\n    $lte: j,\n    $eq: O,\n    $ne: R,\n    $regex: _,\n    $options: q,\n    $where: A\n  });\nvar P = function (e) {\n    var t, r;\n    function n(t) {\n      return e.call(this, t, {\n        defaultOperatorName: \"$eq\",\n        operatorToConditionName: function operatorToConditionName(e) {\n          return e.slice(1);\n        }\n      }) || this;\n    }\n    return r = e, (t = n).prototype = Object.create(r.prototype), t.prototype.constructor = t, t.__proto__ = r, n.prototype.parse = function (t, r) {\n      return r && r.field ? a(this.parseFieldOperators(r.field, t)) : e.prototype.parse.call(this, t);\n    }, n;\n  }(i),\n  z = N;\nexport { x as $all, p as $and, v as $elemMatch, O as $eq, m as $exists, b as $gt, g as $gte, y as $in, E as $lt, j as $lte, h as $mod, R as $ne, $ as $nin, l as $nor, d as $not, q as $options, s as $or, _ as $regex, w as $size, A as $where, P as MongoQueryParser, z as allParsingInstructions };","map":{"version":3,"sources":["../../src/instructions.ts","../../src/MongoQueryParser.ts","../../src/index.ts"],"names":["ensureIsArray","instruction","value","Array","isArray","Error","name","ensureIsNonEmptyArray","length","Date","ensureIs","type","$and","validate","parse","queries","conditions","map","query","optimizedCompoundCondition","$or","$nor","$not","RegExp","constructor","Object","context","condition","FieldCondition","field","CompoundCondition","$elemMatch","hasOperators","ITSELF","$size","$in","$nin","$all","$mod","$exists","$gte","$gt","$lt","$lte","$eq","$ne","$regex","rawValue","$options","NULL_CONDITION","$where","MongoQueryParser","ObjectQueryParser","instructions","_ObjectQueryParser","defaultOperatorName","operatorToConditionName","slice","options","and","this","parseFieldOperators","allParsingInstructions"],"mappings":"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","sourcesContent":["import {\n  CompoundCondition,\n  FieldCondition,\n  NamedInstruction,\n  CompoundInstruction,\n  FieldInstruction,\n  DocumentInstruction,\n  Comparable,\n  ITSELF,\n  NULL_CONDITION,\n  FieldParsingContext,\n  optimizedCompoundCondition,\n  ObjectQueryFieldParsingContext,\n} from '@ucast/core';\nimport { MongoQuery } from './types';\n\nfunction ensureIsArray(instruction: NamedInstruction, value: unknown) {\n  if (!Array.isArray(value)) {\n    throw new Error(`\"${instruction.name}\" expects value to be an array`);\n  }\n}\n\nfunction ensureIsNonEmptyArray(instruction: NamedInstruction, value: unknown[]) {\n  ensureIsArray(instruction, value);\n\n  if (!value.length) {\n    throw new Error(`\"${instruction.name}\" expects to have at least one element in array`);\n  }\n}\n\nfunction ensureIsComparable(instruction: NamedInstruction, value: string | number | Date) {\n  const isComparable = typeof value === 'string' || typeof value === 'number' || value instanceof Date;\n\n  if (!isComparable) {\n    throw new Error(`\"${instruction.name}\" expects value to be comparable (i.e., string, number or date)`);\n  }\n}\n\nconst ensureIs = (type: string) => (instruction: NamedInstruction, value: unknown) => {\n  if (typeof value !== type) { // eslint-disable-line valid-typeof\n    throw new Error(`\"${instruction.name}\" expects value to be a \"${type}\"`);\n  }\n};\n\nexport const $and: CompoundInstruction<MongoQuery<any>[]> = {\n  type: 'compound',\n  validate: ensureIsNonEmptyArray,\n  parse(instruction, queries, { parse }) {\n    const conditions = queries.map(query => parse(query));\n    return optimizedCompoundCondition(instruction.name, conditions);\n  }\n};\nexport const $or = $and;\nexport const $nor: CompoundInstruction<MongoQuery<any>[]> = {\n  type: 'compound',\n  validate: ensureIsNonEmptyArray,\n};\n\nexport const $not: FieldInstruction<MongoQuery<any> | RegExp> = {\n  type: 'field',\n  validate(instruction, value) {\n    const isValid = value && (value instanceof RegExp || value.constructor === Object);\n\n    if (!isValid) {\n      throw new Error(`\"${instruction.name}\" expects to receive either regular expression or object of field operators`);\n    }\n  },\n  parse(instruction, value, context) {\n    const condition = value instanceof RegExp\n      ? new FieldCondition('regex' as typeof instruction.name, context.field, value)\n      : context.parse(value, context);\n\n    return new CompoundCondition(instruction.name, [condition]);\n  },\n};\nexport const $elemMatch: FieldInstruction<MongoQuery<any>, ObjectQueryFieldParsingContext> = {\n  type: 'field',\n  validate(instruction, value) {\n    if (!value || value.constructor !== Object) {\n      throw new Error(`\"${instruction.name}\" expects to receive an object with nested query or field level operators`);\n    }\n  },\n  parse(instruction, value, { parse, field, hasOperators }) {\n    const condition = hasOperators(value) ? parse(value, { field: ITSELF }) : parse(value);\n    return new FieldCondition(instruction.name, field, condition);\n  }\n};\n\nexport const $size: FieldInstruction<number> = {\n  type: 'field',\n  validate: ensureIs('number')\n};\nexport const $in: FieldInstruction<unknown[]> = {\n  type: 'field',\n  validate: ensureIsArray,\n};\nexport const $nin = $in;\nexport const $all = $in;\nexport const $mod: FieldInstruction<[number, number]> = {\n  type: 'field',\n  validate(instruction, value) {\n    if (!Array.isArray(value) || value.length !== 2) {\n      throw new Error(`\"${instruction.name}\" expects an array with 2 numeric elements`);\n    }\n  }\n};\n\nexport const $exists: FieldInstruction<boolean> = {\n  type: 'field',\n  validate: ensureIs('boolean'),\n};\n\nexport const $gte: FieldInstruction<Comparable> = {\n  type: 'field',\n  validate: ensureIsComparable\n};\nexport const $gt = $gte;\nexport const $lt = $gt;\nexport const $lte = $gt;\n\nexport const $eq: FieldInstruction = {\n  type: 'field',\n};\nexport const $ne = $eq;\n\nexport interface RegExpFieldContext extends FieldParsingContext {\n  query: {\n    $options?: string\n  }\n}\n\nexport const $regex: FieldInstruction<string | RegExp, RegExpFieldContext> = {\n  type: 'field',\n  validate(instruction, value) {\n    if (!(value instanceof RegExp) && typeof value !== 'string') {\n      throw new Error(`\"${instruction.name}\" expects value to be a regular expression or a string that represents regular expression`);\n    }\n  },\n  parse(instruction, rawValue, context) {\n    const value = typeof rawValue === 'string'\n      ? new RegExp(rawValue, context.query.$options || '')\n      : rawValue;\n    return new FieldCondition(instruction.name, context.field, value);\n  }\n};\nexport const $options: FieldInstruction = {\n  type: 'field',\n  parse: () => NULL_CONDITION,\n};\n\nexport const $where: DocumentInstruction<() => boolean> = {\n  type: 'document',\n  validate: ensureIs('function'),\n};\n","import {\n  Condition,\n  buildAnd as and,\n  ParsingInstruction,\n  ObjectQueryParser,\n  FieldQueryOperators,\n} from '@ucast/core';\nimport { MongoQuery } from './types';\n\nexport interface ParseOptions {\n  field: string\n}\n\nexport class MongoQueryParser extends ObjectQueryParser<MongoQuery<any>> {\n  constructor(instructions: Record<string, ParsingInstruction>) {\n    super(instructions, {\n      defaultOperatorName: '$eq',\n      operatorToConditionName: name => name.slice(1),\n    });\n  }\n\n  parse<Q extends MongoQuery<any>, FQ extends FieldQueryOperators<Q> = FieldQueryOperators<Q>>(\n    query: Q | FQ,\n    options?: ParseOptions\n  ): Condition {\n    if (options && options.field) {\n      return and(this.parseFieldOperators(options.field, query as FQ));\n    }\n\n    return super.parse(query);\n  }\n}\n","import * as instructions from './instructions';\n\nexport const allParsingInstructions = instructions;\nexport * from './instructions';\nexport * from './MongoQueryParser';\nexport * from './types';\nexport { defaultInstructionParsers as defaultParsers } from '@ucast/core';\n"]},"metadata":{},"sourceType":"module"}